<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/HansenZhao.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/HansenZhao.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/HansenZhao.github.io/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/HansenZhao.github.io/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/HansenZhao.github.io/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/HansenZhao.github.io/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/HansenZhao.github.io/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Machine Learning &amp; Coding">
<meta property="og:type" content="website">
<meta property="og:title" content="HansenZhao&#39;s Blog">
<meta property="og:url" content="https://hansenzhao.github.io/index.html">
<meta property="og:site_name" content="HansenZhao&#39;s Blog">
<meta property="og:description" content="Machine Learning &amp; Coding">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HansenZhao&#39;s Blog">
<meta name="twitter:description" content="Machine Learning &amp; Coding">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/HansenZhao.github.io/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://hansenzhao.github.io/"/>





  <title>HansenZhao's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/HansenZhao.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HansenZhao's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Share with ZhuangBiology</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/HansenZhao.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/HansenZhao.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/HansenZhao.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2018/03/08/Fun-with-your-first-Day-with-Matlab-S02E01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2018/03/08/Fun-with-your-first-Day-with-Matlab-S02E01/" itemprop="url">Fun with your first daty with Matlab S02E01</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-08T20:00:00+08:00">
                2018-03-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/MATLAB/" itemprop="url" rel="index">
                    <span itemprop="name">MATLAB</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="元胞自动机模拟程序"><a href="#元胞自动机模拟程序" class="headerlink" title="元胞自动机模拟程序"></a>元胞自动机模拟程序</h2><p>元胞自动机是复杂系统研究的经典模型。直至今天，仍然引起研究者的广泛兴趣。大名鼎鼎的“生命游戏”也是元胞自动机的一种。这种模型生动的展示了即时简单的规则的组合也能在不断的演化中产生复杂的行为。这一现象的发现人，mathmatica软件的开发者Stephen Wolfram在他写的<a href="http://www.wolframscience.com/nks/" target="_blank" rel="external">畅销书</a>中盛赞这种体系是新科学（A new kind of science)的开端。<br>尽管元胞自动机看起来逼格满满，实际上非常简单。我们可以使用MATLAB轻而易举的编写一个元胞自动机模拟的软件。<br>本文的最终程序请见 <a href="https://github.com/HansenZhao/HSToolkit/blob/master/cellularAuto.m" target="_blank" rel="external">Github</a></p>
<h3 id="元胞自动机的原理"><a href="#元胞自动机的原理" class="headerlink" title="元胞自动机的原理"></a>元胞自动机的原理</h3><p>本文仅介绍一维元胞自动机的原理，了解以后，拓展到更高维度就很容易了。<br>首先，所谓元胞，是指在一个模拟的空间中生成彼此相邻的格子，每一个格子都代表一个元胞。每一个元胞都有两个状态——生或者死，也即0或者1。元胞的状态随着时间变化，下一个回合每个元胞的状态取决于上一个回合这个元胞的状态以及其相邻的元胞状态。我们可以看到，元胞自动机在时间上和空间上都是离散的。<a href="http://mp.weixin.qq.com/s/i5x4J7806n9whTEuD5nFiQ" target="_blank" rel="external">现代科学的研究</a>也支持我们生活的世界在极为微小的尺度上是离散的而非连续的,难怪Wolfram要在自己写的书中洋洋得意了。<br>元胞自动成为复杂系统研究的经典模型还有一大因素，就是它在最简单的体系中表达了复杂系统的共性特征：相互作用个体通过简单的规则，形成复杂的整体行为<br>元胞自动机的规则就是前面提到的，下一个回合的状态是如何由上一个时刻的状态决定的。我们知道，影响下一个回合的某个元胞的状态的因素有两个：这个元胞本身状态以及其左邻右舍的状态。那么，所有可能的状态有几个呢？因为我们只考虑紧密相邻的元胞之间的相互影响，因此实际上是三个相邻的元胞状态决定下一个回合的某个元胞的状态。由于每个元胞的状态只有0和1两种情况，因此只有$2^{3}$八种可能的状态。对于八种可能的原始状态，我们完全可以枚举可能的下一个回合的状态，因此对应于每一种原始状态，在规则设定上，下一个回合都有可能是0或者1，因此规则的个数一共有$2^{8}=256$中可能的规则。<br>例如我们可以设定某一个规则，对于上一回合任何情况，除非三个相邻的元胞自动机都为0时，下一个时刻的元胞才为0。否则，下一个时刻的元胞状态为1。我们可以通过表格表示这个规则：</p>
<table>
<thead>
<tr>
<th>上一回合状态</th>
<th style="text-align:center">111</th>
<th style="text-align:center">110</th>
<th style="text-align:center">101</th>
<th style="text-align:center">100</th>
<th style="text-align:center">011</th>
<th style="text-align:center">010</th>
<th style="text-align:center">001</th>
<th style="text-align:right">000</th>
</tr>
</thead>
<tbody>
<tr>
<td>下一回合状态</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:right">0</td>
</tr>
</tbody>
</table>
<p>我们约定在写这张表的时候，上一个时刻的状态组合按照二进制的大小顺序来书写，因此在上面的表格中，上一个回合的状态分别的$7<em>{(2)}$（也就是二进制的111转换为十进制为7）,$6</em>{(2)},5<em>{(2)},4</em>{(2)},3<em>{(2)},2</em>{(2)},1<em>{(2)},0</em>{(2)}$八个二进制数字。下面的状态组合，形成一个八位的二进制数字$1111 1110$。这个二进制数字是多少呢？254。因此，这个规则就被称为254规则。 在Wolfram书中，这个规则有一个很形象的表示：<br><img src="http://oyeuye83q.bkt.clouddn.com/18-3-8/89773590.jpg" alt=""><br>我们可以使用一个二维数组来表示元胞自动机在每一个回合的状态。数组中的0或者1表示相应元胞的状态，数组的行表示每一代元胞自动机的状态组合，不同的行代表了不同代的交替。这样就可以在二维的平面上表示一维的元胞自动机的演化过程了。</p>
<h3 id="元胞自动机的MATLAB编程"><a href="#元胞自动机的MATLAB编程" class="headerlink" title="元胞自动机的MATLAB编程"></a>元胞自动机的MATLAB编程</h3><p>首先，我们要确认模拟一个元胞自动机需要哪些参数。首先，模拟时遵循的规则需要给出。其次，模拟的一维世界的长度必须给出，模拟的步数，初始条件也是必要的。除此之外，还有一个重要的参数，就是元胞自动机如何处理边界条件。<br>我们上面讨论的时候，假设了每一个元胞都有两个相邻的邻居。但是模拟的世界大小是有限的，在一维世界的边界处，左边界的元胞没有左邻局；右边界的元胞没有右邻居。应该怎么办呢？常见的解决方法有三种：</p>
<ul>
<li>常数补充：将缺失的邻居补充为0或者1</li>
<li>扩展补充：将缺失的邻居补充为自己本身</li>
<li>卷曲补充：想象一维世界是一个环，那么左边界的左邻局其实就是右边界，反之亦然。</li>
</ul>
<p>因此，我们需要一个参数来设定世界边界的补充方式<br>最后，我们设定一个参数来确定是否模拟完成就把结果显示出来。</p>
<h4 id="MATLAB中的参数检测"><a href="#MATLAB中的参数检测" class="headerlink" title="MATLAB中的参数检测"></a>MATLAB中的参数检测</h4><p>MATLAB中的函数是输入一个或者几个参数，返回结果的东西。函数相比于脚本，将参数的设置与计算逻辑隔离开来，从而更容易让程序得到复用。MATLAB中的函数的书写格式一般是这样的：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="params">[返回值]</span> = 函数名<span class="params">(参数1，参数2...)</span></span></div><div class="line">    函数体（处理逻辑）</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>其中，函数体的部分与脚本的书写基本一致。返回值的数值在函数体内部被赋值完成。<br>我们前面提到，元胞自动机的参数一共有6个。想象一下如果每次我们用这个函数都需要输入6个参数，是不是很麻烦。因此，我们可以在函数体内对参数的存在与否进行检测，如果用户赋值了，就按照用户的赋值来，如果用户没有赋值，我们就给予默认值。这样的话，用户在不必要的时候就不需要给定赋值了。我们看这部分的代码：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ histArray ]</span> = <span class="title">cellularAuto</span><span class="params">( rules,len,steps,init,world,isShow )</span></span></div><div class="line">    <span class="comment">% 规则编号</span></div><div class="line">    <span class="keyword">if</span> ~exist(<span class="string">'rules'</span>,<span class="string">'var'</span>) <span class="comment">%检查是否存在叫rules的变量，如果没有就赋值为110</span></div><div class="line">        rules = <span class="number">110</span>;</div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="comment">% 一维世界长度</span></div><div class="line">    <span class="keyword">if</span> ~exist(<span class="string">'len'</span>,<span class="string">'var'</span>)</div><div class="line">        len = <span class="number">21</span>;</div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="comment">% 模拟回合数</span></div><div class="line">    <span class="keyword">if</span> ~exist(<span class="string">'steps'</span>,<span class="string">'var'</span>)</div><div class="line">        steps = <span class="number">100</span>;</div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="comment">% 原始赋值</span></div><div class="line">    <span class="keyword">if</span> ~exist(<span class="string">'init'</span>,<span class="string">'var'</span>)</div><div class="line">        init = randi(<span class="number">2</span>,[<span class="number">1</span>,len])<span class="number">-1</span>;</div><div class="line">    <span class="keyword">elseif</span> <span class="built_in">size</span>(init,<span class="number">2</span>)~= len</div><div class="line">        <span class="comment">% 如果原始赋值向量长度与设定一维世界长度不同，报错退出</span></div><div class="line">        error(<span class="string">'Init condition size: %d is not equal to the length: %d\n'</span>,<span class="built_in">size</span>(init,<span class="number">2</span>),len);</div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="comment">% 边界处理模式</span></div><div class="line">    <span class="keyword">if</span> ~exist(<span class="string">'world'</span>,<span class="string">'var'</span>)</div><div class="line">        world = <span class="string">'zero'</span>;</div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="comment">% 是否展示结果</span></div><div class="line">    <span class="keyword">if</span> ~exist(<span class="string">'isShow'</span>,<span class="string">'var'</span>)</div><div class="line">        isShow = <span class="number">1</span>;</div><div class="line">    <span class="keyword">end</span></div><div class="line">    ..........</div></pre></td></tr></table></figure></p>
<p>我们命名了一个叫做$cellularAuto$的函数，拥有6个输入参数，1个输出结果$histArray$。这个结果就是上面说的表示元胞自动机演化过程的二维数组。这里使用的是$exist$函数检测是否存在特定的变量。</p>
<h4 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h4><p>我们首先生成一个矩阵保存结果，同时也是函数的输出值<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">histArray = [init;zeros(steps<span class="number">-1</span>,len)];</div></pre></td></tr></table></figure></p>
<p>这里直接建立了一个二维数组。数组的第一行是用户指定的或者随机生成的一维01序列；后面的模拟回合数-1行一开始全部填充为0。然后我们对规则进行一定的前处理。前面说到的11111110规则也即254规则是通过将8位的二进制转化为10进制得到的。因此我们在程序中首先要对10进制的规则编号重新转化为原来的8位二进制。我们首先将规则编号转化为8位的数字<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rules = uint8(rules);</div></pre></td></tr></table></figure></p>
<p>我们将rules通过$uint8$函数转化为了无符号的8位整数。那么，想要取得每一个上一回合组合对应的下一个回合应该的状态，我们可以寻找这个8位整数对应的二进制位的数值。例如，我想知道在这个规则下，上一个回合是111的时候，这个回合应该存在的状态，我们可以寻找这个规则（254规则）的第8位上的数字。如何实现呢？使用的是$bitget$函数。$bitget$函数接受两个参数，第一个参数是一个数字，第二个参数是位的编号。比如我想知道254号的第8位是多少，只需要使用<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bitget(<span class="number">254</span>,<span class="number">8</span>)</div><div class="line"><span class="built_in">ans</span> = <span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>即可。其中，第二个参数也可以是矩阵，我们因此可以批量的进行这个操作。另外，这里面还有一点窍门。例如上一个回合的状态是111，那么上一个时刻的状态的10进制表示就是7，正好是对应的检索位数（8）减去1的结果。这个窍门成立的原因就是我们前面严格的约定了规则表格的书写方式。<br>下面，我们可以很简单的想到可以通过一个循环语句来进行模拟，每次模拟一步<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> m = <span class="number">2</span>:<span class="number">1</span>:steps</div><div class="line">    模拟一步......</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>那么每一步怎么模拟呢？我们首先针对world参数的赋值，补全上一个回合的边界状态<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">tmp = histArray(m<span class="number">-1</span>,:); <span class="comment">%将上一个回合的状态取出</span></div><div class="line"><span class="keyword">switch</span> world</div><div class="line">    <span class="keyword">case</span> <span class="string">'zero'</span></div><div class="line">        tmp = [<span class="number">0</span>,tmp,<span class="number">0</span>]; <span class="comment">%边界补0</span></div><div class="line">    <span class="keyword">case</span> <span class="string">'one'</span></div><div class="line">        tmp = [<span class="number">1</span>,tmp,<span class="number">1</span>]; <span class="comment">%边界补1</span></div><div class="line">    <span class="keyword">case</span> <span class="string">'extend'</span></div><div class="line">        tmp = [tmp(<span class="number">1</span>),tmp,tmp(end)]; <span class="comment">%边界扩展</span></div><div class="line">    <span class="keyword">case</span> <span class="string">'wrap'</span></div><div class="line">        tmp = [tmp(end),tmp,tmp(<span class="number">1</span>)]; <span class="comment">%边界卷曲</span></div><div class="line">    <span class="keyword">otherwise</span></div><div class="line">        tmp = [<span class="number">0</span>,tmp,<span class="number">0</span>];</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>由于上一个回合的状态本身就是一个行向量，因此我们补全的过程就是给行向量的头和尾扩展一个元素。这里面使用了一个MATLAB的语法糖（就是语法中为开发者提供的便利语法）。在对向量进行索引的时候，end表示最后一个元素。<br>补充完上一个回合的边界状态以后，我们想要得到每一个对应位置的状态。这个地方比较抽象，我们假设一个简单的情况。例如上一个状态是 1 1 0 1 0，我们采用全0补全以后，变成了0 1 1 0 1 0 0。这是一个1x7的行向量。那么，对应下一个时刻的第一个元胞的状态就是 0 1 1，第二个就是 1 1 0。下一个回合第一个元胞对应上一个时刻【补充以后的元胞组】的索引是1,2,3；第二个就是2,3,4。是不是发现了规律了呢？我们可以直接将上一个时刻补充后元胞状态组1x7的向量转化为3x5的矩阵。其中每一列是对应位置的上一个时刻的状态。<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mat = [tmp(<span class="number">1</span>:(end<span class="number">-2</span>));tmp(<span class="number">2</span>:(end<span class="number">-1</span>));tmp(<span class="number">3</span>:end)];</div></pre></td></tr></table></figure></p>
<p>根据这样的操作，补充后的0 1 1 0 1 0 0数组就会变成这样的一个矩阵</p>
<table>
<thead>
<tr>
<th>0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">1</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td>1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<p>看，是不是第一列对应了第一个位置上一回合的状态，第二列对应了第二个位置上一回合的状态？下一步，我们需要从这个矩阵中获取8位规则的索引。上面提到的111的索引是$7+1=8$。实际上，就是$1<em>2^2+1</em>2^1+1*2^0+1=8$因此，我们只要将上面的矩阵的第一列乘以4，第二列乘以2最后一列乘以1最后再每列求和再加1就好。这样的操作就是：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">condition = sum(mat.*<span class="built_in">repmat</span>([<span class="number">4</span>;<span class="number">2</span>;<span class="number">1</span>],<span class="number">1</span>,len))+<span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>这里的repmat函数将[4;2;1]列向量在重复铺展了1行len这么多列，目的是使得其大小与mat变量大小一致，才能进行按位乘的矩阵操作。最后使用前面说的$bitget$函数查找出来这个时刻应该的状态,就好了，并赋值到histArray的相应位置就好了。<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">res = bitget(rules,condition);</div><div class="line">histArray(m,:) = res;</div></pre></td></tr></table></figure></p>
<p>全部的代码是这样的:<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ histArray ]</span> = <span class="title">cellularAuto</span><span class="params">( rules,len,steps,init,world,isShow )</span></span></div><div class="line">    <span class="keyword">if</span> ~exist(<span class="string">'rules'</span>,<span class="string">'var'</span>)</div><div class="line">        rules = <span class="number">110</span>;</div><div class="line">    <span class="keyword">end</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ~exist(<span class="string">'len'</span>,<span class="string">'var'</span>)</div><div class="line">        len = <span class="number">21</span>;</div><div class="line">    <span class="keyword">end</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ~exist(<span class="string">'steps'</span>,<span class="string">'var'</span>)</div><div class="line">        steps = <span class="number">100</span>;</div><div class="line">    <span class="keyword">end</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ~exist(<span class="string">'init'</span>,<span class="string">'var'</span>)</div><div class="line">        init = randi(<span class="number">2</span>,[<span class="number">1</span>,len])<span class="number">-1</span>;</div><div class="line">    <span class="keyword">elseif</span> <span class="built_in">size</span>(init,<span class="number">2</span>)~= len</div><div class="line">        error(<span class="string">'Init condition size: %d is not equal to the length: %d\n'</span>,<span class="built_in">size</span>(init,<span class="number">2</span>),len);</div><div class="line">    <span class="keyword">end</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ~exist(<span class="string">'world'</span>,<span class="string">'var'</span>)</div><div class="line">        world = <span class="string">'zero'</span>;</div><div class="line">    <span class="keyword">end</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ~exist(<span class="string">'isShow'</span>,<span class="string">'var'</span>)</div><div class="line">        isShow = <span class="number">1</span>;</div><div class="line">    <span class="keyword">end</span></div><div class="line">    </div><div class="line">    histArray = [init;zeros(steps<span class="number">-1</span>,len)];</div><div class="line">    rules = uint8(rules);</div><div class="line">    <span class="keyword">for</span> m = <span class="number">2</span>:<span class="number">1</span>:steps</div><div class="line">        tmp = histArray(m<span class="number">-1</span>,:);</div><div class="line">        <span class="keyword">switch</span> world</div><div class="line">            <span class="keyword">case</span> <span class="string">'zero'</span></div><div class="line">                tmp = [<span class="number">0</span>,tmp,<span class="number">0</span>];</div><div class="line">            <span class="keyword">case</span> <span class="string">'one'</span></div><div class="line">                tmp = [<span class="number">1</span>,tmp,<span class="number">1</span>];</div><div class="line">            <span class="keyword">case</span> <span class="string">'extend'</span></div><div class="line">                tmp = [tmp(<span class="number">1</span>),tmp,tmp(end)];</div><div class="line">            <span class="keyword">case</span> <span class="string">'wrap'</span></div><div class="line">                tmp = [tmp(end),tmp,tmp(<span class="number">1</span>)];</div><div class="line">            <span class="keyword">otherwise</span></div><div class="line">                tmp = [<span class="number">0</span>,tmp,<span class="number">0</span>];</div><div class="line">        <span class="keyword">end</span></div><div class="line">        mat = [tmp(<span class="number">1</span>:(end<span class="number">-2</span>));tmp(<span class="number">2</span>:(end<span class="number">-1</span>));tmp(<span class="number">3</span>:end)];</div><div class="line">        condition = sum(mat.*<span class="built_in">repmat</span>([<span class="number">4</span>;<span class="number">2</span>;<span class="number">1</span>],<span class="number">1</span>,len))+<span class="number">1</span>;</div><div class="line">        res = bitget(rules,condition);</div><div class="line">        histArray(m,:) = res;</div><div class="line">    <span class="keyword">end</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> isShow</div><div class="line">        figure;</div><div class="line">        imagesc(histArray); colormap([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]);</div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<h3 id="玩转元胞自动机"><a href="#玩转元胞自动机" class="headerlink" title="玩转元胞自动机"></a>玩转元胞自动机</h3><p>至此，我们的编程也就完了，是不是很简单？我们可以全部使用默认设置玩一下<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cellularAuto; <span class="comment">%无任何参数，全部使用默认值</span></div></pre></td></tr></table></figure></p>
<p>两次模拟的结果。其中每一行就是一维世界的一个状态，每一列代表一次模拟，由上到下是时间维度。</p>
<p><img src="http://oyeuye83q.bkt.clouddn.com/18-3-8/48934686.jpg" alt=""></p>
<p>我们还可以使用110规则模拟一个一万长度的一维世界的一万次变化的结果：</p>
<p><img src="http://oyeuye83q.bkt.clouddn.com/18-3-8/87004660.jpg" alt=""></p>
<p>怎么样，很有意思吧！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2018/03/06/Notes of A new kind of science-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2018/03/06/Notes of A new kind of science-02/" itemprop="url">Notes of A new kind of Science-01</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-06T13:00:00+08:00">
                2018-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/General-Science/" itemprop="url" rel="index">
                    <span itemprop="name">General Science</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Chapter-01-The-Foundations-for-a-New-Kind-of-Science"><a href="#Chapter-01-The-Foundations-for-a-New-Kind-of-Science" class="headerlink" title="Chapter 01: The Foundations for a New Kind of Science"></a>Chapter 01: The Foundations for a New Kind of Science</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><h4 id="传统科学是否能真正的解释自然？"><a href="#传统科学是否能真正的解释自然？" class="headerlink" title="传统科学是否能真正的解释自然？"></a>传统科学是否能真正的解释自然？</h4><blockquote>
<p>If theoretical science is to be possible, then at some level the systems it studies must follow definite rules…But the crucial realization that led me to develop the new kind of science in this book is that there is in fact no reason to think that systems ike those we see in nature should follow only such traditional mathematical rules.</p>
</blockquote>
<h4 id="计算可能是是相比于数学更普适的描述自然的方法"><a href="#计算可能是是相比于数学更普适的描述自然的方法" class="headerlink" title="计算可能是是相比于数学更普适的描述自然的方法"></a>计算可能是是相比于数学更普适的描述自然的方法</h4><ul>
<li>想法：这里使用计算而非计算机，主要是因为我认为现代的计算机架构未必就是最优化的形式。现代计算机的运行基本上是线性的，独立的，不同计算单元之间的联系是非常复杂的。但是元胞自动机以及自然界中存在的计算本质上是多核心（去中心化），并行以及非线性的。不同个体之间的联系是本征的。并行化与相互作用是自然产生复杂现象的必要条件。</li>
</ul>
<h4 id="简单的规则也可以产生复杂的行为（元胞自动机）"><a href="#简单的规则也可以产生复杂的行为（元胞自动机）" class="headerlink" title="简单的规则也可以产生复杂的行为（元胞自动机）"></a>简单的规则也可以产生复杂的行为（元胞自动机）</h4><h4 id="已有的科学范式将整体分解为部分，并仔细的研究各个部分的性质（蛋白）"><a href="#已有的科学范式将整体分解为部分，并仔细的研究各个部分的性质（蛋白）" class="headerlink" title="已有的科学范式将整体分解为部分，并仔细的研究各个部分的性质（蛋白）"></a>已有的科学范式将整体分解为部分，并仔细的研究各个部分的性质（蛋白）</h4><ul>
<li>想法：【科学】的思维模式也被广泛的应用到了社会治理至少。工人们和学生们一天中大部分的时间扮演了机器上的一颗螺丝钉，其独特的情感以及创造性被忽略且被视为社会机器的一个组成部分。只有当下班或者下课以后，他们的生命才再次鲜活起来，变成了了一个真正的人，尽管还要与劳作以后的疲惫奋战。</li>
</ul>
<blockquote>
<p>In the existing sciences much of the emphasis over the past century or so has been on breaking systems down to find their underlying parts, then trying to analyze these parts in as much detail as possible.</p>
</blockquote>
<h4 id="计算等价定理（Principle-of-Computational-Equivalence）"><a href="#计算等价定理（Principle-of-Computational-Equivalence）" class="headerlink" title="计算等价定理（Principle of Computational Equivalence）"></a>计算等价定理（Principle of Computational Equivalence）</h4><ul>
<li>想法：不同的观察视角是否会对复杂性产生不同的认识？复杂性显然的与时间和空间的次序相关，但是与观测的智能是否相关呢？是否观测的角度导致的复杂性？在【rule space】中观测是否就简单了？</li>
</ul>
<blockquote>
<p>Whenever one sees behavior that is not obviously simple, in essentially any system, it can be thought of as corresponding to a computation of equivalent sophistication.</p>
</blockquote>
<h4 id="传统的数学公式表达仅仅适用于少部分体系"><a href="#传统的数学公式表达仅仅适用于少部分体系" class="headerlink" title="传统的数学公式表达仅仅适用于少部分体系"></a>传统的数学公式表达仅仅适用于少部分体系</h4><blockquote>
<p>But the great historical successes of theoretical science have typically revolved around finding mathematical formulas that instead directly allow one to predict the outcome…And the principle of Computational Equivalence now implies that this will normally be possible only for rather special system with simple behavior.</p>
</blockquote>
<h4 id="理论科学是否存在极限，极限在哪里？极限以外是否还是人能够理解的世界？"><a href="#理论科学是否存在极限，极限在哪里？极限以外是否还是人能够理解的世界？" class="headerlink" title="理论科学是否存在极限，极限在哪里？极限以外是否还是人能够理解的世界？"></a>理论科学是否存在极限，极限在哪里？极限以外是否还是人能够理解的世界？</h4><blockquote>
<p>So this implies that there is in a sense a fundamental limitation to theoretical science. </p>
<p>But it also shows that there is something irreducible that can be achieved by the passage of time. And it leads to an explanation of how we as humans—even though we may follow definite underlying rules—can still in a meaningful way show free will.</p>
</blockquote>
<ul>
<li><p>想法：作者联系到的“自由意志”看似是无稽之谈，但是也有一定道理。用数学和理论描述世界的思想尽管是科学的主流。但是将这种方法论极致的推广导致的结果就是我们开始怀疑是否存在【自由意志】。</p>
</li>
<li><p>想法：是否可以存在一种理论工具预测元胞自动机的发展趋势</p>
</li>
</ul>
<h4 id="人类没有什么特别的"><a href="#人类没有什么特别的" class="headerlink" title="人类没有什么特别的"></a>人类没有什么特别的</h4><blockquote>
<p>One feature of many of the most important advances in science throughout history is that they show new ways in which we as humans are not special. And at some level the Principle of Computational Equivalence does this as well. For it implies that when it comes to computation—or intelligence—we are in the end no more sophisticated than all sorts of simple programs, and all sorts of systems in nature.</p>
</blockquote>
<h3 id="与其他学科的联系"><a href="#与其他学科的联系" class="headerlink" title="与其他学科的联系"></a>与其他学科的联系</h3><h4 id="数学：作者认为元胞自动机是一种更广泛意义上的数学"><a href="#数学：作者认为元胞自动机是一种更广泛意义上的数学" class="headerlink" title="数学：作者认为元胞自动机是一种更广泛意义上的数学"></a>数学：作者认为元胞自动机是一种更广泛意义上的数学</h4><blockquote>
<p>And one of the consequences of this complexity is that it leads to fundamental limitations on the idea of proof that has been central to traditional mathematics…Yet what the discoveries in this book show is that this is largely just a reflection of how small the scope is of what is now considered mathematics. And indeed the core of this book can be viewed as introducing a major generalization of mathematics—with new ideas and methods, and vast new areas to be explored.</p>
</blockquote>
<h4 id="物理"><a href="#物理" class="headerlink" title="物理"></a>物理</h4><blockquote>
<p>The traditional mathematical approach to science has historically had its great success in physics—and by now it has become almost universally assumed that any serious physical theory must be based on mathematical equations. Yet with this approach there are still many common physical phenomena about which physics has had remarkably little to say. But with the approach of thinking in terms of simple programs that I develop in this book it finally seems possible to make some dramatic progress. And indeed in the course of the book we will see that some extremely simple programs seem able to capture the essential mechanisms for a great many physical phenomena that have previously seemed completely mysterious.</p>
</blockquote>
<h5 id="传统物理多使用连续数值，微积分以及概率；元胞自动机本质是离散的；简单的规则组合形成了复杂的行为"><a href="#传统物理多使用连续数值，微积分以及概率；元胞自动机本质是离散的；简单的规则组合形成了复杂的行为" class="headerlink" title="传统物理多使用连续数值，微积分以及概率；元胞自动机本质是离散的；简单的规则组合形成了复杂的行为"></a>传统物理多使用连续数值，微积分以及概率；元胞自动机本质是离散的；简单的规则组合形成了复杂的行为</h5><h5 id="传统物理多是理想化的建立在数学上的关系；元胞自动机可以表达更复杂的关系"><a href="#传统物理多是理想化的建立在数学上的关系；元胞自动机可以表达更复杂的关系" class="headerlink" title="传统物理多是理想化的建立在数学上的关系；元胞自动机可以表达更复杂的关系"></a>传统物理多是理想化的建立在数学上的关系；元胞自动机可以表达更复杂的关系</h5><h4 id="生物：传统生物学细节了解的多，但是却缺乏统一的理论"><a href="#生物：传统生物学细节了解的多，但是却缺乏统一的理论" class="headerlink" title="生物：传统生物学细节了解的多，但是却缺乏统一的理论"></a>生物：传统生物学细节了解的多，但是却缺乏统一的理论</h4><blockquote>
<p>Vast amounts are now known about the details of biological organisms, but very little in the way of general theory has ever emerged.</p>
<p>And part of the reason for this is that traditional mathematical models have never seemed to come even close to capturing the kind of complexity we see in biology. </p>
</blockquote>
<h4 id="社会科学"><a href="#社会科学" class="headerlink" title="社会科学"></a>社会科学</h4><ul>
<li>想法：社会科学，环境科学，天体科学的变化周期长，难以在短期内获得重复性数据。从容易掌控和重复的微观体系入手研究复杂体系行为；再寻找微观复杂体系的行为与宏观复杂体系行为之间的关系，从而间接的探究宏观体系的动力学本质</li>
</ul>
<blockquote>
<p>From economics to psychology there has been a widespread if controversial assumption—no doubt from the success of the physical sciences—that solid theories must always be formulated in terms of numbers, equations and traditional mathematics. </p>
</blockquote>
<h4 id="计算机科学-从专家型的编程变为通用型-自组织的编程"><a href="#计算机科学-从专家型的编程变为通用型-自组织的编程" class="headerlink" title="计算机科学:从专家型的编程变为通用型+自组织的编程"></a>计算机科学:从专家型的编程变为通用型+自组织的编程</h4><ul>
<li>想法：例如机器学习、遗传算法等方法的发展代表了这种趋势</li>
</ul>
<blockquote>
<p>Throughout its brief history computer science has focused almost exclusively on studying specific computational systems set up to perform particular tasks. But one of the core ideas of this book is to consider the more general scientific question of what arbitrary computational systems do. </p>
</blockquote>
<h4 id="哲学"><a href="#哲学" class="headerlink" title="哲学"></a>哲学</h4><h4 id="艺术"><a href="#艺术" class="headerlink" title="艺术"></a>艺术</h4><h4 id="技术：去中心化的控制，进化的功能实现"><a href="#技术：去中心化的控制，进化的功能实现" class="headerlink" title="技术：去中心化的控制，进化的功能实现"></a>技术：去中心化的控制，进化的功能实现</h4><ul>
<li>Despite all its success, there is still much that goes on in nature that seems more complex and sophisticated than anything technology has ever been able to produce. But what the discoveries in this book now show is that by using the types of rules embodied in simple programs one can capture many of the essential mechanisms of nature. And from this it becomes possible to imagine a whole new kind of technology that in effect achieves the same sophistication as nature. </li>
</ul>
<h3 id="相关领域"><a href="#相关领域" class="headerlink" title="相关领域"></a>相关领域</h3><h4 id="人工智能：遭遇瓶颈"><a href="#人工智能：遭遇瓶颈" class="headerlink" title="人工智能：遭遇瓶颈"></a>人工智能：遭遇瓶颈</h4><blockquote>
<p> And in the 1960s the field of artificial intelligence grew up with the goal of understanding processes of human thinking and implementing them on computers. But doing this turned out to be much more difficult than expected, and after some spin-offs, little fundamental progress was made. At some level, however, the basic problem has always been to understand how the seemingly simple components in a brain can lead to all the complexities of thinking</p>
</blockquote>
<h4 id="合成生命-Artificial-Life"><a href="#合成生命-Artificial-Life" class="headerlink" title="合成生命(Artificial Life)"></a>合成生命(Artificial Life)</h4><blockquote>
<p>Most active from the mid-1980s to the mid-1990s, the field of artificial life concerned itself mainly with showing that computer programs could be made to emulate various features of biological systems. But normally it was assumed that the necessary programs would have to be quite complex. What the discoveries in this book show, however, is that in fact very simple programs can be sufficient.</p>
</blockquote>
<h4 id="突变理论"><a href="#突变理论" class="headerlink" title="突变理论"></a>突变理论</h4><blockquote>
<p>Traditional mathematical models are normally based on quantities that vary continuously. Yet in nature discrete changes are often seen. Popular in the 1970s, catastrophe theory was concerned with showing that even in traditional mathematical models, certain simple discrete changes could still occur. </p>
</blockquote>
<h4 id="混沌理论"><a href="#混沌理论" class="headerlink" title="混沌理论"></a>混沌理论</h4><blockquote>
<p>Indeed, all that it shows is that if there is complexity in the details of the initial conditions, then this complexity will eventually appear in the large-scale behavior of the system. But if the initial conditions are simple, then there is no reason for the behavior not to be correspondingly simple. What I show in this book, however, is that even when their initial conditions are very simple there are many systems that still produce highly complex behavior. And I argue that it is this phenomenon that is for example responsible for most of the obvious complexity we see in nature.</p>
</blockquote>
<h4 id="复杂性理论"><a href="#复杂性理论" class="headerlink" title="复杂性理论"></a>复杂性理论</h4><blockquote>
<p>One feature of the new kind of science that I describe in this book is that it finally makes possible the development of a basic understanding of the general phenomenon of complexity, and its origins.</p>
</blockquote>
<h4 id="计算复杂度理论"><a href="#计算复杂度理论" class="headerlink" title="计算复杂度理论"></a>计算复杂度理论</h4><blockquote>
<p>Developed mostly in the 1970s, computational complexity theory attempts to characterize how difficult certain computational tasks are to perform. Its concrete results have tended to be based on fairly specific programs with complicated structure yet rather simple behavior. The new kind of science in this book, however, explores much more general classes of programs—and in doing so begins to shed new light on various longstanding questions in computational complexity theory.</p>
</blockquote>
<h4 id="控制论-Cybernetics"><a href="#控制论-Cybernetics" class="headerlink" title="控制论 (Cybernetics)"></a>控制论 (Cybernetics)</h4><h4 id="动力系统理论"><a href="#动力系统理论" class="headerlink" title="动力系统理论"></a>动力系统理论</h4><blockquote>
<p>But what I argue in this book is that in fact the behavior of many systems is fundamentally too complex to be usefully captured in any such way.</p>
</blockquote>
<h4 id="进化理论"><a href="#进化理论" class="headerlink" title="进化理论"></a>进化理论</h4><blockquote>
<p>And indeed I will argue in this book that in many respects it(natural selection) tends to oppose complexity. But the discoveries in the book suggest a new and quite different mechanism that I believe is in fact responsible for most of the examples of great complexity that we see in biology.</p>
</blockquote>
<h4 id="实验数学"><a href="#实验数学" class="headerlink" title="实验数学"></a>实验数学</h4><h4 id="分形"><a href="#分形" class="headerlink" title="分形"></a>分形</h4><h4 id="系统理论"><a href="#系统理论" class="headerlink" title="系统理论"></a>系统理论</h4><h4 id="纳米技术"><a href="#纳米技术" class="headerlink" title="纳米技术"></a>纳米技术</h4><h4 id="非线性动力学"><a href="#非线性动力学" class="headerlink" title="非线性动力学"></a>非线性动力学</h4><h4 id="科学计算"><a href="#科学计算" class="headerlink" title="科学计算"></a>科学计算</h4><h4 id="自组织"><a href="#自组织" class="headerlink" title="自组织"></a>自组织</h4><h4 id="统计力学"><a href="#统计力学" class="headerlink" title="统计力学"></a>统计力学</h4><h3 id="作者自传"><a href="#作者自传" class="headerlink" title="作者自传"></a>作者自传</h3><blockquote>
<p>So I thought that perhaps I could do something similar in natural science: that there might be some appropriate primitives that I could find that would successfully capture a vast range of natural phenomena.</p>
<p>There were in many cases well-established mathematical models for the individual components of such systems. But two practical issues stood in the way of using these as a basis for simulations. First, the models were usually quite complicated, so that with realistic computer resources it was very difficult to include enough components for interesting phenomena to occur. And second, even if one did see such phenomena, it was almost impossible to tell whether in fact they were genuine consequences of the underlying models or were just the result of approximations made in implementing the models on a computer.</p>
<p>My early discoveries about the behavior of cellular automata stimulated a fair amount of activity in the scientific community. And by the mid-1980s, many applications had been found in physics, biology, computer science, mathematics and elsewhere. And indeed some of the phenomena I had discovered were starting to be used as the basis for a new area of research that I called complex systems theory.</p>
<p>The typical issue was that there was some core problem that traditional methods or intuition had never successfully been able to address—and which the field had somehow grown to avoid. Yet over and over again I was excited to find that with my new kind of science I could suddenly begin to make great progress—even on problems that in some cases had remained unanswered for centuries.</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2018/03/06/Notes of A new kind of science-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2018/03/06/Notes of A new kind of science-01/" itemprop="url">Notes of A new kind of Science-01</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-06T13:00:00+08:00">
                2018-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/General-Science/" itemprop="url" rel="index">
                    <span itemprop="name">General Science</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Chapter-01-The-Foundations-for-a-New-Kind-of-Science"><a href="#Chapter-01-The-Foundations-for-a-New-Kind-of-Science" class="headerlink" title="Chapter 01: The Foundations for a New Kind of Science"></a>Chapter 01: The Foundations for a New Kind of Science</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><h4 id="传统科学是否能真正的解释自然？"><a href="#传统科学是否能真正的解释自然？" class="headerlink" title="传统科学是否能真正的解释自然？"></a>传统科学是否能真正的解释自然？</h4><blockquote>
<p>If theoretical science is to be possible, then at some level the systems it studies must follow definite rules…But the crucial realization that led me to develop the new kind of science in this book is that there is in fact no reason to think that systems ike those we see in nature should follow only such traditional mathematical rules.</p>
</blockquote>
<h4 id="计算可能是是相比于数学更普适的描述自然的方法"><a href="#计算可能是是相比于数学更普适的描述自然的方法" class="headerlink" title="计算可能是是相比于数学更普适的描述自然的方法"></a>计算可能是是相比于数学更普适的描述自然的方法</h4><ul>
<li>想法：这里使用计算而非计算机，主要是因为我认为现代的计算机架构未必就是最优化的形式。现代计算机的运行基本上是线性的，独立的，不同计算单元之间的联系是非常复杂的。但是元胞自动机以及自然界中存在的计算本质上是多核心（去中心化），并行以及非线性的。不同个体之间的联系是本征的。并行化与相互作用是自然产生复杂现象的必要条件。</li>
</ul>
<h4 id="简单的规则也可以产生复杂的行为（元胞自动机）"><a href="#简单的规则也可以产生复杂的行为（元胞自动机）" class="headerlink" title="简单的规则也可以产生复杂的行为（元胞自动机）"></a>简单的规则也可以产生复杂的行为（元胞自动机）</h4><h4 id="已有的科学范式将整体分解为部分，并仔细的研究各个部分的性质（蛋白）"><a href="#已有的科学范式将整体分解为部分，并仔细的研究各个部分的性质（蛋白）" class="headerlink" title="已有的科学范式将整体分解为部分，并仔细的研究各个部分的性质（蛋白）"></a>已有的科学范式将整体分解为部分，并仔细的研究各个部分的性质（蛋白）</h4><ul>
<li>想法：【科学】的思维模式也被广泛的应用到了社会治理至少。工人们和学生们一天中大部分的时间扮演了机器上的一颗螺丝钉，其独特的情感以及创造性被忽略且被视为社会机器的一个组成部分。只有当下班或者下课以后，他们的生命才再次鲜活起来，变成了了一个真正的人，尽管还要与劳作以后的疲惫奋战。</li>
</ul>
<blockquote>
<p>In the existing sciences much of the emphasis over the past century or so has been on breaking systems down to find their underlying parts, then trying to analyze these parts in as much detail as possible.</p>
</blockquote>
<h4 id="计算等价定理（Principle-of-Computational-Equivalence）"><a href="#计算等价定理（Principle-of-Computational-Equivalence）" class="headerlink" title="计算等价定理（Principle of Computational Equivalence）"></a>计算等价定理（Principle of Computational Equivalence）</h4><ul>
<li>想法：不同的观察视角是否会对复杂性产生不同的认识？复杂性显然的与时间和空间的次序相关，但是与观测的智能是否相关呢？是否观测的角度导致的复杂性？在【rule space】中观测是否就简单了？</li>
</ul>
<blockquote>
<p>Whenever one sees behavior that is not obviously simple, in essentially any system, it can be thought of as corresponding to a computation of equivalent sophistication.</p>
</blockquote>
<h4 id="传统的数学公式表达仅仅适用于少部分体系"><a href="#传统的数学公式表达仅仅适用于少部分体系" class="headerlink" title="传统的数学公式表达仅仅适用于少部分体系"></a>传统的数学公式表达仅仅适用于少部分体系</h4><blockquote>
<p>But the great historical successes of theoretical science have typically revolved around finding mathematical formulas that instead directly allow one to predict the outcome…And the principle of Computational Equivalence now implies that this will normally be possible only for rather special system with simple behavior.</p>
</blockquote>
<h4 id="理论科学是否存在极限，极限在哪里？极限以外是否还是人能够理解的世界？"><a href="#理论科学是否存在极限，极限在哪里？极限以外是否还是人能够理解的世界？" class="headerlink" title="理论科学是否存在极限，极限在哪里？极限以外是否还是人能够理解的世界？"></a>理论科学是否存在极限，极限在哪里？极限以外是否还是人能够理解的世界？</h4><blockquote>
<p>So this implies that there is in a sense a fundamental limitation to theoretical science. </p>
<p>But it also shows that there is something irreducible that can be achieved by the passage of time. And it leads to an explanation of how we as humans—even though we may follow definite underlying rules—can still in a meaningful way show free will.</p>
</blockquote>
<ul>
<li><p>想法：作者联系到的“自由意志”看似是无稽之谈，但是也有一定道理。用数学和理论描述世界的思想尽管是科学的主流。但是将这种方法论极致的推广导致的结果就是我们开始怀疑是否存在【自由意志】。</p>
</li>
<li><p>想法：是否可以存在一种理论工具预测元胞自动机的发展趋势</p>
</li>
</ul>
<h4 id="人类没有什么特别的"><a href="#人类没有什么特别的" class="headerlink" title="人类没有什么特别的"></a>人类没有什么特别的</h4><blockquote>
<p>One feature of many of the most important advances in science throughout history is that they show new ways in which we as humans are not special. And at some level the Principle of Computational Equivalence does this as well. For it implies that when it comes to computation—or intelligence—we are in the end no more sophisticated than all sorts of simple programs, and all sorts of systems in nature.</p>
</blockquote>
<h3 id="与其他学科的联系"><a href="#与其他学科的联系" class="headerlink" title="与其他学科的联系"></a>与其他学科的联系</h3><h4 id="数学：作者认为元胞自动机是一种更广泛意义上的数学"><a href="#数学：作者认为元胞自动机是一种更广泛意义上的数学" class="headerlink" title="数学：作者认为元胞自动机是一种更广泛意义上的数学"></a>数学：作者认为元胞自动机是一种更广泛意义上的数学</h4><blockquote>
<p>And one of the consequences of this complexity is that it leads to fundamental limitations on the idea of proof that has been central to traditional mathematics…Yet what the discoveries in this book show is that this is largely just a reflection of how small the scope is of what is now considered mathematics. And indeed the core of this book can be viewed as introducing a major generalization of mathematics—with new ideas and methods, and vast new areas to be explored.</p>
</blockquote>
<h4 id="物理"><a href="#物理" class="headerlink" title="物理"></a>物理</h4><blockquote>
<p>The traditional mathematical approach to science has historically had its great success in physics—and by now it has become almost universally assumed that any serious physical theory must be based on mathematical equations. Yet with this approach there are still many common physical phenomena about which physics has had remarkably little to say. But with the approach of thinking in terms of simple programs that I develop in this book it finally seems possible to make some dramatic progress. And indeed in the course of the book we will see that some extremely simple programs seem able to capture the essential mechanisms for a great many physical phenomena that have previously seemed completely mysterious.</p>
</blockquote>
<h5 id="传统物理多使用连续数值，微积分以及概率；元胞自动机本质是离散的；简单的规则组合形成了复杂的行为"><a href="#传统物理多使用连续数值，微积分以及概率；元胞自动机本质是离散的；简单的规则组合形成了复杂的行为" class="headerlink" title="传统物理多使用连续数值，微积分以及概率；元胞自动机本质是离散的；简单的规则组合形成了复杂的行为"></a>传统物理多使用连续数值，微积分以及概率；元胞自动机本质是离散的；简单的规则组合形成了复杂的行为</h5><h5 id="传统物理多是理想化的建立在数学上的关系；元胞自动机可以表达更复杂的关系"><a href="#传统物理多是理想化的建立在数学上的关系；元胞自动机可以表达更复杂的关系" class="headerlink" title="传统物理多是理想化的建立在数学上的关系；元胞自动机可以表达更复杂的关系"></a>传统物理多是理想化的建立在数学上的关系；元胞自动机可以表达更复杂的关系</h5><h4 id="生物：传统生物学细节了解的多，但是却缺乏统一的理论"><a href="#生物：传统生物学细节了解的多，但是却缺乏统一的理论" class="headerlink" title="生物：传统生物学细节了解的多，但是却缺乏统一的理论"></a>生物：传统生物学细节了解的多，但是却缺乏统一的理论</h4><blockquote>
<p>Vast amounts are now known about the details of biological organisms, but very little in the way of general theory has ever emerged.</p>
<p>And part of the reason for this is that traditional mathematical models have never seemed to come even close to capturing the kind of complexity we see in biology. </p>
</blockquote>
<h4 id="社会科学"><a href="#社会科学" class="headerlink" title="社会科学"></a>社会科学</h4><ul>
<li>想法：社会科学，环境科学，天体科学的变化周期长，难以在短期内获得重复性数据。从容易掌控和重复的微观体系入手研究复杂体系行为；再寻找微观复杂体系的行为与宏观复杂体系行为之间的关系，从而间接的探究宏观体系的动力学本质</li>
</ul>
<blockquote>
<p>From economics to psychology there has been a widespread if controversial assumption—no doubt from the success of the physical sciences—that solid theories must always be formulated in terms of numbers, equations and traditional mathematics. </p>
</blockquote>
<h4 id="计算机科学-从专家型的编程变为通用型-自组织的编程"><a href="#计算机科学-从专家型的编程变为通用型-自组织的编程" class="headerlink" title="计算机科学:从专家型的编程变为通用型+自组织的编程"></a>计算机科学:从专家型的编程变为通用型+自组织的编程</h4><ul>
<li>想法：例如机器学习、遗传算法等方法的发展代表了这种趋势</li>
</ul>
<blockquote>
<p>Throughout its brief history computer science has focused almost exclusively on studying specific computational systems set up to perform particular tasks. But one of the core ideas of this book is to consider the more general scientific question of what arbitrary computational systems do. </p>
</blockquote>
<h4 id="哲学"><a href="#哲学" class="headerlink" title="哲学"></a>哲学</h4><h4 id="艺术"><a href="#艺术" class="headerlink" title="艺术"></a>艺术</h4><h4 id="技术：去中心化的控制，进化的功能实现"><a href="#技术：去中心化的控制，进化的功能实现" class="headerlink" title="技术：去中心化的控制，进化的功能实现"></a>技术：去中心化的控制，进化的功能实现</h4><ul>
<li>Despite all its success, there is still much that goes on in nature that seems more complex and sophisticated than anything technology has ever been able to produce. But what the discoveries in this book now show is that by using the types of rules embodied in simple programs one can capture many of the essential mechanisms of nature. And from this it becomes possible to imagine a whole new kind of technology that in effect achieves the same sophistication as nature. </li>
</ul>
<h3 id="相关领域"><a href="#相关领域" class="headerlink" title="相关领域"></a>相关领域</h3><h4 id="人工智能：遭遇瓶颈"><a href="#人工智能：遭遇瓶颈" class="headerlink" title="人工智能：遭遇瓶颈"></a>人工智能：遭遇瓶颈</h4><blockquote>
<p> And in the 1960s the field of artificial intelligence grew up with the goal of understanding processes of human thinking and implementing them on computers. But doing this turned out to be much more difficult than expected, and after some spin-offs, little fundamental progress was made. At some level, however, the basic problem has always been to understand how the seemingly simple components in a brain can lead to all the complexities of thinking</p>
</blockquote>
<h4 id="合成生命-Artificial-Life"><a href="#合成生命-Artificial-Life" class="headerlink" title="合成生命(Artificial Life)"></a>合成生命(Artificial Life)</h4><blockquote>
<p>Most active from the mid-1980s to the mid-1990s, the field of artificial life concerned itself mainly with showing that computer programs could be made to emulate various features of biological systems. But normally it was assumed that the necessary programs would have to be quite complex. What the discoveries in this book show, however, is that in fact very simple programs can be sufficient.</p>
</blockquote>
<h4 id="突变理论"><a href="#突变理论" class="headerlink" title="突变理论"></a>突变理论</h4><blockquote>
<p>Traditional mathematical models are normally based on quantities that vary continuously. Yet in nature discrete changes are often seen. Popular in the 1970s, catastrophe theory was concerned with showing that even in traditional mathematical models, certain simple discrete changes could still occur. </p>
</blockquote>
<h4 id="混沌理论"><a href="#混沌理论" class="headerlink" title="混沌理论"></a>混沌理论</h4><blockquote>
<p>Indeed, all that it shows is that if there is complexity in the details of the initial conditions, then this complexity will eventually appear in the large-scale behavior of the system. But if the initial conditions are simple, then there is no reason for the behavior not to be correspondingly simple. What I show in this book, however, is that even when their initial conditions are very simple there are many systems that still produce highly complex behavior. And I argue that it is this phenomenon that is for example responsible for most of the obvious complexity we see in nature.</p>
</blockquote>
<h4 id="复杂性理论"><a href="#复杂性理论" class="headerlink" title="复杂性理论"></a>复杂性理论</h4><blockquote>
<p>One feature of the new kind of science that I describe in this book is that it finally makes possible the development of a basic understanding of the general phenomenon of complexity, and its origins.</p>
</blockquote>
<h4 id="计算复杂度理论"><a href="#计算复杂度理论" class="headerlink" title="计算复杂度理论"></a>计算复杂度理论</h4><blockquote>
<p>Developed mostly in the 1970s, computational complexity theory attempts to characterize how difficult certain computational tasks are to perform. Its concrete results have tended to be based on fairly specific programs with complicated structure yet rather simple behavior. The new kind of science in this book, however, explores much more general classes of programs—and in doing so begins to shed new light on various longstanding questions in computational complexity theory.</p>
</blockquote>
<h4 id="控制论-Cybernetics"><a href="#控制论-Cybernetics" class="headerlink" title="控制论 (Cybernetics)"></a>控制论 (Cybernetics)</h4><h4 id="动力系统理论"><a href="#动力系统理论" class="headerlink" title="动力系统理论"></a>动力系统理论</h4><blockquote>
<p>But what I argue in this book is that in fact the behavior of many systems is fundamentally too complex to be usefully captured in any such way.</p>
</blockquote>
<h4 id="进化理论"><a href="#进化理论" class="headerlink" title="进化理论"></a>进化理论</h4><blockquote>
<p>And indeed I will argue in this book that in many respects it(natural selection) tends to oppose complexity. But the discoveries in the book suggest a new and quite different mechanism that I believe is in fact responsible for most of the examples of great complexity that we see in biology.</p>
</blockquote>
<h4 id="实验数学"><a href="#实验数学" class="headerlink" title="实验数学"></a>实验数学</h4><h4 id="分形"><a href="#分形" class="headerlink" title="分形"></a>分形</h4><h4 id="系统理论"><a href="#系统理论" class="headerlink" title="系统理论"></a>系统理论</h4><h4 id="纳米技术"><a href="#纳米技术" class="headerlink" title="纳米技术"></a>纳米技术</h4><h4 id="非线性动力学"><a href="#非线性动力学" class="headerlink" title="非线性动力学"></a>非线性动力学</h4><h4 id="科学计算"><a href="#科学计算" class="headerlink" title="科学计算"></a>科学计算</h4><h4 id="自组织"><a href="#自组织" class="headerlink" title="自组织"></a>自组织</h4><h4 id="统计力学"><a href="#统计力学" class="headerlink" title="统计力学"></a>统计力学</h4><h3 id="作者自传"><a href="#作者自传" class="headerlink" title="作者自传"></a>作者自传</h3><blockquote>
<p>So I thought that perhaps I could do something similar in natural science: that there might be some appropriate primitives that I could find that would successfully capture a vast range of natural phenomena.</p>
<p>There were in many cases well-established mathematical models for the individual components of such systems. But two practical issues stood in the way of using these as a basis for simulations. First, the models were usually quite complicated, so that with realistic computer resources it was very difficult to include enough components for interesting phenomena to occur. And second, even if one did see such phenomena, it was almost impossible to tell whether in fact they were genuine consequences of the underlying models or were just the result of approximations made in implementing the models on a computer.</p>
<p>My early discoveries about the behavior of cellular automata stimulated a fair amount of activity in the scientific community. And by the mid-1980s, many applications had been found in physics, biology, computer science, mathematics and elsewhere. And indeed some of the phenomena I had discovered were starting to be used as the basis for a new area of research that I called complex systems theory.</p>
<p>The typical issue was that there was some core problem that traditional methods or intuition had never successfully been able to address—and which the field had somehow grown to avoid. Yet over and over again I was excited to find that with my new kind of science I could suddenly begin to make great progress—even on problems that in some cases had remained unanswered for centuries.</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2017/12/30/生物化学方向数据分析与机器学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2017/12/30/生物化学方向数据分析与机器学习/" itemprop="url">生物化学方向数据分析与机器学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-30T13:00:00+08:00">
                2017-12-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/General-Science/" itemprop="url" rel="index">
                    <span itemprop="name">General Science</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这篇文章主要讲生物化学的基础研究和技术应用中产生的数据与机器学习的结合。实际上，在我看过的文献里面，这两者的结合早已有之，并不是什么新鲜的事情，至少20世纪90年代就有相关的工作，这也和人工智能等概念的几起几落相关。近年来，这种相互结合的趋势愈加明显，部分的原因可能也是机器学习和大数据等概念的兴起，但除此之外，生物化学的研究本身的趋势也愈加的需要这样的技术。</p>
<p>我们研究基础科学，涉及的主要认为有：客观的观测与描述，抽象模型和解释，预测以及干预。科学走到今天，不同的领域有不同的发展，基础物理和高能物理现在还在寻找一些方法间接的观测例如“暗物质”或者某种预言的粒子之类的东西，包括近来观测到的引力波等等，都是在寻找方法对系统进行观测。反过来，如有机合成等学科，已经建立了一套方法体系，控制有机反应，使得我们可以理性的设计合成路线，获得我们想要的产物，对有机产物结构的观测手段如质谱等，已经在过去多次获得诺贝尔奖。可见，【客观的观测与描述】一个体系这件事情，尽管是科学定量研究的第一步，但是仍然是非常重要且大有可为的一个领域。</p>
<p>在对生命科学体系以及化学体系的研究中，分析手段大部分就是做的客观的观测与描述的工作。这部分工作尽管已经取得了长足的进步，但是还有很多问题没有解决。如何从静态的观测走向动态的观测；在空间尺度和时间尺度上，如何尽可能准确的观测到尽可能微小的差异；如何观测和分析复杂的多组分相互作用的体系等等</p>
<p>我们客观的观测和描述研究的对象，基本的方法就是通过检测器检测信号，获取数据，我们认为，数据是脱离主观的，是对被观测食物的客观反映。然后再进一步的从数据中提取信息，进行分析和描述，最终获得对研究对象的理解和新的知识。因此，对于数据中包含的信息的提取，分析和描述是一道连接实验数据与我们最终目标——对体系的理解和获取新的知识的桥梁，不得不说是非常重要的。当我们研究的体系比较简单，数据量较少的时候，分析和描述也不复杂，因此，在过去的纯分析研究中，大量的精力集中在如何更好的获得数据上面；而分析的应用方面，则精力集中在如何从对体系的描述中发现新的知识，建立新的模型上面。比如说获得了诺贝尔奖的MALDI离子源，就是解决了质谱如何获取生物大分子质量数的问题。</p>
<p>但是，随着分析技术的进步，从观测数据到知识之间的桥梁变得不那么好走了。这主要是两个方面的原因造成的，一是随着分析方法和分析仪器的进步，单位时间获取的数据量大大增加了。过去我们拍摄一张荧光成像的图片，显示了被标记的物种在某个时刻在体系中的空间分布情况，我们是可以简单的对其进行分析的；但是现在，在笔者的实验中，拍摄的随时间变化的荧光时序图像，由于采用了高速的和高灵敏度的EMCCD，因此在一个下午的时间里，2~3份样品就将产生大约六万帧的图像，占用约50GB储存空间。在这样的情况下，完全无法通过传统的定性分析的方法人工的来全面的理解和描述获得的实验信息。第二个原因是我们研究的体系变得更加的复杂了，简单的体系中，我们关注的物质种类单一，且认为不同的物种之间是相互独立的，如果有相互作用，那么这种作用是线性的和决定性的，可以简单描述的。例如我们分析一份环境样本，想要获取其中几种农药含量，这样的体系就是简单的，因为每一种农药的情况都单一的对应一个质谱峰的强度；且不同的质谱峰之间互不干扰，这样的分析是经典的化学分析的内容。但是，当面对复杂的体系的时候，我们就没有办法如此直观的获得一一对应的相关性信息。譬如说，我们现在想要研究的是药物对细胞的刺激作用，当然，如果刺激的作用很强烈，那么就只有杀死细胞和细胞存活的差异。 但是，如果药物对细胞的状态产生了影响，但这种影响只是改变了细胞的生活方式，而并没有杀死细胞，这样的情况下问题就非常多了。如何观测细胞状态的变化？细胞的状态与那些可以被观测的量相关？如何定量的描述这种变化等等。研究体系的复杂化以及研究问题的精细化，导致我们很难再像以前一样直观的从数据中获得结论了，因此必须更好的利用“从数据中提取信息，进行描述和分析”这个桥梁的作用，帮助我们从复杂的自然想象中获取有益的信息。</p>
<p>那么如何更好的利用这个桥梁呢？或者说，如何从大量的，复杂的数据中，提取我们想要的信息，进行定量化的描述和分析呢？机器学习的方法无疑是很重要的方法（但不是唯一的方法）。</p>
<h3 id="机器学习中的基本概念"><a href="#机器学习中的基本概念" class="headerlink" title="机器学习中的基本概念"></a>机器学习中的基本概念</h3><h4 id="机器学习的任务"><a href="#机器学习的任务" class="headerlink" title="机器学习的任务"></a>机器学习的任务</h4><p>机器学习的任务，也就是大家使用机器学习的目的，大致上可以有 <strong>分类与预测</strong>，<strong>关联性分析</strong>等内容。<br><strong>分类与预测</strong>是机器学习最常见的用途。实际上，分析的目的常常与分类有关，有些是二分类问题：如一份河水样本是不是有机物超标？一个细胞是否是活细胞？一个生物样本是否是来自于猪的？这些都是传统的二分类问题。当我们的结论与信号之间的很强的关联性的时候，这个事情并不需要机器学习来做：河水中还原性物质给了高锰酸钾x个电子每毫升以上就是有机物超标；细胞质区域被不能跨膜的染料染上颜色就说明细胞已经死亡；DNA电泳中出现了特征的条带就说明样本来源是猪等等。但是，正如上面所说的，如果需要研究的问题更为深入和精细的时候，我们就很难将结论与直接观测的数据相联系了，比如，一个细胞是否是癌细胞？如果是，是哪一种癌细胞？一个细菌是否是耐药的？如果是，耐哪一种类型的药物？我们直接能够观测的量没有一个能想前面所说的那样给我们直接的结论，综合多个不同观测变量的结果，给出一个单一的分类标签的过程，就是机器学习中的分类。之所以成为机器学习，主要是因为我们在生活中大部分时间都会做这件事：比如我们第一次遇到一个人，我们的大脑就可以根据这个人的衣着，相貌，举止，语言等多个因素给出一个综合的评价——第一印象是好还是坏；这就是我们大脑作出的二分类问题。预测问题就是给定一个未知结果的观测结果，根据以前的学习结果，预测这个观测结果属于的类别。<br><strong>关联性分析</strong>则是为了回答这样的一个问题，一个观测的结果与众多的不同的观测值之间的关系是什么。尽管学习的方法可以对数百上千的观测值进行综合给出一个单一的结果，但是我们人类还是希望知道，这个结果主要是由哪些因素影响的。这与后面的解释，建模以及预测直接相关。因此也是科学领域内非常重要的一步。</p>
<h4 id="样本，特征与分类器"><a href="#样本，特征与分类器" class="headerlink" title="样本，特征与分类器"></a>样本，特征与分类器</h4><p>机器学习中一个观测的对象称为一个样本，每个观测的指标称为一个特征，对观测结果进行综合和预测的一组参数成为模型或者分类器。 上面的概念非常抽象，我们可以举一个很简单的例子来说明。譬如我们给实验室采购电脑，需要选择买哪些电脑来给大家来用。买电脑这种事情还是有点复杂的，对于每一个品牌和型号的电脑，实际上就是我们观测的一个对象，也就是一个样本。 我们观测的指标很简单，一个是CPU的计算能力，可以用benchmark来量化表示；另一个就是电脑的价格，可以用人民币为单位进行表示。这里的CPU benchmark和价格就是我们观测的两个特征。对于每一个样本（电脑型号），都可以获得这两个特征。分类器的作用就是根据这两个特征来作出决策，买还是不买这个品牌的电脑。<br>那么怎么理解分类器就是一组参数呢？因为机器学习需要处理的问题来自各个不同的领域，永远也无法穷举出来每个领域的专家模型（也就是对这个领域有深厚了解的专家的决策规则）。因此机器学习算法仅仅是一系列抽象的计算方法，而面对不同领域和不同的数据集的时候，同样的一个算法实际上还是同样设定好的分析规则。所不同的是执行这个规则的参数不同。什么样的参数最适合做一个特定领域的分析和预测呢？这个就是通过这个领域的历史数据来进行学习的<br>还回到买电脑的故事里面。我们怎么知道什么样的电脑才适合实验室买呢？我们可以找出来过去实验室买电脑的记录，其中已经购买的电脑的CPU benchmark以及当时的价格我们都是可以获得的；同时我们也可以看看当时考虑了但是没有买的电脑的相关特征。我们知道过去的决策中关注的样本，特征与最终结果，就可以训练一个分类器来帮我们预测当前的那些电脑型号适合实验室购买。<br>刚才我们说，一个机器学习算法就是一个通用的计算规则。比如我们这里找到了一个简单的算法，那就是价格在某个区间中的时候，CPU benchmark达到一定数值，就会被购买。这个规则就是一个简单的机器学习模型。那么价格具体要在哪个范围呢？CPU benchmark要高过哪个阈值才会购买呢？这些参数与就是需要通过从历史数据中计算确定得到的。这些参数算出来以后，这个规则和参数就形成了一个分类器，帮助我们确定一个新的品牌的电脑是否值得购买。<br>那么上述的机器学习算法的抽象就是这样的一组规则：特征1（例子中为价格）需要同时满足大于参数$\alpha$，小于参数$\beta$，以及特征2需要大于参数$\gamma$的情况下，就输出结果1，否则输出结果2. 一个具体应用的模型就是由一组具体($\alpha_0$, $\beta_0$, $\gamma_0$)确定的规则。</p>
<h4 id="有监督的学习和无监督的学习"><a href="#有监督的学习和无监督的学习" class="headerlink" title="有监督的学习和无监督的学习"></a>有监督的学习和无监督的学习</h4><p>上面描述的例子中，学习是通过历史决策数据完成的。这样的机器学习算法成为有监督的机器学习算法。也就是说过去的决策数据作为真实值，指导了算法的优化和评价过程。但是，实际工作中，历史决策数据可能是很难获取到的。更重要的是，有监督的情况是建立在我们对需要做的事情非常清楚的情况下。但是，在研究中我们有的时候希望从大量的数据中看到差异性，再从差异性入手挖掘新的未知的知识，这个时候，无监督的学习方法也就变得很重要了。<br>还是上面的买电脑的例子。假如现在实验室刚刚建立，还没有过去买电脑的历史。于是导师跟你说，你调研总结一下市场上在售的电脑都有哪些不同的类型，我们选一个类型来买。这个需求中提到的【调研总结一下市场上在售的电脑都有哪些不同的类型】就是一个非常不明确的需求，我们作为非计算机销售的专家，并不知道在售有哪几种类型的电脑；也不知道每一种类型的电脑都是什么样子的。但是，我们可以使用无监督的学习方法，从在售电脑数据中学习到这些东西。<br>无监督学习的主要应用就是聚类。所谓聚类就是对于一个有大量不同样本的数据集，根据样本之间的相似度，将彼此相似的样本聚为一类；彼此不同的样本分开为不同的类。最终给出的结果就是每一个样本属于的类别。我们再观察每一个类别的平均状况，就可以知道大概每一个类别都是什么情况。无监督学习判断两个样本的差异性就是通过他们的特征值计算得到的。不同的相似度计算方法成为不同的【度量】。度量选择的不同也会导致分类结果的不同，这是因为无监督学习既然是【无监督】的，它其实不懂对错，只是完美的根据【相似的在一起；不同的不在一起】的规则去工作，至于最后的结果是否有意义，就让人来决定吧。举一个例子，现在我们有一群人要进行分类；如果选择【性别】作为度量，那么就会分成【男人】和【女人】两类。如果根据年龄来作为度量，分类的结果就是老年和少年。无监督的学习方法没有变，规则也没有变，但是分类的结果变了，这是度量发生改变的结果。<br>回到原来的例子，使用无监督的学习方法，我们将收集来的市场上在售的电脑分成了四类。我们观察每一类的平均情况，发现有一类是价格高，CPU benchmark低的电脑，原来是商务笔记本；有一类价格高，benchmark也高的，原来是游戏本；有一类价格低，benchmark也低的，原来是低端本；还有一类价格低但是benchmark高的，原来是二手本。</p>
<h4 id="机器学习与物理模型"><a href="#机器学习与物理模型" class="headerlink" title="机器学习与物理模型"></a>机器学习与物理模型</h4><p>上面谈到，机器学习的方法是普适性的，而非是领域相关的专家知识的集合。相反的，物理模型则完全是通过领域内专家通过专业知识推导得到的结果。我们说机器学习这个东西并不新鲜，在过去已经经历多次起落。当它衰落的时候，也就是对应的专家模型应用广泛的时候。因此，这两种东西实际上是相互竞争又相互启发的。 机器学习在过去衰落的原因主要是计算能力不够，数据量不够或者算法不好导致的应用效果差。对于科学研究上来说，机器学习还有一个先天的劣势，就是即时机器学习给出了很好的预测或者聚类结果，我们却无法从科学本质上的了解其中的因果关系。尽管通过关联分析和重要特征的提取可以改善这一问题（因为特征一般是有具体意义的观测值），但仍然不如物理模型来的直接和易于解释。机器学习也因为其黑匣子的特征，大部分的应用于商业。对于科学研究来说，黑匣子是不够的。<br>但是我们上面说，机器学习与物理模型也有相辅相成的关系。这也是当前科学研究中的新型热点。物理模型的建立过程中天然的带有人对于体系本身的规则的假设，也就是模型的预设条件。但是，对于上面说的复杂的多因素相互作用的系统，尤其是缺乏先验知识的未被探索的科学领域，建立的模型常常是不完整的，有偏差的甚至是错误的。当下甚至更有激进的观点认为，因果关系的科学主要是建立在牛顿力学的观念上的近现代科学研究体系。在面对复杂的，相互作用相互关联的系统是，因果关系可能是没有意义的。比如说，你说我是因为胖才不爱运动的呢？还是因为不爱运动才变胖的呢？这两个系统变量的变化是相互关联相互反馈的，因此因果之说就变得缥缈。遗憾的是，这样的系统在生物学，社会学等等重要领域都是广泛存在的，以至于让我们认为开始觉得过去研究的简单的相互独立的体系才是复杂的相互关联的体系的海洋中的孤岛。因此，这对我们是挑战也是机遇。<br>物理模型与机器学习的关系也是相辅相成的。我们谈到机器学习中需要对样本进行定量的描述，形成样本的特征，这个特征怎么来的呢？很大一部分就是通过物理模型计算出来的。比如在我的研究中，对于单个粒子在一段时间的运动行为，有一个重要的描述特征就是在这个区间的局部扩散系数。扩散系数是怎么计算的呢？就是基于爱因斯坦的自由扩散物理模型计算的。<br>爱因斯坦的自由扩散模型中的假设是粒子运动在均一稳定的粘性溶液中；因此粒子在扩散过程中，只要统计的量足够完备，应该扩散系数是处处相同的，运动行为的概率统计也应该是相同的。但是在观测实际的体系中，我们发现很多与生物复杂粘弹性的细胞质作用的粒子，表现出与空间和时间相关的运动行为，通过机器学习的方法，我们可以得到不同运动行为的时间和空间的分布。这样的结果反过来又可以刺激新的物理模型的产生。因为机器学习的方法，尤其是无监督的方法，并没有带入先验的人为假设，因此更适用于新知识的发现。数据驱动的知识挖掘也是非常热的商业和科学课题。</p>
<h3 id="生物化学基础研究，应用与机器学习"><a href="#生物化学基础研究，应用与机器学习" class="headerlink" title="生物化学基础研究，应用与机器学习"></a>生物化学基础研究，应用与机器学习</h3><p>前面谈了很多虚的东西，这里进入主题。生物化学的研究范围非常广阔，涉及的话题又纷繁复杂，并不是我这一篇文章能够说清楚的事情。 这里仅仅是从分析化学的角度谈其中很小的一部分。分析化学在生物化学上的研究和应用就是文章开头谈到的对观测体系进行定量的观测和描述。 过去，分析化学大量的研究了简单的，线性的体系，上面提到的如农药检测等就是经典的简单线性系统。 在研究这类系统的时候，最重要的问题是提高检测的范围，精确性和最低检出量。但是随着科学的进步，人们越来越多的关注到了复杂的非线性的系统。尽管这类系统实在是很多，但是真正能够确定性的，可重复性的研究的体系，还是一些生物体系。这是因为，如细胞，生物个体等研究体系可以通过标准化的培养发育大量的可重复的提供实验材料。更多的社会学，生态学和天文学问题，研究体系的时间尺度远远大于生物学实验，因此数据的积累和实验重复性，对照实验的设计等方面都会有所限制。更重要的是，对生物体系的了解直接关系人类永恒的需求——健康，因此生物学的研究如此火热也不难理解。<br>分析化学在生物学当中的应用非常广泛，可以说，分析手段是绝大多数生物学实验的基础。分析化学手段为生物学的研究提供了定量的基础。在研究参照之间存在单一的，显著性差异的时候，定性分析仍然适用（如跑胶看条带的深浅）；在研究参照之间存在单一的，但是仅仅是统计学意义上的显著差异时，定量分析为统计学计算提供了支持；在研究参照之间存在多变量的复杂的相互关系的时候，更多的计算方法就需要运用进去，将数据中的差异提取出来。 机器学习的方法无疑是一种重要的分析手段；其他的，建立在物理模型和假设上的特殊领域算法，时序分析等等也包括在内。<br>前面说了，既然使用数据分析方法的数据本身对于人的定性直觉来讲，太过复杂，那么就会遇到一个直接的问题，就是当分析结果与预期差距很大的时候，或者说结果“不好”的时候，我们如何确定是数据上的问题，还是计算方法上的问题？<br>最常用的方法是使用模拟数据来对算法进行评估。模拟数据的好处是我们本身对模拟所用的数学模型，条件以及基本参数非常了解，这些模拟的基本参数可以当做真实值来与算法的结果作对照，从而评估算法的准确性以及误差范围。如果通过这样的方式确定下来算法是准确的，那么当分析结果与预期有差异的时候，算法的因素就被排除了。<br>除了算法本身正确性的问题以外，还有一个重要的方面是算法本身是否能够揭示你需要的信息。这一点上，需要研究人员至少要对所使用的算法有基本性的了解，否则的话就是胡乱尝试，出了问题也无从下手改进。不同的算法所着重的点是不同的，好比我们看待一样事物有不同的角度一样。如果想要知道苹果的好坏，“尝一口”这个算法将得到口味的结果，对于区别好坏苹果很有帮助；反过来【称重】这个算法只能得到质量数据，很可能发现好苹果和坏苹果没有什么差异。在机器学习在生物化学的领域应用中，在特征的提取上以及算法的选用上，研究人员需要考虑数据的天然属性，机器学习算法的特性以及处理的目标，综合的选择合适的算法。当然，上述的要求实际上是比较高的，通常情况下我们可以先尝试文献中已经报道的方法或者实验室已有的成熟的方法入手。但是归根结底最重要的是，不能期望一劳永逸的用一套算法处理所有的数据且能获得预期的成果；也不建议计算结果不理想就直接重新做实验。还是要将实验数据和算法结果相互不断比对和印证，逐步有针对性的获得理想的结果。</p>
<h3 id="常见的数据种类与学习方法"><a href="#常见的数据种类与学习方法" class="headerlink" title="常见的数据种类与学习方法"></a>常见的数据种类与学习方法</h3><p>分析化学实验常用的数据类型有图像数据和谱图数据，在此处分开来讲。<br>图像数据的来源有显微成像和质谱成像。总体而言，图像数据表现的是物质在空间上的分布信息。图像数据中一个像素点对应一个空间位置，这个像素点的值对应这个位置的信号强度，图像数据本质上就是按照空间位置对应的一个数值矩阵。图像数据的处理非常之多，最为常见的是提高图像质量的降噪，滤波，调节对比度，边缘增强等等；还有识别目标的需求，如特殊物体的自动识别;也有数值分析的需求，如分析某个区域的强度均值等。<br>科学研究中的图像数据通常有TIF格式，TIF格式全称(Tag Image File Format), 是具有标签的无压缩的数据文件格式。其中的标签既可以描述图像本身的信息，也可以描述获取数据的仪器，软件等信息。TIF格式的无压缩特性使得它适合作为科学图像数据格式。计算机在保存图片的时候常常需要将像素的值归一化到一个范围区间内，如8 bit的TIF文件每一个像素的数值就是0~255。对于科学数据来说，并不一定原始信号就与TIF格式的要求相同，在这种情况下，会使用线性变幻将原始数据变换到需要的数值区域，这个过程中可能造成信息的损失。<br>另一个更为麻烦的数据格式是Text Image，如名称所示，这种格式中所有像素的值是按照一定的顺序写在一个txt文档中的，因此是没有信号值域的范围的，因此最大的保留的原始数据。但是这种数据在读取和保存的时候，涉及到数值与字符的相互转换以及显示的时候的数值变换，因此读取和保存的速度较慢。对于看重图像不同区域之间的强度比率的情况，适合使用TIF保存数据；对于看重具体信号强度的情况，适合保存为text image的形式。<br>PNG格式是常见的压缩格式，但是质量也是比较好的，因此与TIF格式一样适合作为发表文章时用的数据格式。<br>向量图通常是软件输出或者人工制作的用于发表文献用的展示用格式，非常重要，但是与数据处理无关，在此就不多说了。<br>说完图像数据常见的类型，那么对于图像数据常见的处理都有哪些呢？前面提到，图像数据的本质上是一个数值矩阵。空间信号处理的方式如二维傅里叶变换等处理方式广泛的应用于图像的信号处理（SIM），降噪等方面。目标识别目前有两种路径。简单的目标识别（如单个圆形颗粒等）可以使用数值方法如最大值寻找，边缘扩展等等方法。复杂的目标识别通常是计算机领域的工作，目前流行使用神经网络的方法。图像数据也可以作为机器学习的样本。最为简单的特征提取方式就是认为每一个像素点就是一个特征，像素点的数值就是特征的值。这样，一张100像素x100像素的图像作为一个样本，就有一万个不同的特征。特征还需要对齐，也就是在相同位置的特征需要表达相同的物理意义。前面提到机器学习中非常重要的相似度计算，就是分别计算对应位置的特征值差异获得的；因此如果物理意义都不想同，计算就没有意义了。<br>除了图像数据，最为常见还有谱图数据。谱图数据与图像数据类似，表达的是信号在不同波谱频域中的强度分布。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2017/12/03/Fun-with-your-first-Day-with-Matlab-S01E04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2017/12/03/Fun-with-your-first-Day-with-Matlab-S01E04/" itemprop="url">Fun with your first daty with Matlab S01E04</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-03T19:51:00+08:00">
                2017-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/MATLAB/" itemprop="url" rel="index">
                    <span itemprop="name">MATLAB</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h3 id="脚本的执行顺序控制"><a href="#脚本的执行顺序控制" class="headerlink" title="脚本的执行顺序控制"></a>脚本的执行顺序控制</h3><h4 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h4><h4 id="if-else-判断语句"><a href="#if-else-判断语句" class="headerlink" title="if-else 判断语句"></a>if-else 判断语句</h4><h4 id="switch-case分支语句"><a href="#switch-case分支语句" class="headerlink" title="switch-case分支语句"></a>switch-case分支语句</h4><h4 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h4><h4 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h4><h3 id="MATLAB中的函数"><a href="#MATLAB中的函数" class="headerlink" title="MATLAB中的函数"></a>MATLAB中的函数</h3><h4 id="创建函数文件"><a href="#创建函数文件" class="headerlink" title="创建函数文件"></a>创建函数文件</h4><h4 id="编写第一个函数"><a href="#编写第一个函数" class="headerlink" title="编写第一个函数"></a>编写第一个函数</h4><h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h4><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><h4 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h4><h4 id="公有与私有权限"><a href="#公有与私有权限" class="headerlink" title="公有与私有权限"></a>公有与私有权限</h4><h4 id="函数句柄"><a href="#函数句柄" class="headerlink" title="函数句柄"></a>函数句柄</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2017/11/22/复杂性思考/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2017/11/22/复杂性思考/" itemprop="url">Ideas of Complexity</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-22T20:55:35+08:00">
                2017-11-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/General-Science/" itemprop="url" rel="index">
                    <span itemprop="name">General Science</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="How-to-define-Complexity"><a href="#How-to-define-Complexity" class="headerlink" title="How to define Complexity?"></a>How to define Complexity?</h3><p>We may be sure of that static system can not produce complexity as complexity is emergenced from dynamics. While complexity system such as social behavior or genes expression usually can be modeled as network with many agents, I ask a question that can single series produce complexity?</p>
<p>To answer the question, we may begin with organized series such as const series$X_t = Const$ or series follows certain time related rule$X_t=A<em>sin(t)$. We may define these series as <strong>simple series</strong> instead of <strong>complex series</strong> for the rule is simple and easy to be found.Another side of the issue is that totally random series, we define this case as <em>*simple series</em></em> too for there is no rules to be found.</p>
<p>However, a subtle case is that the series is historical related, such as $X<em>t=f(X</em>{t-1},X<em>{t-2},…,X</em>{t-n})$, can we now define the series as <strong>complex series</strong>? The answer is yes and no. An important issue is that how complex the function $f(·)$(We then term the function as <strong>history function</strong>) is. For an example:<br>$$X_t = X_t + 1$$<br>In this case, we definitely define the series as simple. so why our definition change as the function become <strong>complex</strong>? The answer may be that we should introduce nonlinearity in our history function.</p>
<p>可以确定的是静态是无法产生复杂的，复杂是在动态中表现的行为。单个序列是否能够产生复杂的现象呢？当一个序列是有序的（如常量序列$X_t = Const$或者符合某个周期函数的序列$X_t=A<em>sin(t)$）或者是完全随机的，我们都可以认为这样的序列是简单的。同样的，简单的机制相互线性叠加产生的序列，如$X_t=A</em>sin(t)+random+Const$我们仍然认为是简单序列。但是如果一个序列是历史相关的，如$X<em>t=f(X</em>{t-1})$，我们是否应该认为这样的序列是复杂序列呢？</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2017/11/15/Fun-with-your-first-Day-with-Matlab-S01E03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2017/11/15/Fun-with-your-first-Day-with-Matlab-S01E03/" itemprop="url">Fun with your first daty with Matlab S01E03</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-15T15:02:35+08:00">
                2017-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/MATLAB/" itemprop="url" rel="index">
                    <span itemprop="name">MATLAB</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>上一回我们讲述了MATLAB中最为重要的数据结构——数组的使用方法。这一次我们在讲述两个常用的数据结构，元胞和结构体。在实际使用的过程中，需要根据不同数据结构的特点以及需要完成的任务综合考虑需要什么样的数据结构。</p>
<h3 id="元胞"><a href="#元胞" class="headerlink" title="元胞"></a>元胞</h3><p>数组有一个特点，就是每一个元素储存的东西都必须是同类型的数据。如果想要存储不同类型的数据怎么办？这个时候就需要使用元胞了。</p>
<h4 id="创建元胞"><a href="#创建元胞" class="headerlink" title="创建元胞"></a>创建元胞</h4><p>元胞的创建是使用cell函数的：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = cell(<span class="number">3</span>,<span class="number">5</span>); <span class="comment">%创建3行5列的元胞</span></div></pre></td></tr></table></figure></p>
<p>这样就创建了一个元胞。除此之外，还可以直接创建元胞：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;;</div></pre></td></tr></table></figure></p>
<p>上面创建的元胞中包含3个字符。元胞还可以包含不同类型的数据：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b = &#123;<span class="string">'a'</span>,<span class="number">3</span>,<span class="string">'cdx'</span>&#125;;</div></pre></td></tr></table></figure></p>
<p>上面的元胞依次包含字符，数字以及字符串。<br>实际应用中，直接创建的可能性较少，大部分情况下都是先用cell函数创建空元胞，再使用索引将元胞的元素赋值为需要存储的变量。实际上，元胞和向量大部分情况下在MATLAB中都充当了数据的集合的作用。元胞和数组在使用的时候，需要占用内存空间，通常情况下，我们如果可以预先知道需要使用的元胞和数组的大小维度，就可以使用函数先声明相应大小的元胞或者数组，再将其中的元素赋值为我们需要的变量。如果需要扩大元胞或者数组的大小，这是非常耗时的一个操作。因为在这个操作中，实际上发生的是：声明一个新大小的元胞或者数组$\rightarrow$将原来的数据搬运到新声明的空间中$\rightarrow$销毁原来的元胞或者数组，释放空间</p>
<p>想想也觉得很麻烦吧！</p>
<h4 id="元胞元素操作"><a href="#元胞元素操作" class="headerlink" title="元胞元素操作"></a>元胞元素操作</h4><p>获取元胞的单个元素可以使用大括号操作，修改值也是这样<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">12</span>&#125;;</div><div class="line">a&#123;<span class="number">1</span>&#125;</div><div class="line"><span class="built_in">ans</span> = <span class="number">2</span></div><div class="line">a&#123;<span class="number">1</span>&#125; = <span class="string">'s'</span></div><div class="line"><span class="built_in">ans</span> = &#123;<span class="string">'s'</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">12</span>&#125;</div></pre></td></tr></table></figure></p>
<p>如果要对元胞进行切片，切片是指从数据的集合中获取一个子集。元胞的切片也是使用圆括号的<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">12</span>&#125;;</div><div class="line">b = a([<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>])</div><div class="line">b = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>&#125;</div></pre></td></tr></table></figure></p>
<p>要想同时改变元胞中的多个元素的值也是使用圆括号，赋值的项需要是元胞<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">12</span>&#125;;</div><div class="line">a([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) = &#123;inf&#125; <span class="comment">%广播赋值</span></div><div class="line">a = &#123;inf,inf,inf,<span class="number">11</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">12</span>&#125;</div><div class="line">a([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) = &#123;<span class="string">'s'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>&#125; <span class="comment">%按元素赋值</span></div><div class="line">a = &#123;<span class="string">'s'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">12</span>&#125;</div></pre></td></tr></table></figure></p>
<p>如果想要删除元素，直接使用圆括号和空集就可以<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">12</span>&#125;;</div><div class="line">a([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) = &#123;[]&#125; <span class="comment">%赋值为空集</span></div><div class="line">a = &#123;[],[],[],<span class="number">11</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">12</span>&#125;;</div><div class="line">a([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) = [] <span class="comment">%删除</span></div><div class="line">a = &#123;<span class="number">11</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">12</span>&#125;;</div></pre></td></tr></table></figure></p>
<p>上面的运算也都可以使用上一次讲的逻辑索引</p>
<h4 id="元胞与数组的转换"><a href="#元胞与数组的转换" class="headerlink" title="元胞与数组的转换"></a>元胞与数组的转换</h4><p>有的时候需要将元胞和数组相互转换。当一个元胞是全部由同种类型的数据组成的时候，就可以转换为数组。<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</div><div class="line">b = cell2mat(a)</div><div class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</div></pre></td></tr></table></figure></p>
<p>这样做有什么样的好处呢？前面我们说过，当使用数据集合的时候，最好能够提前知道需要的容量大小，然后再通过索引存入到数据集合中，当有些情况下，我们没有办法提前知道需要的容量，这个时候可能可以使用元胞优化。例如下面的程序，someFunc是一个返回任意长度的<strong>行</strong>向量的函数，我们需要调用它两次，将两次的结果放在同一个向量中，并求取平均值：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">%需要在运行中扩展向量大小的方法</span></div><div class="line">a = [];</div><div class="line">a = [a,someFunc()]; <span class="comment">%扩展大小，重新申请空间</span></div><div class="line">a = [a,someFunc()]; <span class="comment">%扩展大小，重新申请空间</span></div><div class="line">res = mean(a)</div><div class="line"></div><div class="line"><span class="comment">%不需要重新申请空间</span></div><div class="line">a = cell(<span class="number">2</span>,<span class="number">1</span>); <span class="comment">%两行一列的元胞</span></div><div class="line">a&#123;<span class="number">1</span>&#125; = someFunc();</div><div class="line">a&#123;<span class="number">2</span>&#125; = someFunc();</div><div class="line">a = cell2mat(a)；</div><div class="line">res = mean(a);</div></pre></td></tr></table></figure></p>
<p>反过来，也可以用mat2cell来将向量转换为元胞</p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>除了元胞，还有一个常用的保存不同类型数据的容器成为结构体（struct)。与前面讲的元胞和向量不同，结构体中存取数据是通过变量名称的，而前者实际上是使用数据所在位置的下标的。通过变量名称存取数据的好处是可以让程序更加容易阅读，毕竟变量名往往都是使用人类容易理解和符号表示的；但是使用下标容易大批量的存储，修改以及取出。因此，结构体往往用来存储性质不同但聚合程度很高的数据。什么意思呢？譬如我们可以使用元胞存储长度不一的字符串，他们性质不同（长度不同)，同时聚合度不高，也就是说相互之间没有关系。但是，同样的，如果我们需要储存几个长度不同的字符串，分别为一个对象的名称，描述，型号和价格，这些数据相互之间性质不同，但在意义上有很强的关联性，因为它们同样属于一个对象的性质，这个时候就非常适合使用结构体了。</p>
<h4 id="使用结构体"><a href="#使用结构体" class="headerlink" title="使用结构体"></a>使用结构体</h4><p>创建结构体使用struct函数，我们这里假设创建一个游戏中的角色，大天使bigAngel哈哈哈<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">bigAngel = struct() <span class="comment">%创建结构体</span></div><div class="line">bigAngel.HP = <span class="number">1000</span>; <span class="comment">%血量1k</span></div><div class="line">bigAngel.MP = <span class="number">2000</span>; <span class="comment">%魔法2k</span></div><div class="line">bigAngel.name = <span class="string">'Big Angel'</span> <span class="comment">%游戏名称</span></div><div class="line">bigAngel.skill = <span class="string">'Healing'</span> <span class="comment">%技能是治愈</span></div></pre></td></tr></table></figure></p>
<p>在结构体中，使用<strong>结构体名称.数据名称</strong>的方式来存取数据，这样的方式使得代码的可读性非常高，表达的意思的<strong>结构体XX的属性XXX</strong>的含义<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">bigAngel.HP <span class="comment">%查看bigAngel中HP的属性</span></div><div class="line"><span class="built_in">ans</span> = <span class="number">1000</span></div><div class="line">bigAngel.HP = <span class="number">2000</span></div><div class="line">bigAngel.HP <span class="comment">%给bigAngel中的HP属性赋值</span></div><div class="line"><span class="built_in">ans</span> = <span class="number">2000</span></div></pre></td></tr></table></figure></p>
<p>在像C++，C#这样的语言中，一个结构体中包含哪些属性，属性类型和名称名称是什么，都是提前设定好的，在使用过程中不能更改。但是在MATLAB，Python这样的动态语言中，像上面的例子一样，我们在定义结构体时，只需要使用struct函数，而给属性赋值的时候，如果这个属性以前定义过，就更更新属性值，如果从来没有定义过，就新建一个相应属性名称的属性，将值赋给新建的属性。这样的方式非常灵活，但有时候也会出现bug，例如上述的bigAngel的例子<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bigAngel.skil = <span class="string">'Purify'</span> <span class="comment">%本意是更改skill属性，但是打错为skil</span></div><div class="line">bigAngel.skill</div><div class="line"><span class="built_in">ans</span> = <span class="string">'Healing'</span> <span class="comment">%导致属性skill并没有如预期改变</span></div></pre></td></tr></table></figure></p>
<h4 id="结构体相关函数"><a href="#结构体相关函数" class="headerlink" title="结构体相关函数"></a>结构体相关函数</h4><p>结构体有很多相关的常用函数：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = isstruct(b) <span class="comment">%判断b是否为一个结构体</span></div><div class="line">a = isfield(b,C) <span class="comment">%判断某个字符串是否为结构体b的属性，C可以是单个字符串，也可以是一个由字符串构成的元胞</span></div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2017/05/26/科学与复杂性-Science-and-Complexity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2017/05/26/科学与复杂性-Science-and-Complexity/" itemprop="url">科学与复杂性(Science and Complexity)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-26T22:56:07+08:00">
                2017-05-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/General-Science/" itemprop="url" rel="index">
                    <span itemprop="name">General Science</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Translated from: Warren Weaver, Science and Complexity, American Scientist, 1948</p>
<p>科学在过去已经获得了大量的研究成果，并且影响着人们的生活。其中一些只是在琐碎的事情上提供了方便，但是更多的科学成果构建了我们今天（1948年）的现代社会，还有一些，尤其是那些与生物医药相关的成果，无可置疑的提高了我们的生活质量；更有一些结论深刻的改变了我们看待事物的思想。<br>我们应该如何看待科学在未来人类发展中的作用？科学到底是什么，或者同等重要的，不是什么？当然，我们可以从哲学的角度讨论这个问题，在某种意义上，这样的讨论也是非常重要和必要的，不过我们现在用一种更直接的方法来讨论。就像某些政客说的那样，让我们来看看（科学发展的）历程。我们将会忽略非常早期的一些探索故事，从三个半世纪以前开始，忽视一些细节，来考察科学发展过程中的主导的趋势。让我们从物理学开始，到后面在谈到生物学。</p>
<h4 id="朴素问题（Problem-of-Simplicity"><a href="#朴素问题（Problem-of-Simplicity" class="headerlink" title="朴素问题（Problem of Simplicity)"></a>朴素问题（Problem of Simplicity)</h4><p>大致来说，17世纪到19世纪这段时期物理学开始使用“变量”的概念，并且由此发展出了电话，无线电，汽车，飞机，照相以及电影等技术。<br>于此同时在生物学和医药学上面的进展也是令人印象深刻的。然而，有关生命活动的问题很少想物理学中的问题一样，仅仅涉及一到两个变量和一系列假定的常数。有机体更多的情况下包含了数十个同时变化的量，并且这些变量相互之间有微妙的联系。通常在生物学的研究中，很多重要的变量并没有被定量的测定，而是使用了定性的说明和度量，因此，直到1900年左右，生命科学的研究仍然停留在科学研究的初步阶段——包括采集，描述，分类以及对于显著存在的相关性的观察和描述。这些只是定量的理论发展之初的勇敢尝试，甚至很少讨论产生生物现象的物理化学机理。<br>总体来说，20世纪前的物理学大部分只是涉及到一两个变量作用和变化的朴素问题。同时，朴素问题极少适用的生命科学还尚未被定量的分析。</p>
<h4 id="混乱复杂问题"><a href="#混乱复杂问题" class="headerlink" title="混乱复杂问题"></a>混乱复杂问题</h4><p>如果有人把Josiah Willard Gibbs作为研究混乱复杂问题的英雄先驱的话，比1900年更早一些，他已经开始对自然中一种全新的体系发起了进攻。相比于之前对于几个变量的体系的研究，Gibbs富有创造性的研究了自然的另一个极端，并说：“让我的发展一套研究二十亿个变量的分析方法吧！”。也就是说，物理学家，通常以数学家为先锋，开始发展了一套基于概率统计的处理混乱复杂体系的工具。<br>什么是混乱复杂问题呢？想象这样一幅物理图景来感觉一下这样的体系。经典的19世纪动力学擅长于研究和描述一个象牙球在台球桌上的运动。实际上，象牙球在台球桌上的运动位置与时间的关系是非常经典的朴素问题研究体系。人们可以研究更多的象牙球在桌上共同运动的情形，不过随着球的数量的增多，问题的复杂度也在极具的上升。事实上，确实有人研究过标准台球比赛中象牙球的运动行为，尽管在理论上是可行的，但是当你同时研究10到15个球的运动行为时，实际需要的大量人力劳动将使得这项研究无法实行（译者：1948年计算机尚处于萌芽阶段）。<br>想象一下，一个巨大的台球桌上包含了上十亿个台球在滚动，相互碰撞，令人惊奇的是这样的体系反而因为统计学可以应用其中而变得容易研究了。尽管单个的球体的运动轨迹无法被追踪，但是很多有用的问题可以得到解答，譬如说：平均每秒有多少球与球台边缘碰撞？平均每个球在碰到其他球之前运动了多远的距离？平均每个球每秒受到多少次撞击？<br>早些时候我们说这种新的统计方法可以适用于“混乱复杂体系”，数十亿个台球在球桌上运动的问题为什么可以描述为“混乱复杂体系”呢？这种统计的方法适用的前提是球的运动为位置的随机的，也就是“混乱”的。譬如，如果我们将所有的球都放置在一行之上并且让他们严格的平行于竖列运动，这些球将永远无法相互以及与竖列的边沿碰撞，统计的方法也就不再适用了，这个体系也不是“混乱复杂体系”了。<br>从上面描绘的图景中我们清楚的认识了混乱复杂体系的意义。这类问题具有大量的变量，并且其中的变化是混乱的，甚至是完全不可预测的。但是，尽管其混乱性非常强，但是体系整体的行为是有规律的，其平均性质是可以解析的。<br>大量的实际体系可以归结为混乱复杂体系，其方法的准确性随着体系数量的增长而提高。在大量电话线路交换的预测平均拨号频率，以及相同拨号冲突的概率等问题中，这样的方法被证明是有效的。这种方法同样也确保了生命保险公司的财务稳定，尽管保险公司并不知道每个投保人的生活状况，但是公司可以了解群体的平均死亡率。<br>最后，重要而且有趣的一点是，统计方法学并不是完全依照理论中对每个个体行为完全理解的基础上应用的。在前面的台球桌的例子中，牛顿力学可以完美的解释和预测台球的碰撞行为。但是在保险公司的例子中，个体的行为（死亡率）实际上是受到一系列复杂因素影响的，因而是不可知的。<br>尽管保险公司以及电话线路的例子展现了统计学的实际应用前景，但在某种程度上，这些并不是很好的例子，因为这些例子使得人们忽视了统计学在更基础的自然科学中的应用和贡献。从组成物质的原子运动到组成宇宙的星体的运动都使用统计学进行研究。遗传理论应用了统计学分析，描述一些物理体系发展运动方向（孤立体系熵增）的热力学定律是通过统计学推导而出的。现代物理的架构，我们对自然世界的物理规律，以及目前获得的实验观测数据都是建立在统计学的概念上的。实际上，观测结果以及对观测结果的推论都是建立在统计思想上的，因此概率的思想构成了知识和理论本身。</p>
<h4 id="有序复杂问题"><a href="#有序复杂问题" class="headerlink" title="有序复杂问题"></a>有序复杂问题</h4><p>强大的统计学工具相比于处理一两个变量的朴素问题的方法有了很大的提升，但是却留下了很大一部分未探索的情形。研究者常常试图过分的简化问题，声称科学的研究体系不是只有一两个变量的朴素简单体系就是具有天文数量变量的混乱复杂体系，然后忽略很大一部分的中间地带。 这个中间地带为什么重要呢？并不是因为这部分涉及的变量数目比三两个要多，而又比一小撮盐当中的原子数目要少。对于这部分科学尚未涉足的中间地带，真正重要的特征是他们呈现出一种有秩序的特征————与前述的统计学支配的无序复杂体系不同————因此我们又可以称这部分问题为有序复杂问题(Organized complexity)。<br>月见草(primrose)因何而开？为什么盐水不能止渴？为什么一支菌株可以合成某种化学物质而另一支却不行？为什么一种有毒的物质的镜像对映体却是无毒的？ 为什么饮食中的锰元素含量会影响动物的母性行为？ 如何从生物的角度解释衰老？ 还有下面这些问题的研究会有什么意义呢： 病毒是否是“活”的？ 基因是什么？基因是如何靠表达自身指导生物发育的？ 复杂的蛋白组装体是否“指导”如何复制自身？这与生物体的繁殖有关么？ 所有这些问题都是一类复杂的问题，但却不是统计学支配的无序复杂的(disorganized complexity), 他们是关于一类有大量相互作用的变量共同形成的有机整体的问题，他们都是我这里所说的，有序复杂问题(organized complexity)。<br>小麦的价格与什么相关呢？这也是一个有序复杂问题。很多变量与之相关，并且这些变量也是相互关联形成一个复杂的整体的。<br>经济体系是如何维持稳定的呢？ 依赖于供需平衡的经济体系有多安全呢？ 应该多大程度上应用调控使得经济不至于波动太大？这些问题也是关于复杂体系的问题，因为研究的体系是一个有机的整体，其中的每一部分斗都与其他部分紧密相关。<br>我们该如何解释一个群体例如一个实验室的人员，一群工人或者一个种族的行为模式呢？显然很多因素在这其中起作用，然而使用数学平均的方式来描述它是不够的。 给定一个国家一定可以消耗的资源，采用什么样的策略才更可能获得战争的胜利？ 或者另一方面，放弃多少自私的欲望将更有效的保持世界的和平？<br>这些问题，以及一系列类似关于生物，医药，心理，经济以及政治科学的问题，对于19世纪流行的处理三两个变量的经典理论来说太复杂了。同样的，也不能被广泛应用在处理无序混乱体系中的统计学解释。<br>这些问题又与世界发展的未来如此相关，以至于要求科学进行第三次革命，比19世纪学会处理三两个变量的革命，以及20世纪学会处理无序混乱体系的革命更为重要。科学界必须在今后的50年里学会处理有序复杂体系。<br>目前又什么能确保这样的革命可以完成呢？ 有一些曙光确实存在，存在于这样一个事实：全世界数百名学者已经开始在思考这些问题了。 物理学中使用的定量实验的方法以及数学分析的工具从未有过的被应用在生物学，医学甚至是社会学的研究中。 目前获得的成果尽管是零散的，但却十分可信。 与25年前相比，我们在生物学中的癌症研究已经获得了更加清晰的图景。无疑我们对癌症的认识还是肤浅的，但我们已经发展了一些研究工具并且基本肯定了一些关键问题之所在。 我们知道一些癌症类型是可以被某种化学品诱发的，了解了一些类型的癌症的遗传易感性。原子物理发展出了百万伏甚至更强的射线。 发射性元素可以用来进行基础研究以及治疗。 科学家正在面对生物体中最为复杂的生化过程。 对于正常细胞的了解将有助于我们识别病态的细胞，尽管距离这个目标还很遥远，至少我们已经在解决问题的路上了。<br>除了上述的正在发展的可能解决问题的方向，还有至少两个很可能有助于我们发展的特别的事情。 罪恶的战争最终留下了帮助我们解决复杂问题的曙光。<br>其中之一即是在战争时期发展的电子计算机，这种装置的灵活性和可用性更类似于人类的大脑而不是传统的机器。它们具有存储大量信息的“记忆”，它们也可以被“指示”去独自完成复杂的科学计算。它计算十位数乘法的速度比人脑快4万倍。 灵活性，可用性以及快速性的集合使得它将对科学的发展产生巨大的影响。 它们使得过去过于复杂的问题能够得到解决，更重要的是，它将促成新的分析复杂体系的方法的建立。<br>第二个战时产生的进步是建立“多元化团队(mixed-team)”来解决问题。 尽管在未军方进行数学计算的人已经非常熟悉这个名词了，但我还是要介绍一番。<br>想象这样一个场景，为大西洋上的目标提供护航以及补给，考虑可以使用的舰艇数量，潜艇攻击能力以及其他可量化的和不可量化的因素。 如何组织才是最好的方案？综合考虑到速度，安全性，经济性等指标？ 护航编队应该是大是小？速度要快还是慢？ 他们应该迂回前进还是直线前进？ 应该如何组织，如何防御才是最好的？ 什么样的组织和架构形式才能更好用于巡防和攻击？<br>试图去回答这些宽泛的战术问题的工作团队就是运作分析团队(operations analysis groups)。 从英国开端，在纳粹的反潜艇作战以及陆军防空队中大放异彩，这样的运作分析团队更多的被称为“多元化团队”。 尽管数学家，物理学家以及工程学家都是必要的，实际上最好的交叉团队包含了心理学家，生化学家，生理学家以及多种生物医药以及社会学方面的代表性任务。 例如在优秀的英国多元化团队中，就包含了内分泌专家和X射线晶体学家。 在战争的压力下，这些交叉团队在同一个普遍性的问题上施展了队员各自不同角度的才华。 尽管现代科学有专业分工增强的趋势，但是最终人们发现在多元化团队中的人可以共同工作并且形成一个整体效用大于所有人之和的组织。 实践证明这样的团队可以针对一个复杂性问题进行研究并且获得有用的解答。<br>预测在未来50年将会实现的科学的巨大进步中，将会有交叉团队的贡献，就像他们在战时做的那样。计算机的发展更会提高他们的效率。 但是，并不能认为这就是未来科学工作的方式。 一定会有那种只有在独立的环境下才能保持思维的自由的科学家，那样的人一定会独立工作。 前者则是更“美国”的做事方式。 不同方式之间的竞争将是有益的，所以这里并没有一定要描绘一幅所有科学家都在同样的体系下工作。这里仅仅是建议一些学者可以寻求一种新的合作方式，在团队中包含所有必要领域的专家，这样一种新的工作方式，在计算机的帮助下，将为后半个世纪发展解决复杂生物和社会学问题的方法提供帮助。</p>
<h4 id="科学的界限"><a href="#科学的界限" class="headerlink" title="科学的界限"></a>科学的界限</h4><p>让我们会到最初的问题，什么是科学？什么不是科学？我们希望从科学获得什么？<br>科学显然是解决问题的一种方法————并不是所有的问题，但是是很大一部分重要的和实践性的问题。科学可以处理的问题是那些影响的主要因素是符合逻辑的基本规律，常常还是可以度量的问题。科学是这样的可重现的知识的集合，是专注与训练想象力，是权衡证据，是确定哪些现象是相关的，哪些是无关的，是验证假设，是丢失可能不准确的数据，是阐述，是面对事实，是让自然的真相服务于人类。<br>科学的本质并不是其外在的表现，不是其物理现象，而在于其内核的精神。 那些朴素却令人激动的探究方式也就是人们常说的科学方法。 科学的方法要求实施者诚实守信，头脑开放，视野聚焦以及热爱真理。 这些都是可贵的品质，但是科学却并不完全依赖它们，诗人往往也有同样的品质，并且将它们用在更纯高的地方。<br>科学已经在解决逻辑和定量问题上获得了极大的成功。事实上，这类成功实在是太多太伟大了，以至于失败的结果极少被公开发布，以至于普通的人一定觉得科学是人类完成的最伟大的事业。事实上，这样的看法的确有一点道理。<br>我们取得的成就大伟大了，以至于科学家没有理由走出固有的工作方式。 但我们必须清醒的认识到，尽管很多简单的问题已经被科学解决，还有很多复杂的，与人类未来相关的问题，任然摆在我们面前。<br>因此，我们必须停止认为科学永远是解决简单问题的成果的方法。这在某种程度上意味着我们不在把科学当做手中摆弄的小玩意儿，也不能认为科学史现代的可以掌控任何事的黑魔法。<br>我认为所有科学家都会对科学在未来为人类福祉作出巨大贡献怀有信心。科学将会继续认识物理，了解自然法则，学会预测以及调控，创造新的物质攻人们使用或者娱乐。 科学将会继续帮助我们认识动物的本性，提高健康水平，延长寿命以及更加了解人类的行为。实际上，我认为有追求的科学家还“得寸进尺”的希望这种精确的，客观的分析手段可以应用于过去极少涉足的社会学以及政治学的领域。<br>甚至更进一步的，由于科学本身的特质，科学家坚持使用精确定义的术语以及明确阐述的问题进行交流。尽管在科学领域确实更容易获得清晰的定义，但是实际上科学的语言在表意的有效性上压倒一切自然语言，意识以及传统。 这种普适性对于跨域时空限制，跨越政治以及文化的界限是非常重要的。可能科学本身比任何有智慧的人更能够解决意识交流的问题，得到世界范围内的合作，分享以及获得科学成果。<br>是的，科学是一种强大的工具，获得了巨大的成功。然而谦逊和明智的科学家不会期待科学可以解决任何问题。 他记得科学教会我们重视特殊的情况，他不认为任何一个社会，经济或者政治问题会因为“科学家”的介入而自行解决，他不期待——也许有些例外——科学可以提供道德和美学的基准。他不期待科学能够度量或者控制人类的爱，纯真，价值观以及信仰。人生之中有太多无形的难以衡量的感性存在，它们是无法在显微镜下观测的，无法在天平上称量的，无法被最灵敏的话筒记录。<br>如果科学只是关于定量的逻辑的问题的话，如果科学不去关注价值以及目标，那么现代的有科学素养的人如何获得平衡的幸福生活？逻辑是美感的伙伴，效率是一种美德。<br>答案或许是简单的，那就是让我们的精神匹配我们的技术。为什么要这样呢？使得我们驾驭力量的智慧与我们所拥有的力量匹配需要多方面的努力。我们必须加强对个体以及群体行为的理解，必须加强不同语言和文化背景的人之间的交流，必须使用同样的规范分享我们的观点。我们对影响政治和经济的因素的理解必须有飞跃式的加深，必须建立起牺牲个人甚至民族的短期的自私的利益以换取对整个人类长期的贡献的意愿。<br>这些提升需要建立在对科学到底是什么的理解上，建立在科学不可避免的展现出强大的影响力的世界中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2017/05/26/科学范式与数据科学/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2017/05/26/科学范式与数据科学/" itemprop="url">科学范式与数据科学</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-26T22:56:07+08:00">
                2017-05-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/General-Science/" itemprop="url" rel="index">
                    <span itemprop="name">General Science</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>清华大学大数据分析（B）朱文武</p>
<h3 id="科学"><a href="#科学" class="headerlink" title="科学"></a>科学</h3><p>对自然的观察？ 肉眼观察 -&gt; 仪器观察 -&gt; 数据观察（大量仪器）<br>归纳与推理     哲学归纳 -&gt; 数学与物理归纳 -&gt; 建模归纳<br>应用与推广<br>因果关系——关联关系     </p>
<ul>
<li>start from model to data improvement</li>
<li>start from data to model implementation<br>#### </li>
<li>数据驱动/数据决策（data-driven)</li>
<li>模型驱动/经验决策 (model-driven)<h3 id="实验科学（古希腊时代）"><a href="#实验科学（古希腊时代）" class="headerlink" title="实验科学（古希腊时代）"></a>实验科学（古希腊时代）</h3>观察与实验<h3 id="理论科学（西方近代）"><a href="#理论科学（西方近代）" class="headerlink" title="理论科学（西方近代）"></a>理论科学（西方近代）</h3>物理模型<h3 id="计算科学（现代）"><a href="#计算科学（现代）" class="headerlink" title="计算科学（现代）"></a>计算科学（现代）</h3>数学模型构建——定量分析——仿真模拟<h3 id="数据科学？"><a href="#数据科学？" class="headerlink" title="数据科学？"></a>数据科学？</h3>理论+实验+计算？<h3 id="computational-thinking"><a href="#computational-thinking" class="headerlink" title="computational thinking"></a>computational thinking</h3></li>
<li>data -&gt; knowledge -&gt; intelligence -&gt; decision<br>37度    人体正常温度36度~37度    不算发烧    不用去医院</li>
<li>数据如何变成知识？ 数据的可解释性（find-defined)</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2017/05/01/Fun-with-your-first-Day-with-Matlab-S01E02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2017/05/01/Fun-with-your-first-Day-with-Matlab-S01E02/" itemprop="url">Fun with your first daty with Matlab S01E02</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-01T23:32:35+08:00">
                2017-05-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/MATLAB/" itemprop="url" rel="index">
                    <span itemprop="name">MATLAB</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h3><p>上一节当中我们说到了如何使用MATLAB作为高级的计算器，事实上，数据处理的过程就是对“数字”进行计算从而获取有意义的信息的过程。理论上来讲，如果时间足够多，我们就可以使用计算器手工计算处理任何的数据。然而，这种方式太过繁琐，如果要处理成千上万条数据记录，还不是要被累死!更重要的是，处理这些数据的方法大多数情况下都是固定的，重复的。对于这种由明确定义的，固定的，重复的工作，交给计算机程序来做真是最好不过了。幸运的是，有很多数据处理的任务都是这样的。使用计算机语言批量的执行任务，我们需要写“脚本”。脚本(Script)就是一组指令，写好以后计算机会按照顺序依次执行，而不需要有人在一旁看管，实在是非常方便。那么我们就开始学习如何写MATLAB的脚本吧！</p>
<h3 id="MATLAB中的数据类型"><a href="#MATLAB中的数据类型" class="headerlink" title="MATLAB中的数据类型"></a>MATLAB中的数据类型</h3><p>数据类型是计算机程序中非常重要的概念。计算机工作的原理就是对数据进行操作，因此数据类型应该是非常基础和重要的东西啦！学过C语言的同学可能还记得，C语言中有整形变量(int:0,1,2,3…), 单精度浮点类型(float:1.0,1.2….)等等数据类型。像C语言这样的，在声明变量之前，首先要声明变量类型的语言，被称为【强类型语言】。例如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//声明变量i为整型变量，初始值为0</span></div></pre></td></tr></table></figure></p>
<p>MATLAB的脚本语言，在声明变量的时候并不需要声明类型，而是由解释器（将MATLAB脚本进一步解释为计算机能够理解的指令的东西）决定变量的类型，这样的语言被称为【弱类型语言】。最近火热的Python也是弱类型语言哦。弱类型语言实际上是方便使用者，也就是编程人员，的一项设计。不过相比与类型严格的强类型语言，在使用弱类型语言的时候，有可能会渐渐忘记或者搞混变量的类型，引发程序错误。如果错误在运行时被发现的话，还是很好的。可是，如果在运行时因为类型错误而进行了错误的计算，解释器并没有因此报告错误的话，是可能使处理出来的数据完全没有意义的。因此，在完成复杂的程序编写以后进行测试以便确定算法的正确性是一个非常重要的好习惯。为了保持这样的习惯，你需要在下意识里“质疑”自己写的程序。</p>
<h4 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h4><p>上一节我们讲到，MATLAB可以被认为是Matrix Lab的缩写，可见，矩阵在MATLAB中的重要地位。 矩阵可以类比于C语言中的数组，是包含一组<strong>同类</strong>数据的<strong>容器</strong>。【容器】在计算机术语里面称为Container。正如其名，是包含一组数据的结构。MATLAB中的矩阵的特点是只能包含同类型的数据，除了数学上的数字以外，还可以包含字符串，引用等等。矩阵的数据结构还可以让我们轻易的进行高效的矩阵运算，如矩阵乘法，转置，求逆等等。使用矩阵的思维进行数据处理，还可以大大加快程序运行的速度，这样的技术被称为“向量化”。我在自己的工作中，超过一半的计算都是通过矩阵进行的。</p>
<h5 id="矩阵基础"><a href="#矩阵基础" class="headerlink" title="矩阵基础"></a>矩阵基础</h5><p>矩阵是有【维度】的，这个维度就是指矩阵的大小。在MATLAB中，我们可以通过size函数获取矩阵的大小。例如：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">x = <span class="built_in">rand</span>(<span class="number">5</span>); <span class="comment">%创建5x5的矩阵</span></div><div class="line">[nr,nc] = <span class="built_in">size</span>(x)</div><div class="line">nr = </div><div class="line"><span class="number">5</span></div><div class="line">nc = </div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure></p>
<p>上面的代码中我们使用rand函数创建了一个5x5的随机数矩阵，使用size函数可以获取矩阵的行数和列数。值得注意的是，在编写程序或者脚本的时候，变量的命名非常重要。因为程序是写给人看的，而不是给计算机看的。因此，使用良好的变量命名规范，可以使得程序的【可读性】变得更好，方便自己和他人阅读程序。这里，nr和nc是常用的矩阵大小变量命名，是number of row以及number of column的缩写。不同的语言的变量命名也不尽相同，Python的变量命名非常喜欢使用下划线_，因此，同样含义的变量可能会被命名为num_row以及num_col。如果我们希望只得到矩阵的行数，可以使用<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nr = <span class="built_in">size</span>(x,<span class="number">1</span>);</div><div class="line">[nr,~] = <span class="built_in">size</span>(x);</div></pre></td></tr></table></figure></p>
<p>这两种写法。其中，第一种写法使用了size函数的可变参数的功能。可变参数是指一个函数可以输入多种可能数量的参数，并因此而改变函数的行为。MATLAB中大多数函数都是有可变数量参数的，这样设计的目的是为了既保证函数调用的简洁性，又保持函数调用的灵活性。<br>怎么理解呢？譬如说我们现在有一个add函数，作用是给传入的参数加上一个值。我们在使用的过程中发现，大多数情况下，我们都是给传入参数加上1的，因此，我们可以把add函数设计为一个可变参数的函数。当调用<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">add(x);</div></pre></td></tr></table></figure></p>
<p>时，函数的行为是返回x+1的值。当调用<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">add(x,a)</div></pre></td></tr></table></figure></p>
<p>时，函数的行为是返回x+a的值。这样在大多数情况下我们都可以按照前者的方式调用函数，非常的简洁方便。可是我们需要使用add函数提供的更灵活的功能时，例如加上a，我们又可以按照后者的方式进行调用。这就是所谓的既保证函数调用的简洁性，又保持函数调用的灵活性，是不是很方便呢？在这个例子里，add函数的第一个参数是必要的，否则就不知道在谁的基础上做加法了。第二个参数是可选参数，可以指定，如果没有指定就使用默认值。<br>size函数调用的第一种写法中第二个参数1就是可选的参数。它代表传入的矩阵的轴的次序。1是指列，2则是指行。在matlab中的矩阵，因为常常与数据处理相关，因此矩阵的行往往表示<strong>观测结果</strong>，列往往表示<strong>观测的维度</strong>。譬如我们对小学生早晨上学这个事情进行观测，那么默认我们的数据集矩阵的行是上学的每一个小学生，列则是相应学生的身高，体重等等信息。<br>第二种获取矩阵大小的方式我们使用了符号~。“~”代表我们在之后的计算中不需要使用相应位置的变量。这使得matlab脚本在执行的时候不在为这部分数据分配储存空间，因此在程序运行的效率上会更好一些。</p>
<h5 id="创建矩阵"><a href="#创建矩阵" class="headerlink" title="创建矩阵"></a>创建矩阵</h5><p>我们常常需要创建新的矩阵，新矩阵的创建有很多种方法<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = <span class="built_in">zeros</span>(<span class="number">5</span>) <span class="comment">%创建5行5列的零矩阵</span></div><div class="line">a = <span class="built_in">zeros</span>(<span class="number">5</span>,<span class="number">3</span>) <span class="comment">%创建5行3列的零矩阵</span></div><div class="line">a = <span class="built_in">zeros</span>(<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>) <span class="comment">%创建5行3列2层的零矩阵</span></div></pre></td></tr></table></figure></p>
<p>类似的，我们还有<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = <span class="built_in">ones</span>(<span class="number">5</span>,<span class="number">1</span>) <span class="comment">%创建5行1列的全1矩阵</span></div><div class="line">a = <span class="built_in">nan</span>(<span class="number">5</span>,<span class="number">1</span>) <span class="comment">%创建5行1列的全无效数字矩阵</span></div><div class="line">a = <span class="built_in">rand</span>(<span class="number">5</span>,<span class="number">1</span>) <span class="comment">%创建5行1列的随机矩阵</span></div><div class="line">a = <span class="built_in">randn</span>(<span class="number">5</span>,<span class="number">1</span>) <span class="comment">%创建5行1列的正态分布随机矩阵</span></div><div class="line">a = <span class="built_in">eye</span>(<span class="number">5</span>) <span class="comment">%创建5阶单位矩阵</span></div></pre></td></tr></table></figure></p>
<p>我们也可以直接创建矩阵，使用中括号表示矩阵的起始，逗号或者空格表示矩阵的行间隔，分号表示列间隔。例如：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</div><div class="line">a = </div><div class="line">[ <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></div><div class="line">  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></div><div class="line">  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>]</div></pre></td></tr></table></figure></p>
<p>还可以使用冒号：操作符建立等差的行向量（1行n列的矩阵），例如<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = <span class="number">1</span>:<span class="number">1</span>:<span class="number">10</span> <span class="comment">%建立一个以1为始，1为步长，10为终止的行向量</span></div></pre></td></tr></table></figure></p>
<p>当步长为1的时候，也可以省略，直接用1:10表示起始位置。<strong>注意,MATLAB中所使用的符号均为英文符号！</strong></p>
<h5 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h5><p>创建矩阵以后，我们还需要对元素进行操作。这些操作主要包括索引和赋值。索引就是通过编号来查找矩阵中某一个位置的元素的值，赋值就是改变某一个位置元素的值。<br>矩阵是通过行列来进行索引的，索引用括号表示，括号内可以使用逗号进行分割，表示行或者列的区别。例如：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</div><div class="line">a = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span></div><div class="line">     <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></div><div class="line">     <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</div><div class="line">x = a(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">% 索引矩阵a的1行2列的数值</span></div><div class="line">x = <span class="number">2</span></div></pre></td></tr></table></figure></p>
<p>MATLAB中存储矩阵数据是按照列存储的，因此也可以使用序号对矩阵数据进行索引，因为MATLAB的序号是以1开头的，因此需要的最大值是行数*列数。这种索引方法并不推荐，因为并不直观，容易出BUG，但是介绍这种方法的意义在于写代码的时候有时会因为不注意而忘记写行列索引中的逗号，这种情况下MATLAB可能仍然执行代码，只不过是按照上面介绍的序号索引取值，而不会引发错误警告。在这种情况下，计算实际上是错误的，因为你索引到的数据并不是你想要的，然而MATLAB的解释器并不会发现这个错误，因而是十分危险的。<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x = a(<span class="number">3</span>) <span class="comment">%索引矩阵a的第3个值</span></div><div class="line">x = <span class="number">7</span></div><div class="line">x = a(<span class="number">8</span>) <span class="comment">%索引矩阵a的第8个值</span></div><div class="line">x = <span class="number">6</span></div></pre></td></tr></table></figure></p>
<p>同时，我们也可以向量化的进行索引，冒号在这里表示在相应的维度取所有有效的值<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x = a([<span class="number">1</span>,<span class="number">2</span>],<span class="number">3</span>) <span class="comment">%索引矩阵a的第1,2行，第3列的值</span></div><div class="line">x = [<span class="number">3</span></div><div class="line">     <span class="number">6</span>]</div><div class="line">x = a(<span class="number">3</span>,:) <span class="comment">%索引矩阵a的第3行，所有列的值</span></div><div class="line">x = [<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</div></pre></td></tr></table></figure></p>
<p>end在索引中代表相应维度的最后一个有效的序号<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x = a(<span class="keyword">end</span>,<span class="number">3</span>) <span class="comment">%索引矩阵a最后一行，第三列的值</span></div></pre></td></tr></table></figure></p>
<p>索引中还有一个很重要的方法叫做逻辑索引。在实际应用中，这种索引方式非常方便，可以使得代码更简洁，运行速度也更快。逻辑索引是在索引的位置不传入索引的需要（如第1行，第3列等），而是传入一个与被索引矩阵相应维度等长的逻辑数组，其中每个逻辑元素表示相应的位置是否会被索引到，如果为True就表示索引到，反之则为被忽略掉。例如，我们对一个随机向量r,想要获取数值大于0.5的所有值，可以这样操作<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">r = <span class="built_in">rand</span>(<span class="number">10</span>,<span class="number">1</span>) <span class="comment">%建立[0,1]均匀分布的10行列向量</span></div><div class="line">logicTag = r &gt; <span class="number">0.5</span> <span class="comment">%获取元素是否大于0.5的逻辑向量，向量大小与r相同</span></div><div class="line">x = r(logicTag)</div></pre></td></tr></table></figure></p>
<p>在实际应用中这种方式非常有用，例如：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">t = importdata(<span class="string">'sales.csv'</span>) <span class="comment">%一个3列的表格，每一列分别表示 商品出售时间，商品价格，商品折扣</span></div><div class="line">logicTag = t(:,<span class="number">2</span>) &gt; <span class="number">10</span> <span class="comment">%获取商品价格大于10的逻辑向量</span></div><div class="line">saleTime = t(logicTag,<span class="number">1</span>) <span class="comment">%获取商品价格大于10的商品的出售时间</span></div></pre></td></tr></table></figure></p>
<p>在上面的例子中我们非常方便的获取了商品价格大于10的商品的出售时间，而不需要循环判断。<br>元素操作的另一个重要方面是元素的赋值。上面我们进行取值的时候，元素的索引放在了等号的右边。当进行元素赋值的时候，索引就放在等号的左边来告诉MATLAB的解释器将数值赋值给哪些元素。例如：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</div><div class="line">a = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span></div><div class="line">     <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></div><div class="line">     <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</div><div class="line">a(<span class="number">1</span>,<span class="number">3</span>) = <span class="number">0</span> <span class="comment">%将1行3列的元素赋值为0</span></div><div class="line">a = [<span class="number">1</span> <span class="number">2</span> <span class="number">0</span></div><div class="line">     <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></div><div class="line">     <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</div></pre></td></tr></table></figure></p>
<p>赋值的时候有两种赋值的形式。一种是按照元素赋值，一种是广播赋值。<br>按照元素赋值的时候，等号的左右两边必须是维度相同的矩阵，例如<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a(<span class="number">1</span>,:) = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]; <span class="comment">%正确，等号左右两边都是1行3列</span></div><div class="line">a(<span class="number">1</span>,:) = [<span class="number">0</span>;<span class="number">0</span>;<span class="number">0</span>]; <span class="comment">%报错，等号的左边是1x3向量，右边是3x1向量</span></div></pre></td></tr></table></figure></p>
<p>另外一种赋值的方法是广播赋值，顾名思义，在这种形式下，等号右边是单一数值，数值将赋值给左边表示的矩阵的任意一个元素，例如：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</div><div class="line">a = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span></div><div class="line">     <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></div><div class="line">     <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</div><div class="line">a(<span class="number">1</span>,:) = <span class="built_in">inf</span></div><div class="line">a = [inf inf inf</div><div class="line">     <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></div><div class="line">     <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</div></pre></td></tr></table></figure></p>
<p>无穷大inf这个值就赋予了左边a矩阵的1行所有列的所有位置上<br>上面学的索引的方法在赋值的时候都可以使用，因此我们可以快速的实现很多效果，比如有两个等长的向量a和b，我们希望将a中大于0的数字都替换成对应位置的b的数字，可以这样：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bLogic = a &gt; <span class="number">0</span>;</div><div class="line">a(bLogic) = b(bLogic);</div></pre></td></tr></table></figure></p>
<p>是不是很方便呢？</p>
<h5 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h5><p>矩阵的运算非常多，这里介绍主要的几种。<br><strong>转置</strong>：矩阵的转置是常见的矩阵运算，数学中的转置用T来表示，在MATLAB中，用英文中的一撇来表示<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A = A';</div></pre></td></tr></table></figure></p>
<p>矩阵的转置除了本来的数学意义以外，很多情况下也用来将原始的数据进行转置以满足一些函数的输入需求，某些函数要求输入的数据是行向量或者列向量的形式。<br><strong>统计计算</strong>：统计计算中经常要求计算最大值，最小值，标准差等等统计量。这些统计量的计算在MATLAB中都有具体的函数，以max函数为例：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>; <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</div><div class="line">b = max(a) <span class="comment">%默认，按列取最大值</span></div><div class="line">b = <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></div><div class="line">b = max(a,[],<span class="number">2</span>) <span class="comment">%按行取最大值</span></div><div class="line">b = [ <span class="number">3</span></div><div class="line">      <span class="number">6</span></div><div class="line">      <span class="number">9</span>]</div></pre></td></tr></table></figure></p>
<p>因为MATLAB的逻辑中，行代表观测的样本，列代表观测特征，因此在默认情况下，统计函数都是对列进行计算，也就是对观测的特征进行计算。也可以通过输入特别的参数来指定特定的计算维度。如果想要得到一个矩阵的最大值怎么办呢？<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">b = max(max(a)) <span class="comment">%naive的方法</span></div><div class="line">b = max(a(:)) <span class="comment">%高级的方法</span></div></pre></td></tr></table></figure></p>
<p>a(:)的方法可以将矩阵a完全向量化为一个列向量,因此使用一次，max函数就可以得到整个矩阵的最大值。<br><strong>数值计算</strong><br>矩阵可以直接与一个数值进行加减乘除，结果是矩阵中每一个元素对这个数值进行加减乘除；矩阵相互之间可以相互加减，要求是相互加减的矩阵维度大小相同，例如其中一个矩阵是3x5的矩阵，另一个矩阵也必须是3x5.矩阵之间也可以相互乘除，要求也线性代数的一样。<br>那么，如果想要让矩阵中每一个元素分别乘除另一个矩阵中对应的元素怎么办呢？只要在乘除符号前加上英文的.就可以。.*和./代表的含义就是逐元素的乘和除。此时要求两个矩阵对应维度大小相同，与矩阵相互加减的情况相同。</p>
<p>这里举一个例子，在数据分析中有一个常见的需求是对各个观测量的数值进行归一化，也就是让各个观测维度的数值均值为0，方差为1。这样做的好处是使得各个观测的特征对数据分布的贡献相同。这样讲有点抽象，我们再举一个实际例子，譬如说我们对房价的一个观测：</p>
<table>
<thead>
<tr>
<th>样本序号</th>
<th>与中心城区距离</th>
<th>面积</th>
<th>价格</th>
<th>层高</th>
<th>客厅面积与卧室面积之比</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>50</td>
<td>100</td>
<td>1000000</td>
<td>20</td>
<td>0.5</td>
</tr>
<tr>
<td>2</td>
<td>20</td>
<td>80</td>
<td>2000000</td>
<td>15</td>
<td>0.8</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>在这个例子里面一个房子就是一个观测样本，房子的面积、价格等等都是对于这个样本的观测属性，或者说是特征。不同的特征，数值范围不同。在这个例子当中，房价这个特征数值最大，客厅卧室面积之比这个特征数值最小。可是如果不做处理，价格这个特征的变化量在数值上要远远大于面积之比的变化量，这样就可能掩盖后者变化造成的影响。为了在数值上让不同的特征的变化有相同的权重，就需要做归一化。也就是让不同的特征在所有样本上的值均值为0，方差为1。在数学上，假设某个维度用$X$表示，$X_i$表示第i个观测值，$\mu_x$表示$X$的均值，$\sigma_x$表示$X$的标准差,使用$X_i^{transformed}$表示转换以后的特征数值。那么可以使用<br>$$X_i^{transformed}=\frac{X_i-\mu_x}{\sigma_x}$$<br>这个公式进行归一化转换。假设我们我们这个观测的表是x，一个最为naive的操作是：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[nr,nc] = <span class="built_in">size</span>(x); <span class="comment">%获取行数和列数</span></div><div class="line"><span class="keyword">for</span> m = <span class="number">1</span>:nc <span class="comment">%对于每一列</span></div><div class="line">    rowMean = mean(x(:,m));</div><div class="line">    rowStd = std(x(:,m));</div><div class="line">    <span class="keyword">for</span> n = <span class="number">1</span>:nr <span class="comment">%对于每一行</span></div><div class="line">        x(n,m) = (x(n,m) - rowMean)/rowStd;</div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>另一种操作是通过向量化的方式，其中repmat的作用是将一个矩阵重复堆叠。repmat(x,2,1)的含义是将x矩阵当做一个元素堆叠为两行一列，如果x的的维度是mxn，那么堆叠以后就会成为(2*m)xn的矩阵。<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">L = <span class="built_in">size</span>(x,<span class="number">1</span>); <span class="comment">%获取x表格的长度/矩阵的行数</span></div><div class="line">xMean = mean(x); <span class="comment">%获取x的各个维度(各列)的平均值</span></div><div class="line">xStd = std(x); <span class="comment">%获取x的各个维度(各列)的标准差</span></div><div class="line">x = (x - <span class="built_in">repmat</span>(xMean,L,<span class="number">1</span>))./<span class="built_in">repmat</span>(xStd,L,<span class="number">1</span>);</div></pre></td></tr></table></figure></p>
<p>那么关于向量数据结构的讲解就到这里吧！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/HansenZhao.github.io/page/2/">2</a><a class="extend next" rel="next" href="/HansenZhao.github.io/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/HansenZhao.github.io/images/zhs.png"
                alt="Hansen Zhao" />
            
              <p class="site-author-name" itemprop="name">Hansen Zhao</p>
              <p class="site-description motion-element" itemprop="description">Machine Learning & Coding</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/HansenZhao.github.io/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/HansenZhao.github.io/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/HansenZhao" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="zhaohs12@163.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hansen Zhao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/HansenZhao.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/HansenZhao.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/HansenZhao.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/HansenZhao.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/HansenZhao.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/HansenZhao.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/HansenZhao.github.io/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/HansenZhao.github.io/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/HansenZhao.github.io/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
