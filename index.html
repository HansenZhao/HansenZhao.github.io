<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/HansenZhao.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/HansenZhao.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/HansenZhao.github.io/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/HansenZhao.github.io/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/HansenZhao.github.io/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/HansenZhao.github.io/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/HansenZhao.github.io/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Machine Learning &amp; Coding">
<meta property="og:type" content="website">
<meta property="og:title" content="HansenZhao&#39;s Blog">
<meta property="og:url" content="https://hansenzhao.github.io/index.html">
<meta property="og:site_name" content="HansenZhao&#39;s Blog">
<meta property="og:description" content="Machine Learning &amp; Coding">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HansenZhao&#39;s Blog">
<meta name="twitter:description" content="Machine Learning &amp; Coding">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/HansenZhao.github.io/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://hansenzhao.github.io/"/>





  <title>HansenZhao's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/HansenZhao.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HansenZhao's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Share with ZhuangBiology</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/HansenZhao.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/HansenZhao.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/HansenZhao.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2018/03/06/Notes of A new kind of science-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2018/03/06/Notes of A new kind of science-01/" itemprop="url">Notes of A new kind of Science-01</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-06T13:00:00+08:00">
                2018-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/General-Science/" itemprop="url" rel="index">
                    <span itemprop="name">General Science</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Chapter-01-The-Foundations-for-a-New-Kind-of-Science"><a href="#Chapter-01-The-Foundations-for-a-New-Kind-of-Science" class="headerlink" title="Chapter 01: The Foundations for a New Kind of Science"></a>Chapter 01: The Foundations for a New Kind of Science</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><h4 id="传统科学是否能真正的解释自然？"><a href="#传统科学是否能真正的解释自然？" class="headerlink" title="传统科学是否能真正的解释自然？"></a>传统科学是否能真正的解释自然？</h4><blockquote>
<p>If theoretical science is to be possible, then at some level the systems it studies must follow definite rules…But the crucial realization that led me to develop the new kind of science in this book is that there is in fact no reason to think that systems ike those we see in nature should follow only such traditional mathematical rules.</p>
<h4 id="计算可能是是相比于数学更普适的描述自然的方法"><a href="#计算可能是是相比于数学更普适的描述自然的方法" class="headerlink" title="计算可能是是相比于数学更普适的描述自然的方法"></a>计算可能是是相比于数学更普适的描述自然的方法</h4><ul>
<li>想法：这里使用计算而非计算机，主要是因为我认为现代的计算机架构未必就是最优化的形式。现代计算机的运行基本上是线性的，独立的，不同计算单元之间的联系是非常复杂的。但是元胞自动机以及自然界中存在的计算本质上是多核心（去中心化），并行以及非线性的。不同个体之间的联系是本征的。并行化与相互作用是自然产生复杂现象的必要条件。<h4 id="简单的规则也可以产生复杂的行为（元胞自动机）"><a href="#简单的规则也可以产生复杂的行为（元胞自动机）" class="headerlink" title="简单的规则也可以产生复杂的行为（元胞自动机）"></a>简单的规则也可以产生复杂的行为（元胞自动机）</h4><h4 id="已有的科学范式将整体分解为部分，并仔细的研究各个部分的性质（蛋白）"><a href="#已有的科学范式将整体分解为部分，并仔细的研究各个部分的性质（蛋白）" class="headerlink" title="已有的科学范式将整体分解为部分，并仔细的研究各个部分的性质（蛋白）"></a>已有的科学范式将整体分解为部分，并仔细的研究各个部分的性质（蛋白）</h4></li>
<li>想法：【科学】的思维模式也被广泛的应用到了社会治理至少。工人们和学生们一天中大部分的时间扮演了机器上的一颗螺丝钉，其独特的情感以及创造性被忽略且被视为社会机器的一个组成部分。只有当下班或者下课以后，他们的生命才再次鲜活起来，变成了了一个真正的人，尽管还要与劳作以后的疲惫奋战。<br>In the existing sciences much of the emphasis over the past century or so has been on breaking systems down to find their underlying parts, then trying to analyze these parts in as much detail as possible.<h4 id="计算等价定理（Principle-of-Computational-Equivalence）"><a href="#计算等价定理（Principle-of-Computational-Equivalence）" class="headerlink" title="计算等价定理（Principle of Computational Equivalence）"></a>计算等价定理（Principle of Computational Equivalence）</h4></li>
<li>想法：不同的观察视角是否会对复杂性产生不同的认识？复杂性显然的与时间和空间的次序相关，但是与观测的智能是否相关呢？是否观测的角度导致的复杂性？在【rule space】中观测是否就简单了？<br>Whenever one sees behavior that is not obviously simple, in essentially any system, it can be thought of as corresponding to a computation of equivalent sophistication.<h4 id="传统的数学公式表达仅仅适用于少部分体系"><a href="#传统的数学公式表达仅仅适用于少部分体系" class="headerlink" title="传统的数学公式表达仅仅适用于少部分体系"></a>传统的数学公式表达仅仅适用于少部分体系</h4>But the great historical successes of theoretical science have typically revolved around finding mathematical formulas that instead directly allow one to predict the outcome…And the principle of Computational Equivalence now implies that this will normally be possible only for rather special system with simple behavior.<h4 id="理论科学是否存在极限，极限在哪里？极限以外是否还是人能够理解的世界？"><a href="#理论科学是否存在极限，极限在哪里？极限以外是否还是人能够理解的世界？" class="headerlink" title="理论科学是否存在极限，极限在哪里？极限以外是否还是人能够理解的世界？"></a>理论科学是否存在极限，极限在哪里？极限以外是否还是人能够理解的世界？</h4>So this implies that there is in a sense a fundamental limitation to theoretical science.<br>But it also shows that there is something irreducible that can be achieved by the passage of time. And it leads to an explanation of how we as humans—even though we may follow definite underlying rules—can still in a meaningful way show free will.</li>
<li>想法：作者联系到的“自由意志”看似是无稽之谈，但是也有一定道理。用数学和理论描述世界的思想尽管是科学的主流。但是将这种方法论极致的推广导致的结果就是我们开始怀疑是否存在【自由意志】。</li>
<li>想法：是否可以存在一种理论工具预测元胞自动机的发展趋势<h4 id="人类没有什么特别的"><a href="#人类没有什么特别的" class="headerlink" title="人类没有什么特别的"></a>人类没有什么特别的</h4>One feature of many of the most important advances in science throughout history is that they show new ways in which we as humans are not special. And at some level the Principle of Computational Equivalence does this as well. For it implies that when it comes to computation—or intelligence—we are in the end no more sophisticated than all sorts of simple programs, and all sorts of systems in nature.</li>
</ul>
</blockquote>
<h3 id="与其他学科的联系"><a href="#与其他学科的联系" class="headerlink" title="与其他学科的联系"></a>与其他学科的联系</h3><h4 id="数学：作者认为元胞自动机是一种更广泛意义上的数学"><a href="#数学：作者认为元胞自动机是一种更广泛意义上的数学" class="headerlink" title="数学：作者认为元胞自动机是一种更广泛意义上的数学"></a>数学：作者认为元胞自动机是一种更广泛意义上的数学</h4><blockquote>
<p>And one of the consequences of this complexity is that it leads to fundamental limitations on the idea of proof that has been central to traditional mathematics…Yet what the discoveries in this book show is that this is largely just a reflection of how small the scope is of what is now considered mathematics. And indeed the core of this book can be viewed as introducing a major generalization of mathematics—with new ideas and methods, and vast new areas to be explored.</p>
<h4 id="物理"><a href="#物理" class="headerlink" title="物理"></a>物理</h4><p>The traditional mathematical approach to science has historically had its great success in physics—and by now it has become almost universally assumed that any serious physical theory must be based on mathematical equations. Yet with this approach there are still many common physical phenomena about which physics has had remarkably little to say. But with the approach of thinking in terms of simple programs that I develop in this book it finally seems possible to make some dramatic progress. And indeed in the course of the book we will see that some extremely simple programs seem able to capture the essential mechanisms for a great many physical phenomena that have previously seemed completely mysterious.</p>
<h5 id="传统物理多使用连续数值，微积分以及概率；元胞自动机本质是离散的；简单的规则组合形成了复杂的行为"><a href="#传统物理多使用连续数值，微积分以及概率；元胞自动机本质是离散的；简单的规则组合形成了复杂的行为" class="headerlink" title="传统物理多使用连续数值，微积分以及概率；元胞自动机本质是离散的；简单的规则组合形成了复杂的行为"></a>传统物理多使用连续数值，微积分以及概率；元胞自动机本质是离散的；简单的规则组合形成了复杂的行为</h5><h5 id="传统物理多是理想化的建立在数学上的关系；元胞自动机可以表达更复杂的关系"><a href="#传统物理多是理想化的建立在数学上的关系；元胞自动机可以表达更复杂的关系" class="headerlink" title="传统物理多是理想化的建立在数学上的关系；元胞自动机可以表达更复杂的关系"></a>传统物理多是理想化的建立在数学上的关系；元胞自动机可以表达更复杂的关系</h5><h4 id="生物：传统生物学细节了解的多，但是却缺乏统一的理论"><a href="#生物：传统生物学细节了解的多，但是却缺乏统一的理论" class="headerlink" title="生物：传统生物学细节了解的多，但是却缺乏统一的理论"></a>生物：传统生物学细节了解的多，但是却缺乏统一的理论</h4><p>Vast amounts are now known about the details of biological organisms, but very little in the way of general theory has ever emerged.<br>And part of the reason for this is that traditional mathematical models have never seemed to come even close to capturing the kind of complexity we see in biology. </p>
<h4 id="社会科学"><a href="#社会科学" class="headerlink" title="社会科学"></a>社会科学</h4><p>From economics to psychology there has been a widespread if controversial assumption—no doubt from the success of the physical sciences—that solid theories must always be formulated in terms of numbers, equations and traditional mathematics. </p>
<h4 id="计算机科学-从专家型的编程变为通用型-自组织的编程"><a href="#计算机科学-从专家型的编程变为通用型-自组织的编程" class="headerlink" title="计算机科学:从专家型的编程变为通用型+自组织的编程"></a>计算机科学:从专家型的编程变为通用型+自组织的编程</h4><ul>
<li>想法：例如机器学习、遗传算法等方法的发展代表了这种趋势<br>Throughout its brief history computer science has focused almost exclusively on studying specific computational systems set up to perform particular tasks. But one of the core ideas of this book is to consider the more general scientific question of what arbitrary computational systems do. <h4 id="哲学"><a href="#哲学" class="headerlink" title="哲学"></a>哲学</h4><h4 id="艺术"><a href="#艺术" class="headerlink" title="艺术"></a>艺术</h4><h4 id="技术：去中心化的控制，进化的功能实现"><a href="#技术：去中心化的控制，进化的功能实现" class="headerlink" title="技术：去中心化的控制，进化的功能实现"></a>技术：去中心化的控制，进化的功能实现</h4></li>
<li>Despite all its success, there is still much that goes on in nature that seems more complex and sophisticated than anything technology has ever been able to produce. But what the discoveries in this book now show is that by using the types of rules embodied in simple programs one can capture many of the essential mechanisms of nature. And from this it becomes possible to imagine a whole new kind of technology that in effect achieves the same sophistication as nature. <h3 id="相关领域"><a href="#相关领域" class="headerlink" title="相关领域"></a>相关领域</h3><h4 id="人工智能：遭遇瓶颈"><a href="#人工智能：遭遇瓶颈" class="headerlink" title="人工智能：遭遇瓶颈"></a>人工智能：遭遇瓶颈</h4>And in the 1960s the field of artificial intelligence grew up with the goal of understanding processes of human thinking and implementing them on computers. But doing this turned out to be much more difficult than expected, and after some spin-offs, little fundamental progress was made. At some level, however, the basic problem has always been to understand how the seemingly simple components in a brain can lead to all the complexities of thinking<h4 id="合成生命-Artificial-Life"><a href="#合成生命-Artificial-Life" class="headerlink" title="合成生命(Artificial Life)"></a>合成生命(Artificial Life)</h4>Most active from the mid-1980s to the mid-1990s, the field of artificial life concerned itself mainly with showing that computer programs could be made to emulate various features of biological systems. But normally it was assumed that the necessary programs would have to be quite complex. What the discoveries in this book show, however, is that in fact very simple programs can be sufficient.<h4 id="突变理论"><a href="#突变理论" class="headerlink" title="突变理论"></a>突变理论</h4>Traditional mathematical models are normally based on quantities that vary continuously. Yet in nature discrete changes are often seen. Popular in the 1970s, catastrophe theory was concerned with showing that even in traditional mathematical models, certain simple discrete changes could still occur. <h4 id="混沌理论"><a href="#混沌理论" class="headerlink" title="混沌理论"></a>混沌理论</h4>Indeed, all that it shows is that if there is complexity in the details of the initial conditions, then this complexity will eventually appear in the large-scale behavior of the system. But if the initial conditions are simple, then there is no reason for the behavior not to be correspondingly simple. What I show in this book, however, is that even when their initial conditions are very simple there are many systems that still produce highly complex behavior. And I argue that it is this phenomenon that is for example responsible for most of the obvious complexity we see in nature.<h4 id="复杂性理论"><a href="#复杂性理论" class="headerlink" title="复杂性理论"></a>复杂性理论</h4>One feature of the new kind of science that I describe in this book is that it finally makes possible the development of a basic understanding of the general phenomenon of complexity, and its origins.<h4 id="计算复杂度理论"><a href="#计算复杂度理论" class="headerlink" title="计算复杂度理论"></a>计算复杂度理论</h4>Developed mostly in the 1970s, computational complexity theory attempts to characterize how difficult certain computational tasks are to perform. Its concrete results have tended to be based on fairly specific programs with complicated structure yet rather simple behavior. The new kind of science in this book, however, explores much more general classes of programs—and in doing so begins to shed new light on various longstanding questions in computational complexity theory.<h4 id="控制论-Cybernetics"><a href="#控制论-Cybernetics" class="headerlink" title="控制论 (Cybernetics)"></a>控制论 (Cybernetics)</h4><h4 id="动力系统理论"><a href="#动力系统理论" class="headerlink" title="动力系统理论"></a>动力系统理论</h4>But what I argue in this book is that in fact the behavior of many systems is fundamentally too complex to be usefully captured in any such way.<h4 id="进化理论"><a href="#进化理论" class="headerlink" title="进化理论"></a>进化理论</h4>And indeed I will argue in this book that in many respects it(natural selection) tends to oppose complexity. But the discoveries in the book suggest a new and quite different mechanism that I believe is in fact responsible for most of the examples of great complexity that we see in biology.<h4 id="实验数学"><a href="#实验数学" class="headerlink" title="实验数学"></a>实验数学</h4><h4 id="分形"><a href="#分形" class="headerlink" title="分形"></a>分形</h4><h4 id="系统理论"><a href="#系统理论" class="headerlink" title="系统理论"></a>系统理论</h4><h4 id="纳米技术"><a href="#纳米技术" class="headerlink" title="纳米技术"></a>纳米技术</h4><h4 id="非线性动力学"><a href="#非线性动力学" class="headerlink" title="非线性动力学"></a>非线性动力学</h4><h4 id="科学计算"><a href="#科学计算" class="headerlink" title="科学计算"></a>科学计算</h4><h4 id="自组织"><a href="#自组织" class="headerlink" title="自组织"></a>自组织</h4><h4 id="统计力学"><a href="#统计力学" class="headerlink" title="统计力学"></a>统计力学</h4><h3 id="作者自传"><a href="#作者自传" class="headerlink" title="作者自传"></a>作者自传</h3>So I thought that perhaps I could do something similar in natural science: that there might be some appropriate primitives that I could find that would successfully capture a vast range of natural phenomena.<br>There were in many cases well-established mathematical models for the individual components of such systems. But two practical issues stood in the way of using these as a basis for simulations. First, the models were usually quite complicated, so that with realistic computer resources it was very difficult to include enough components for interesting phenomena to occur. And second, even if one did see such phenomena, it was almost impossible to tell whether in fact they were genuine consequences of the underlying models or were just the result of approximations made in implementing the models on a computer.<br>My early discoveries about the behavior of cellular automata stimulated a fair amount of activity in the scientific community. And by the mid-1980s, many applications had been found in physics, biology, computer science, mathematics and elsewhere. And indeed some of the phenomena I had discovered were starting to be used as the basis for a new area of research that I called complex systems theory.<br>The typical issue was that there was some core problem that traditional methods or intuition had never successfully been able to address—and which the field had somehow grown to avoid. Yet over and over again I was excited to find that with my new kind of science I could suddenly begin to make great progress—even on problems that in some cases had remained unanswered for centuries.</li>
</ul>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2017/12/30/生物化学方向数据分析与机器学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2017/12/30/生物化学方向数据分析与机器学习/" itemprop="url">生物化学方向数据分析与机器学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-30T13:00:00+08:00">
                2017-12-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/General-Science/" itemprop="url" rel="index">
                    <span itemprop="name">General Science</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这篇文章主要讲生物化学的基础研究和技术应用中产生的数据与机器学习的结合。实际上，在我看过的文献里面，这两者的结合早已有之，并不是什么新鲜的事情，至少20世纪90年代就有相关的工作，这也和人工智能等概念的几起几落相关。近年来，这种相互结合的趋势愈加明显，部分的原因可能也是机器学习和大数据等概念的兴起，但除此之外，生物化学的研究本身的趋势也愈加的需要这样的技术。</p>
<p>我们研究基础科学，涉及的主要认为有：客观的观测与描述，抽象模型和解释，预测以及干预。科学走到今天，不同的领域有不同的发展，基础物理和高能物理现在还在寻找一些方法间接的观测例如“暗物质”或者某种预言的粒子之类的东西，包括近来观测到的引力波等等，都是在寻找方法对系统进行观测。反过来，如有机合成等学科，已经建立了一套方法体系，控制有机反应，使得我们可以理性的设计合成路线，获得我们想要的产物，对有机产物结构的观测手段如质谱等，已经在过去多次获得诺贝尔奖。可见，【客观的观测与描述】一个体系这件事情，尽管是科学定量研究的第一步，但是仍然是非常重要且大有可为的一个领域。</p>
<p>在对生命科学体系以及化学体系的研究中，分析手段大部分就是做的客观的观测与描述的工作。这部分工作尽管已经取得了长足的进步，但是还有很多问题没有解决。如何从静态的观测走向动态的观测；在空间尺度和时间尺度上，如何尽可能准确的观测到尽可能微小的差异；如何观测和分析复杂的多组分相互作用的体系等等</p>
<p>我们客观的观测和描述研究的对象，基本的方法就是通过检测器检测信号，获取数据，我们认为，数据是脱离主观的，是对被观测食物的客观反映。然后再进一步的从数据中提取信息，进行分析和描述，最终获得对研究对象的理解和新的知识。因此，对于数据中包含的信息的提取，分析和描述是一道连接实验数据与我们最终目标——对体系的理解和获取新的知识的桥梁，不得不说是非常重要的。当我们研究的体系比较简单，数据量较少的时候，分析和描述也不复杂，因此，在过去的纯分析研究中，大量的精力集中在如何更好的获得数据上面；而分析的应用方面，则精力集中在如何从对体系的描述中发现新的知识，建立新的模型上面。比如说获得了诺贝尔奖的MALDI离子源，就是解决了质谱如何获取生物大分子质量数的问题。</p>
<p>但是，随着分析技术的进步，从观测数据到知识之间的桥梁变得不那么好走了。这主要是两个方面的原因造成的，一是随着分析方法和分析仪器的进步，单位时间获取的数据量大大增加了。过去我们拍摄一张荧光成像的图片，显示了被标记的物种在某个时刻在体系中的空间分布情况，我们是可以简单的对其进行分析的；但是现在，在笔者的实验中，拍摄的随时间变化的荧光时序图像，由于采用了高速的和高灵敏度的EMCCD，因此在一个下午的时间里，2~3份样品就将产生大约六万帧的图像，占用约50GB储存空间。在这样的情况下，完全无法通过传统的定性分析的方法人工的来全面的理解和描述获得的实验信息。第二个原因是我们研究的体系变得更加的复杂了，简单的体系中，我们关注的物质种类单一，且认为不同的物种之间是相互独立的，如果有相互作用，那么这种作用是线性的和决定性的，可以简单描述的。例如我们分析一份环境样本，想要获取其中几种农药含量，这样的体系就是简单的，因为每一种农药的情况都单一的对应一个质谱峰的强度；且不同的质谱峰之间互不干扰，这样的分析是经典的化学分析的内容。但是，当面对复杂的体系的时候，我们就没有办法如此直观的获得一一对应的相关性信息。譬如说，我们现在想要研究的是药物对细胞的刺激作用，当然，如果刺激的作用很强烈，那么就只有杀死细胞和细胞存活的差异。 但是，如果药物对细胞的状态产生了影响，但这种影响只是改变了细胞的生活方式，而并没有杀死细胞，这样的情况下问题就非常多了。如何观测细胞状态的变化？细胞的状态与那些可以被观测的量相关？如何定量的描述这种变化等等。研究体系的复杂化以及研究问题的精细化，导致我们很难再像以前一样直观的从数据中获得结论了，因此必须更好的利用“从数据中提取信息，进行描述和分析”这个桥梁的作用，帮助我们从复杂的自然想象中获取有益的信息。</p>
<p>那么如何更好的利用这个桥梁呢？或者说，如何从大量的，复杂的数据中，提取我们想要的信息，进行定量化的描述和分析呢？机器学习的方法无疑是很重要的方法（但不是唯一的方法）。</p>
<h3 id="机器学习中的基本概念"><a href="#机器学习中的基本概念" class="headerlink" title="机器学习中的基本概念"></a>机器学习中的基本概念</h3><h4 id="机器学习的任务"><a href="#机器学习的任务" class="headerlink" title="机器学习的任务"></a>机器学习的任务</h4><p>机器学习的任务，也就是大家使用机器学习的目的，大致上可以有 <strong>分类与预测</strong>，<strong>关联性分析</strong>等内容。<br><strong>分类与预测</strong>是机器学习最常见的用途。实际上，分析的目的常常与分类有关，有些是二分类问题：如一份河水样本是不是有机物超标？一个细胞是否是活细胞？一个生物样本是否是来自于猪的？这些都是传统的二分类问题。当我们的结论与信号之间的很强的关联性的时候，这个事情并不需要机器学习来做：河水中还原性物质给了高锰酸钾x个电子每毫升以上就是有机物超标；细胞质区域被不能跨膜的染料染上颜色就说明细胞已经死亡；DNA电泳中出现了特征的条带就说明样本来源是猪等等。但是，正如上面所说的，如果需要研究的问题更为深入和精细的时候，我们就很难将结论与直接观测的数据相联系了，比如，一个细胞是否是癌细胞？如果是，是哪一种癌细胞？一个细菌是否是耐药的？如果是，耐哪一种类型的药物？我们直接能够观测的量没有一个能想前面所说的那样给我们直接的结论，综合多个不同观测变量的结果，给出一个单一的分类标签的过程，就是机器学习中的分类。之所以成为机器学习，主要是因为我们在生活中大部分时间都会做这件事：比如我们第一次遇到一个人，我们的大脑就可以根据这个人的衣着，相貌，举止，语言等多个因素给出一个综合的评价——第一印象是好还是坏；这就是我们大脑作出的二分类问题。预测问题就是给定一个未知结果的观测结果，根据以前的学习结果，预测这个观测结果属于的类别。<br><strong>关联性分析</strong>则是为了回答这样的一个问题，一个观测的结果与众多的不同的观测值之间的关系是什么。尽管学习的方法可以对数百上千的观测值进行综合给出一个单一的结果，但是我们人类还是希望知道，这个结果主要是由哪些因素影响的。这与后面的解释，建模以及预测直接相关。因此也是科学领域内非常重要的一步。</p>
<h4 id="样本，特征与分类器"><a href="#样本，特征与分类器" class="headerlink" title="样本，特征与分类器"></a>样本，特征与分类器</h4><p>机器学习中一个观测的对象称为一个样本，每个观测的指标称为一个特征，对观测结果进行综合和预测的一组参数成为模型或者分类器。 上面的概念非常抽象，我们可以举一个很简单的例子来说明。譬如我们给实验室采购电脑，需要选择买哪些电脑来给大家来用。买电脑这种事情还是有点复杂的，对于每一个品牌和型号的电脑，实际上就是我们观测的一个对象，也就是一个样本。 我们观测的指标很简单，一个是CPU的计算能力，可以用benchmark来量化表示；另一个就是电脑的价格，可以用人民币为单位进行表示。这里的CPU benchmark和价格就是我们观测的两个特征。对于每一个样本（电脑型号），都可以获得这两个特征。分类器的作用就是根据这两个特征来作出决策，买还是不买这个品牌的电脑。<br>那么怎么理解分类器就是一组参数呢？因为机器学习需要处理的问题来自各个不同的领域，永远也无法穷举出来每个领域的专家模型（也就是对这个领域有深厚了解的专家的决策规则）。因此机器学习算法仅仅是一系列抽象的计算方法，而面对不同领域和不同的数据集的时候，同样的一个算法实际上还是同样设定好的分析规则。所不同的是执行这个规则的参数不同。什么样的参数最适合做一个特定领域的分析和预测呢？这个就是通过这个领域的历史数据来进行学习的<br>还回到买电脑的故事里面。我们怎么知道什么样的电脑才适合实验室买呢？我们可以找出来过去实验室买电脑的记录，其中已经购买的电脑的CPU benchmark以及当时的价格我们都是可以获得的；同时我们也可以看看当时考虑了但是没有买的电脑的相关特征。我们知道过去的决策中关注的样本，特征与最终结果，就可以训练一个分类器来帮我们预测当前的那些电脑型号适合实验室购买。<br>刚才我们说，一个机器学习算法就是一个通用的计算规则。比如我们这里找到了一个简单的算法，那就是价格在某个区间中的时候，CPU benchmark达到一定数值，就会被购买。这个规则就是一个简单的机器学习模型。那么价格具体要在哪个范围呢？CPU benchmark要高过哪个阈值才会购买呢？这些参数与就是需要通过从历史数据中计算确定得到的。这些参数算出来以后，这个规则和参数就形成了一个分类器，帮助我们确定一个新的品牌的电脑是否值得购买。<br>那么上述的机器学习算法的抽象就是这样的一组规则：特征1（例子中为价格）需要同时满足大于参数$\alpha$，小于参数$\beta$，以及特征2需要大于参数$\gamma$的情况下，就输出结果1，否则输出结果2. 一个具体应用的模型就是由一组具体($\alpha_0$, $\beta_0$, $\gamma_0$)确定的规则。</p>
<h4 id="有监督的学习和无监督的学习"><a href="#有监督的学习和无监督的学习" class="headerlink" title="有监督的学习和无监督的学习"></a>有监督的学习和无监督的学习</h4><p>上面描述的例子中，学习是通过历史决策数据完成的。这样的机器学习算法成为有监督的机器学习算法。也就是说过去的决策数据作为真实值，指导了算法的优化和评价过程。但是，实际工作中，历史决策数据可能是很难获取到的。更重要的是，有监督的情况是建立在我们对需要做的事情非常清楚的情况下。但是，在研究中我们有的时候希望从大量的数据中看到差异性，再从差异性入手挖掘新的未知的知识，这个时候，无监督的学习方法也就变得很重要了。<br>还是上面的买电脑的例子。假如现在实验室刚刚建立，还没有过去买电脑的历史。于是导师跟你说，你调研总结一下市场上在售的电脑都有哪些不同的类型，我们选一个类型来买。这个需求中提到的【调研总结一下市场上在售的电脑都有哪些不同的类型】就是一个非常不明确的需求，我们作为非计算机销售的专家，并不知道在售有哪几种类型的电脑；也不知道每一种类型的电脑都是什么样子的。但是，我们可以使用无监督的学习方法，从在售电脑数据中学习到这些东西。<br>无监督学习的主要应用就是聚类。所谓聚类就是对于一个有大量不同样本的数据集，根据样本之间的相似度，将彼此相似的样本聚为一类；彼此不同的样本分开为不同的类。最终给出的结果就是每一个样本属于的类别。我们再观察每一个类别的平均状况，就可以知道大概每一个类别都是什么情况。无监督学习判断两个样本的差异性就是通过他们的特征值计算得到的。不同的相似度计算方法成为不同的【度量】。度量选择的不同也会导致分类结果的不同，这是因为无监督学习既然是【无监督】的，它其实不懂对错，只是完美的根据【相似的在一起；不同的不在一起】的规则去工作，至于最后的结果是否有意义，就让人来决定吧。举一个例子，现在我们有一群人要进行分类；如果选择【性别】作为度量，那么就会分成【男人】和【女人】两类。如果根据年龄来作为度量，分类的结果就是老年和少年。无监督的学习方法没有变，规则也没有变，但是分类的结果变了，这是度量发生改变的结果。<br>回到原来的例子，使用无监督的学习方法，我们将收集来的市场上在售的电脑分成了四类。我们观察每一类的平均情况，发现有一类是价格高，CPU benchmark低的电脑，原来是商务笔记本；有一类价格高，benchmark也高的，原来是游戏本；有一类价格低，benchmark也低的，原来是低端本；还有一类价格低但是benchmark高的，原来是二手本。</p>
<h4 id="机器学习与物理模型"><a href="#机器学习与物理模型" class="headerlink" title="机器学习与物理模型"></a>机器学习与物理模型</h4><p>上面谈到，机器学习的方法是普适性的，而非是领域相关的专家知识的集合。相反的，物理模型则完全是通过领域内专家通过专业知识推导得到的结果。我们说机器学习这个东西并不新鲜，在过去已经经历多次起落。当它衰落的时候，也就是对应的专家模型应用广泛的时候。因此，这两种东西实际上是相互竞争又相互启发的。 机器学习在过去衰落的原因主要是计算能力不够，数据量不够或者算法不好导致的应用效果差。对于科学研究上来说，机器学习还有一个先天的劣势，就是即时机器学习给出了很好的预测或者聚类结果，我们却无法从科学本质上的了解其中的因果关系。尽管通过关联分析和重要特征的提取可以改善这一问题（因为特征一般是有具体意义的观测值），但仍然不如物理模型来的直接和易于解释。机器学习也因为其黑匣子的特征，大部分的应用于商业。对于科学研究来说，黑匣子是不够的。<br>但是我们上面说，机器学习与物理模型也有相辅相成的关系。这也是当前科学研究中的新型热点。物理模型的建立过程中天然的带有人对于体系本身的规则的假设，也就是模型的预设条件。但是，对于上面说的复杂的多因素相互作用的系统，尤其是缺乏先验知识的未被探索的科学领域，建立的模型常常是不完整的，有偏差的甚至是错误的。当下甚至更有激进的观点认为，因果关系的科学主要是建立在牛顿力学的观念上的近现代科学研究体系。在面对复杂的，相互作用相互关联的系统是，因果关系可能是没有意义的。比如说，你说我是因为胖才不爱运动的呢？还是因为不爱运动才变胖的呢？这两个系统变量的变化是相互关联相互反馈的，因此因果之说就变得缥缈。遗憾的是，这样的系统在生物学，社会学等等重要领域都是广泛存在的，以至于让我们认为开始觉得过去研究的简单的相互独立的体系才是复杂的相互关联的体系的海洋中的孤岛。因此，这对我们是挑战也是机遇。<br>物理模型与机器学习的关系也是相辅相成的。我们谈到机器学习中需要对样本进行定量的描述，形成样本的特征，这个特征怎么来的呢？很大一部分就是通过物理模型计算出来的。比如在我的研究中，对于单个粒子在一段时间的运动行为，有一个重要的描述特征就是在这个区间的局部扩散系数。扩散系数是怎么计算的呢？就是基于爱因斯坦的自由扩散物理模型计算的。<br>爱因斯坦的自由扩散模型中的假设是粒子运动在均一稳定的粘性溶液中；因此粒子在扩散过程中，只要统计的量足够完备，应该扩散系数是处处相同的，运动行为的概率统计也应该是相同的。但是在观测实际的体系中，我们发现很多与生物复杂粘弹性的细胞质作用的粒子，表现出与空间和时间相关的运动行为，通过机器学习的方法，我们可以得到不同运动行为的时间和空间的分布。这样的结果反过来又可以刺激新的物理模型的产生。因为机器学习的方法，尤其是无监督的方法，并没有带入先验的人为假设，因此更适用于新知识的发现。数据驱动的知识挖掘也是非常热的商业和科学课题。</p>
<h3 id="生物化学基础研究，应用与机器学习"><a href="#生物化学基础研究，应用与机器学习" class="headerlink" title="生物化学基础研究，应用与机器学习"></a>生物化学基础研究，应用与机器学习</h3><p>前面谈了很多虚的东西，这里进入主题。生物化学的研究范围非常广阔，涉及的话题又纷繁复杂，并不是我这一篇文章能够说清楚的事情。 这里仅仅是从分析化学的角度谈其中很小的一部分。分析化学在生物化学上的研究和应用就是文章开头谈到的对观测体系进行定量的观测和描述。 过去，分析化学大量的研究了简单的，线性的体系，上面提到的如农药检测等就是经典的简单线性系统。 在研究这类系统的时候，最重要的问题是提高检测的范围，精确性和最低检出量。但是随着科学的进步，人们越来越多的关注到了复杂的非线性的系统。尽管这类系统实在是很多，但是真正能够确定性的，可重复性的研究的体系，还是一些生物体系。这是因为，如细胞，生物个体等研究体系可以通过标准化的培养发育大量的可重复的提供实验材料。更多的社会学，生态学和天文学问题，研究体系的时间尺度远远大于生物学实验，因此数据的积累和实验重复性，对照实验的设计等方面都会有所限制。更重要的是，对生物体系的了解直接关系人类永恒的需求——健康，因此生物学的研究如此火热也不难理解。<br>分析化学在生物学当中的应用非常广泛，可以说，分析手段是绝大多数生物学实验的基础。分析化学手段为生物学的研究提供了定量的基础。在研究参照之间存在单一的，显著性差异的时候，定性分析仍然适用（如跑胶看条带的深浅）；在研究参照之间存在单一的，但是仅仅是统计学意义上的显著差异时，定量分析为统计学计算提供了支持；在研究参照之间存在多变量的复杂的相互关系的时候，更多的计算方法就需要运用进去，将数据中的差异提取出来。 机器学习的方法无疑是一种重要的分析手段；其他的，建立在物理模型和假设上的特殊领域算法，时序分析等等也包括在内。<br>前面说了，既然使用数据分析方法的数据本身对于人的定性直觉来讲，太过复杂，那么就会遇到一个直接的问题，就是当分析结果与预期差距很大的时候，或者说结果“不好”的时候，我们如何确定是数据上的问题，还是计算方法上的问题？<br>最常用的方法是使用模拟数据来对算法进行评估。模拟数据的好处是我们本身对模拟所用的数学模型，条件以及基本参数非常了解，这些模拟的基本参数可以当做真实值来与算法的结果作对照，从而评估算法的准确性以及误差范围。如果通过这样的方式确定下来算法是准确的，那么当分析结果与预期有差异的时候，算法的因素就被排除了。<br>除了算法本身正确性的问题以外，还有一个重要的方面是算法本身是否能够揭示你需要的信息。这一点上，需要研究人员至少要对所使用的算法有基本性的了解，否则的话就是胡乱尝试，出了问题也无从下手改进。不同的算法所着重的点是不同的，好比我们看待一样事物有不同的角度一样。如果想要知道苹果的好坏，“尝一口”这个算法将得到口味的结果，对于区别好坏苹果很有帮助；反过来【称重】这个算法只能得到质量数据，很可能发现好苹果和坏苹果没有什么差异。在机器学习在生物化学的领域应用中，在特征的提取上以及算法的选用上，研究人员需要考虑数据的天然属性，机器学习算法的特性以及处理的目标，综合的选择合适的算法。当然，上述的要求实际上是比较高的，通常情况下我们可以先尝试文献中已经报道的方法或者实验室已有的成熟的方法入手。但是归根结底最重要的是，不能期望一劳永逸的用一套算法处理所有的数据且能获得预期的成果；也不建议计算结果不理想就直接重新做实验。还是要将实验数据和算法结果相互不断比对和印证，逐步有针对性的获得理想的结果。</p>
<h3 id="常见的数据种类与学习方法"><a href="#常见的数据种类与学习方法" class="headerlink" title="常见的数据种类与学习方法"></a>常见的数据种类与学习方法</h3><p>分析化学实验常用的数据类型有图像数据和谱图数据，在此处分开来讲。<br>图像数据的来源有显微成像和质谱成像。总体而言，图像数据表现的是物质在空间上的分布信息。图像数据中一个像素点对应一个空间位置，这个像素点的值对应这个位置的信号强度，图像数据本质上就是按照空间位置对应的一个数值矩阵。图像数据的处理非常之多，最为常见的是提高图像质量的降噪，滤波，调节对比度，边缘增强等等；还有识别目标的需求，如特殊物体的自动识别;也有数值分析的需求，如分析某个区域的强度均值等。<br>科学研究中的图像数据通常有TIF格式，TIF格式全称(Tag Image File Format), 是具有标签的无压缩的数据文件格式。其中的标签既可以描述图像本身的信息，也可以描述获取数据的仪器，软件等信息。TIF格式的无压缩特性使得它适合作为科学图像数据格式。计算机在保存图片的时候常常需要将像素的值归一化到一个范围区间内，如8 bit的TIF文件每一个像素的数值就是0~255。对于科学数据来说，并不一定原始信号就与TIF格式的要求相同，在这种情况下，会使用线性变幻将原始数据变换到需要的数值区域，这个过程中可能造成信息的损失。<br>另一个更为麻烦的数据格式是Text Image，如名称所示，这种格式中所有像素的值是按照一定的顺序写在一个txt文档中的，因此是没有信号值域的范围的，因此最大的保留的原始数据。但是这种数据在读取和保存的时候，涉及到数值与字符的相互转换以及显示的时候的数值变换，因此读取和保存的速度较慢。对于看重图像不同区域之间的强度比率的情况，适合使用TIF保存数据；对于看重具体信号强度的情况，适合保存为text image的形式。<br>PNG格式是常见的压缩格式，但是质量也是比较好的，因此与TIF格式一样适合作为发表文章时用的数据格式。<br>向量图通常是软件输出或者人工制作的用于发表文献用的展示用格式，非常重要，但是与数据处理无关，在此就不多说了。<br>说完图像数据常见的类型，那么对于图像数据常见的处理都有哪些呢？前面提到，图像数据的本质上是一个数值矩阵。空间信号处理的方式如二维傅里叶变换等处理方式广泛的应用于图像的信号处理（SIM），降噪等方面。目标识别目前有两种路径。简单的目标识别（如单个圆形颗粒等）可以使用数值方法如最大值寻找，边缘扩展等等方法。复杂的目标识别通常是计算机领域的工作，目前流行使用神经网络的方法。图像数据也可以作为机器学习的样本。最为简单的特征提取方式就是认为每一个像素点就是一个特征，像素点的数值就是特征的值。这样，一张100像素x100像素的图像作为一个样本，就有一万个不同的特征。特征还需要对齐，也就是在相同位置的特征需要表达相同的物理意义。前面提到机器学习中非常重要的相似度计算，就是分别计算对应位置的特征值差异获得的；因此如果物理意义都不想同，计算就没有意义了。<br>除了图像数据，最为常见还有谱图数据。谱图数据与图像数据类似，表达的是信号在不同波谱频域中的强度分布。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2017/12/03/Fun-with-your-first-Day-with-Matlab-S01E04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2017/12/03/Fun-with-your-first-Day-with-Matlab-S01E04/" itemprop="url">Fun with your first daty with Matlab S01E04</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-03T19:51:00+08:00">
                2017-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/MATLAB/" itemprop="url" rel="index">
                    <span itemprop="name">MATLAB</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h3 id="脚本的执行顺序控制"><a href="#脚本的执行顺序控制" class="headerlink" title="脚本的执行顺序控制"></a>脚本的执行顺序控制</h3><h4 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h4><h4 id="if-else-判断语句"><a href="#if-else-判断语句" class="headerlink" title="if-else 判断语句"></a>if-else 判断语句</h4><h4 id="switch-case分支语句"><a href="#switch-case分支语句" class="headerlink" title="switch-case分支语句"></a>switch-case分支语句</h4><h4 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h4><h4 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h4><h3 id="MATLAB中的函数"><a href="#MATLAB中的函数" class="headerlink" title="MATLAB中的函数"></a>MATLAB中的函数</h3><h4 id="创建函数文件"><a href="#创建函数文件" class="headerlink" title="创建函数文件"></a>创建函数文件</h4><h4 id="编写第一个函数"><a href="#编写第一个函数" class="headerlink" title="编写第一个函数"></a>编写第一个函数</h4><h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h4><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><h4 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h4><h4 id="公有与私有权限"><a href="#公有与私有权限" class="headerlink" title="公有与私有权限"></a>公有与私有权限</h4><h4 id="函数句柄"><a href="#函数句柄" class="headerlink" title="函数句柄"></a>函数句柄</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2017/11/22/复杂性思考/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2017/11/22/复杂性思考/" itemprop="url">Ideas of Complexity</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-22T20:55:35+08:00">
                2017-11-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/General-Science/" itemprop="url" rel="index">
                    <span itemprop="name">General Science</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="How-to-define-Complexity"><a href="#How-to-define-Complexity" class="headerlink" title="How to define Complexity?"></a>How to define Complexity?</h3><p>We may be sure of that static system can not produce complexity as complexity is emergenced from dynamics. While complexity system such as social behavior or genes expression usually can be modeled as network with many agents, I ask a question that can single series produce complexity?</p>
<p>To answer the question, we may begin with organized series such as const series$X_t = Const$ or series follows certain time related rule$X_t=A<em>sin(t)$. We may define these series as <strong>simple series</strong> instead of <strong>complex series</strong> for the rule is simple and easy to be found.Another side of the issue is that totally random series, we define this case as <em>*simple series</em></em> too for there is no rules to be found.</p>
<p>However, a subtle case is that the series is historical related, such as $X<em>t=f(X</em>{t-1},X<em>{t-2},…,X</em>{t-n})$, can we now define the series as <strong>complex series</strong>? The answer is yes and no. An important issue is that how complex the function $f(·)$(We then term the function as <strong>history function</strong>) is. For an example:<br>$$X_t = X_t + 1$$<br>In this case, we definitely define the series as simple. so why our definition change as the function become <strong>complex</strong>? The answer may be that we should introduce nonlinearity in our history function.</p>
<p>可以确定的是静态是无法产生复杂的，复杂是在动态中表现的行为。单个序列是否能够产生复杂的现象呢？当一个序列是有序的（如常量序列$X_t = Const$或者符合某个周期函数的序列$X_t=A<em>sin(t)$）或者是完全随机的，我们都可以认为这样的序列是简单的。同样的，简单的机制相互线性叠加产生的序列，如$X_t=A</em>sin(t)+random+Const$我们仍然认为是简单序列。但是如果一个序列是历史相关的，如$X<em>t=f(X</em>{t-1})$，我们是否应该认为这样的序列是复杂序列呢？</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2017/11/15/Fun-with-your-first-Day-with-Matlab-S01E03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2017/11/15/Fun-with-your-first-Day-with-Matlab-S01E03/" itemprop="url">Fun with your first daty with Matlab S01E03</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-15T15:02:35+08:00">
                2017-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/MATLAB/" itemprop="url" rel="index">
                    <span itemprop="name">MATLAB</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>上一回我们讲述了MATLAB中最为重要的数据结构——数组的使用方法。这一次我们在讲述两个常用的数据结构，元胞和结构体。在实际使用的过程中，需要根据不同数据结构的特点以及需要完成的任务综合考虑需要什么样的数据结构。</p>
<h3 id="元胞"><a href="#元胞" class="headerlink" title="元胞"></a>元胞</h3><p>数组有一个特点，就是每一个元素储存的东西都必须是同类型的数据。如果想要存储不同类型的数据怎么办？这个时候就需要使用元胞了。</p>
<h4 id="创建元胞"><a href="#创建元胞" class="headerlink" title="创建元胞"></a>创建元胞</h4><p>元胞的创建是使用cell函数的：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = cell(<span class="number">3</span>,<span class="number">5</span>); <span class="comment">%创建3行5列的元胞</span></div></pre></td></tr></table></figure></p>
<p>这样就创建了一个元胞。除此之外，还可以直接创建元胞：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;;</div></pre></td></tr></table></figure></p>
<p>上面创建的元胞中包含3个字符。元胞还可以包含不同类型的数据：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b = &#123;<span class="string">'a'</span>,<span class="number">3</span>,<span class="string">'cdx'</span>&#125;;</div></pre></td></tr></table></figure></p>
<p>上面的元胞依次包含字符，数字以及字符串。<br>实际应用中，直接创建的可能性较少，大部分情况下都是先用cell函数创建空元胞，再使用索引将元胞的元素赋值为需要存储的变量。实际上，元胞和向量大部分情况下在MATLAB中都充当了数据的集合的作用。元胞和数组在使用的时候，需要占用内存空间，通常情况下，我们如果可以预先知道需要使用的元胞和数组的大小维度，就可以使用函数先声明相应大小的元胞或者数组，再将其中的元素赋值为我们需要的变量。如果需要扩大元胞或者数组的大小，这是非常耗时的一个操作。因为在这个操作中，实际上发生的是：声明一个新大小的元胞或者数组$\rightarrow$将原来的数据搬运到新声明的空间中$\rightarrow$销毁原来的元胞或者数组，释放空间</p>
<p>想想也觉得很麻烦吧！</p>
<h4 id="元胞元素操作"><a href="#元胞元素操作" class="headerlink" title="元胞元素操作"></a>元胞元素操作</h4><p>获取元胞的单个元素可以使用大括号操作，修改值也是这样<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">12</span>&#125;;</div><div class="line">a&#123;<span class="number">1</span>&#125;</div><div class="line"><span class="built_in">ans</span> = <span class="number">2</span></div><div class="line">a&#123;<span class="number">1</span>&#125; = <span class="string">'s'</span></div><div class="line"><span class="built_in">ans</span> = &#123;<span class="string">'s'</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">12</span>&#125;</div></pre></td></tr></table></figure></p>
<p>如果要对元胞进行切片，切片是指从数据的集合中获取一个子集。元胞的切片也是使用圆括号的<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">12</span>&#125;;</div><div class="line">b = a([<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>])</div><div class="line">b = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>&#125;</div></pre></td></tr></table></figure></p>
<p>要想同时改变元胞中的多个元素的值也是使用圆括号，赋值的项需要是元胞<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">12</span>&#125;;</div><div class="line">a([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) = &#123;inf&#125; <span class="comment">%广播赋值</span></div><div class="line">a = &#123;inf,inf,inf,<span class="number">11</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">12</span>&#125;</div><div class="line">a([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) = &#123;<span class="string">'s'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>&#125; <span class="comment">%按元素赋值</span></div><div class="line">a = &#123;<span class="string">'s'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">12</span>&#125;</div></pre></td></tr></table></figure></p>
<p>如果想要删除元素，直接使用圆括号和空集就可以<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">12</span>&#125;;</div><div class="line">a([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) = &#123;[]&#125; <span class="comment">%赋值为空集</span></div><div class="line">a = &#123;[],[],[],<span class="number">11</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">12</span>&#125;;</div><div class="line">a([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) = [] <span class="comment">%删除</span></div><div class="line">a = &#123;<span class="number">11</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">12</span>&#125;;</div></pre></td></tr></table></figure></p>
<p>上面的运算也都可以使用上一次讲的逻辑索引</p>
<h4 id="元胞与数组的转换"><a href="#元胞与数组的转换" class="headerlink" title="元胞与数组的转换"></a>元胞与数组的转换</h4><p>有的时候需要将元胞和数组相互转换。当一个元胞是全部由同种类型的数据组成的时候，就可以转换为数组。<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</div><div class="line">b = cell2mat(a)</div><div class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</div></pre></td></tr></table></figure></p>
<p>这样做有什么样的好处呢？前面我们说过，当使用数据集合的时候，最好能够提前知道需要的容量大小，然后再通过索引存入到数据集合中，当有些情况下，我们没有办法提前知道需要的容量，这个时候可能可以使用元胞优化。例如下面的程序，someFunc是一个返回任意长度的<strong>行</strong>向量的函数，我们需要调用它两次，将两次的结果放在同一个向量中，并求取平均值：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">%需要在运行中扩展向量大小的方法</span></div><div class="line">a = [];</div><div class="line">a = [a,someFunc()]; <span class="comment">%扩展大小，重新申请空间</span></div><div class="line">a = [a,someFunc()]; <span class="comment">%扩展大小，重新申请空间</span></div><div class="line">res = mean(a)</div><div class="line"></div><div class="line"><span class="comment">%不需要重新申请空间</span></div><div class="line">a = cell(<span class="number">2</span>,<span class="number">1</span>); <span class="comment">%两行一列的元胞</span></div><div class="line">a&#123;<span class="number">1</span>&#125; = someFunc();</div><div class="line">a&#123;<span class="number">2</span>&#125; = someFunc();</div><div class="line">a = cell2mat(a)；</div><div class="line">res = mean(a);</div></pre></td></tr></table></figure></p>
<p>反过来，也可以用mat2cell来将向量转换为元胞</p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>除了元胞，还有一个常用的保存不同类型数据的容器成为结构体（struct)。与前面讲的元胞和向量不同，结构体中存取数据是通过变量名称的，而前者实际上是使用数据所在位置的下标的。通过变量名称存取数据的好处是可以让程序更加容易阅读，毕竟变量名往往都是使用人类容易理解和符号表示的；但是使用下标容易大批量的存储，修改以及取出。因此，结构体往往用来存储性质不同但聚合程度很高的数据。什么意思呢？譬如我们可以使用元胞存储长度不一的字符串，他们性质不同（长度不同)，同时聚合度不高，也就是说相互之间没有关系。但是，同样的，如果我们需要储存几个长度不同的字符串，分别为一个对象的名称，描述，型号和价格，这些数据相互之间性质不同，但在意义上有很强的关联性，因为它们同样属于一个对象的性质，这个时候就非常适合使用结构体了。</p>
<h4 id="使用结构体"><a href="#使用结构体" class="headerlink" title="使用结构体"></a>使用结构体</h4><p>创建结构体使用struct函数，我们这里假设创建一个游戏中的角色，大天使bigAngel哈哈哈<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">bigAngel = struct() <span class="comment">%创建结构体</span></div><div class="line">bigAngel.HP = <span class="number">1000</span>; <span class="comment">%血量1k</span></div><div class="line">bigAngel.MP = <span class="number">2000</span>; <span class="comment">%魔法2k</span></div><div class="line">bigAngel.name = <span class="string">'Big Angel'</span> <span class="comment">%游戏名称</span></div><div class="line">bigAngel.skill = <span class="string">'Healing'</span> <span class="comment">%技能是治愈</span></div></pre></td></tr></table></figure></p>
<p>在结构体中，使用<strong>结构体名称.数据名称</strong>的方式来存取数据，这样的方式使得代码的可读性非常高，表达的意思的<strong>结构体XX的属性XXX</strong>的含义<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">bigAngel.HP <span class="comment">%查看bigAngel中HP的属性</span></div><div class="line"><span class="built_in">ans</span> = <span class="number">1000</span></div><div class="line">bigAngel.HP = <span class="number">2000</span></div><div class="line">bigAngel.HP <span class="comment">%给bigAngel中的HP属性赋值</span></div><div class="line"><span class="built_in">ans</span> = <span class="number">2000</span></div></pre></td></tr></table></figure></p>
<p>在像C++，C#这样的语言中，一个结构体中包含哪些属性，属性类型和名称名称是什么，都是提前设定好的，在使用过程中不能更改。但是在MATLAB，Python这样的动态语言中，像上面的例子一样，我们在定义结构体时，只需要使用struct函数，而给属性赋值的时候，如果这个属性以前定义过，就更更新属性值，如果从来没有定义过，就新建一个相应属性名称的属性，将值赋给新建的属性。这样的方式非常灵活，但有时候也会出现bug，例如上述的bigAngel的例子<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bigAngel.skil = <span class="string">'Purify'</span> <span class="comment">%本意是更改skill属性，但是打错为skil</span></div><div class="line">bigAngel.skill</div><div class="line"><span class="built_in">ans</span> = <span class="string">'Healing'</span> <span class="comment">%导致属性skill并没有如预期改变</span></div></pre></td></tr></table></figure></p>
<h4 id="结构体相关函数"><a href="#结构体相关函数" class="headerlink" title="结构体相关函数"></a>结构体相关函数</h4><p>结构体有很多相关的常用函数：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = isstruct(b) <span class="comment">%判断b是否为一个结构体</span></div><div class="line">a = isfield(b,C) <span class="comment">%判断某个字符串是否为结构体b的属性，C可以是单个字符串，也可以是一个由字符串构成的元胞</span></div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2017/05/26/科学范式与数据科学/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2017/05/26/科学范式与数据科学/" itemprop="url">科学范式与数据科学</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-26T22:56:07+08:00">
                2017-05-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/General-Science/" itemprop="url" rel="index">
                    <span itemprop="name">General Science</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>清华大学大数据分析（B）朱文武</p>
<h3 id="科学"><a href="#科学" class="headerlink" title="科学"></a>科学</h3><p>对自然的观察？ 肉眼观察 -&gt; 仪器观察 -&gt; 数据观察（大量仪器）<br>归纳与推理     哲学归纳 -&gt; 数学与物理归纳 -&gt; 建模归纳<br>应用与推广<br>因果关系——关联关系     </p>
<ul>
<li>start from model to data improvement</li>
<li>start from data to model implementation<br>#### </li>
<li>数据驱动/数据决策（data-driven)</li>
<li>模型驱动/经验决策 (model-driven)<h3 id="实验科学（古希腊时代）"><a href="#实验科学（古希腊时代）" class="headerlink" title="实验科学（古希腊时代）"></a>实验科学（古希腊时代）</h3>观察与实验<h3 id="理论科学（西方近代）"><a href="#理论科学（西方近代）" class="headerlink" title="理论科学（西方近代）"></a>理论科学（西方近代）</h3>物理模型<h3 id="计算科学（现代）"><a href="#计算科学（现代）" class="headerlink" title="计算科学（现代）"></a>计算科学（现代）</h3>数学模型构建——定量分析——仿真模拟<h3 id="数据科学？"><a href="#数据科学？" class="headerlink" title="数据科学？"></a>数据科学？</h3>理论+实验+计算？<h3 id="computational-thinking"><a href="#computational-thinking" class="headerlink" title="computational thinking"></a>computational thinking</h3></li>
<li>data -&gt; knowledge -&gt; intelligence -&gt; decision<br>37度    人体正常温度36度~37度    不算发烧    不用去医院</li>
<li>数据如何变成知识？ 数据的可解释性（find-defined)</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2017/05/26/科学与复杂性-Science-and-Complexity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2017/05/26/科学与复杂性-Science-and-Complexity/" itemprop="url">科学与复杂性(Science and Complexity)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-26T22:56:07+08:00">
                2017-05-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/General-Science/" itemprop="url" rel="index">
                    <span itemprop="name">General Science</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Translated from: Warren Weaver, Science and Complexity, American Scientist, 1948</p>
<p>科学在过去已经获得了大量的研究成果，并且影响着人们的生活。其中一些只是在琐碎的事情上提供了方便，但是更多的科学成果构建了我们今天（1948年）的现代社会，还有一些，尤其是那些与生物医药相关的成果，无可置疑的提高了我们的生活质量；更有一些结论深刻的改变了我们看待事物的思想。<br>我们应该如何看待科学在未来人类发展中的作用？科学到底是什么，或者同等重要的，不是什么？当然，我们可以从哲学的角度讨论这个问题，在某种意义上，这样的讨论也是非常重要和必要的，不过我们现在用一种更直接的方法来讨论。就像某些政客说的那样，让我们来看看（科学发展的）历程。我们将会忽略非常早期的一些探索故事，从三个半世纪以前开始，忽视一些细节，来考察科学发展过程中的主导的趋势。让我们从物理学开始，到后面在谈到生物学。</p>
<h4 id="朴素问题（Problem-of-Simplicity"><a href="#朴素问题（Problem-of-Simplicity" class="headerlink" title="朴素问题（Problem of Simplicity)"></a>朴素问题（Problem of Simplicity)</h4><p>大致来说，17世纪到19世纪这段时期物理学开始使用“变量”的概念，并且由此发展出了电话，无线电，汽车，飞机，照相以及电影等技术。<br>于此同时在生物学和医药学上面的进展也是令人印象深刻的。然而，有关生命活动的问题很少想物理学中的问题一样，仅仅涉及一到两个变量和一系列假定的常数。有机体更多的情况下包含了数十个同时变化的量，并且这些变量相互之间有微妙的联系。通常在生物学的研究中，很多重要的变量并没有被定量的测定，而是使用了定性的说明和度量，因此，直到1900年左右，生命科学的研究仍然停留在科学研究的初步阶段——包括采集，描述，分类以及对于显著存在的相关性的观察和描述。这些只是定量的理论发展之初的勇敢尝试，甚至很少讨论产生生物现象的物理化学机理。<br>总体来说，20世纪前的物理学大部分只是涉及到一两个变量作用和变化的朴素问题。同时，朴素问题极少适用的生命科学还尚未被定量的分析。</p>
<h4 id="混乱复杂问题"><a href="#混乱复杂问题" class="headerlink" title="混乱复杂问题"></a>混乱复杂问题</h4><p>如果有人把Josiah Willard Gibbs作为研究混乱复杂问题的英雄先驱的话，比1900年更早一些，他已经开始对自然中一种全新的体系发起了进攻。相比于之前对于几个变量的体系的研究，Gibbs富有创造性的研究了自然的另一个极端，并说：“让我的发展一套研究二十亿个变量的分析方法吧！”。也就是说，物理学家，通常以数学家为先锋，开始发展了一套基于概率统计的处理混乱复杂体系的工具。<br>什么是混乱复杂问题呢？想象这样一幅物理图景来感觉一下这样的体系。经典的19世纪动力学擅长于研究和描述一个象牙球在台球桌上的运动。实际上，象牙球在台球桌上的运动位置与时间的关系是非常经典的朴素问题研究体系。人们可以研究更多的象牙球在桌上共同运动的情形，不过随着球的数量的增多，问题的复杂度也在极具的上升。事实上，确实有人研究过标准台球比赛中象牙球的运动行为，尽管在理论上是可行的，但是当你同时研究10到15个球的运动行为时，实际需要的大量人力劳动将使得这项研究无法实行（译者：1948年计算机尚处于萌芽阶段）。<br>想象一下，一个巨大的台球桌上包含了上十亿个台球在滚动，相互碰撞，令人惊奇的是这样的体系反而因为统计学可以应用其中而变得容易研究了。尽管单个的球体的运动轨迹无法被追踪，但是很多有用的问题可以得到解答，譬如说：平均每秒有多少球与球台边缘碰撞？平均每个球在碰到其他球之前运动了多远的距离？平均每个球每秒受到多少次撞击？<br>早些时候我们说这种新的统计方法可以适用于“混乱复杂体系”，数十亿个台球在球桌上运动的问题为什么可以描述为“混乱复杂体系”呢？这种统计的方法适用的前提是球的运动为位置的随机的，也就是“混乱”的。譬如，如果我们将所有的球都放置在一行之上并且让他们严格的平行于竖列运动，这些球将永远无法相互以及与竖列的边沿碰撞，统计的方法也就不再适用了，这个体系也不是“混乱复杂体系”了。<br>从上面描绘的图景中我们清楚的认识了混乱复杂体系的意义。这类问题具有大量的变量，并且其中的变化是混乱的，甚至是完全不可预测的。但是，尽管其混乱性非常强，但是体系整体的行为是有规律的，其平均性质是可以解析的。<br>大量的实际体系可以归结为混乱复杂体系，其方法的准确性随着体系数量的增长而提高。在大量电话线路交换的预测平均拨号频率，以及相同拨号冲突的概率等问题中，这样的方法被证明是有效的。这种方法同样也确保了生命保险公司的财务稳定，尽管保险公司并不知道每个投保人的生活状况，但是公司可以了解群体的平均死亡率。<br>最后，重要而且有趣的一点是，统计方法学并不是完全依照理论中对每个个体行为完全理解的基础上应用的。在前面的台球桌的例子中，牛顿力学可以完美的解释和预测台球的碰撞行为。但是在保险公司的例子中，个体的行为（死亡率）实际上是受到一系列复杂因素影响的，因而是不可知的。<br>尽管保险公司以及电话线路的例子展现了统计学的实际应用前景，但在某种程度上，这些并不是很好的例子，因为这些例子使得人们忽视了统计学在更基础的自然科学中的应用和贡献。从组成物质的原子运动到组成宇宙的星体的运动都使用统计学进行研究。遗传理论应用了统计学分析，描述一些物理体系发展运动方向（孤立体系熵增）的热力学定律是通过统计学推导而出的。现代物理的架构，我们对自然世界的物理规律，以及目前获得的实验观测数据都是建立在统计学的概念上的。实际上，观测结果以及对观测结果的推论都是建立在统计思想上的，因此概率的思想构成了知识和理论本身。</p>
<h4 id="有序复杂问题"><a href="#有序复杂问题" class="headerlink" title="有序复杂问题"></a>有序复杂问题</h4><p>强大的统计学工具相比于处理一两个变量的朴素问题的方法有了很大的提升，但是却留下了很大一部分未探索的情形。研究者常常试图过分的简化问题，声称科学的研究体系不是只有一两个变量的朴素简单体系就是具有天文数量变量的混乱复杂体系，然后忽略很大一部分的中间地带。 这个中间地带为什么重要呢？并不是因为这部分涉及的变量数目比三两个要多，而又比一小撮盐当中的原子数目要少。对于这部分科学尚未涉足的中间地带，真正重要的特征是他们呈现出一种有秩序的特征————与前述的统计学支配的无序复杂体系不同————因此我们又可以称这部分问题为有序复杂问题(Organized complexity)。<br>月见草(primrose)因何而开？为什么盐水不能止渴？为什么一支菌株可以合成某种化学物质而另一支却不行？为什么一种有毒的物质的镜像对映体却是无毒的？ 为什么饮食中的锰元素含量会影响动物的母性行为？ 如何从生物的角度解释衰老？ 还有下面这些问题的研究会有什么意义呢： 病毒是否是“活”的？ 基因是什么？基因是如何靠表达自身指导生物发育的？ 复杂的蛋白组装体是否“指导”如何复制自身？这与生物体的繁殖有关么？ 所有这些问题都是一类复杂的问题，但却不是统计学支配的无序复杂的(disorganized complexity), 他们是关于一类有大量相互作用的变量共同形成的有机整体的问题，他们都是我这里所说的，有序复杂问题(organized complexity)。<br>小麦的价格与什么相关呢？这也是一个有序复杂问题。很多变量与之相关，并且这些变量也是相互关联形成一个复杂的整体的。<br>经济体系是如何维持稳定的呢？ 依赖于供需平衡的经济体系有多安全呢？ 应该多大程度上应用调控使得经济不至于波动太大？这些问题也是关于复杂体系的问题，因为研究的体系是一个有机的整体，其中的每一部分斗都与其他部分紧密相关。<br>我们该如何解释一个群体例如一个实验室的人员，一群工人或者一个种族的行为模式呢？显然很多因素在这其中起作用，然而使用数学平均的方式来描述它是不够的。 给定一个国家一定可以消耗的资源，采用什么样的策略才更可能获得战争的胜利？ 或者另一方面，放弃多少自私的欲望将更有效的保持世界的和平？<br>这些问题，以及一系列类似关于生物，医药，心理，经济以及政治科学的问题，对于19世纪流行的处理三两个变量的经典理论来说太复杂了。同样的，也不能被广泛应用在处理无序混乱体系中的统计学解释。<br>这些问题又与世界发展的未来如此相关，以至于要求科学进行第三次革命，比19世纪学会处理三两个变量的革命，以及20世纪学会处理无序混乱体系的革命更为重要。科学界必须在今后的50年里学会处理有序复杂体系。<br>目前又什么能确保这样的革命可以完成呢？ 有一些曙光确实存在，存在于这样一个事实：全世界数百名学者已经开始在思考这些问题了。 物理学中使用的定量实验的方法以及数学分析的工具从未有过的被应用在生物学，医学甚至是社会学的研究中。 目前获得的成果尽管是零散的，但却十分可信。 与25年前相比，我们在生物学中的癌症研究已经获得了更加清晰的图景。无疑我们对癌症的认识还是肤浅的，但我们已经发展了一些研究工具并且基本肯定了一些关键问题之所在。 我们知道一些癌症类型是可以被某种化学品诱发的，了解了一些类型的癌症的遗传易感性。原子物理发展出了百万伏甚至更强的射线。 发射性元素可以用来进行基础研究以及治疗。 科学家正在面对生物体中最为复杂的生化过程。 对于正常细胞的了解将有助于我们识别病态的细胞，尽管距离这个目标还很遥远，至少我们已经在解决问题的路上了。<br>除了上述的正在发展的可能解决问题的方向，还有至少两个很可能有助于我们发展的特别的事情。 罪恶的战争最终留下了帮助我们解决复杂问题的曙光。<br>其中之一即是在战争时期发展的电子计算机，这种装置的灵活性和可用性更类似于人类的大脑而不是传统的机器。它们具有存储大量信息的“记忆”，它们也可以被“指示”去独自完成复杂的科学计算。它计算十位数乘法的速度比人脑快4万倍。 灵活性，可用性以及快速性的集合使得它将对科学的发展产生巨大的影响。 它们使得过去过于复杂的问题能够得到解决，更重要的是，它将促成新的分析复杂体系的方法的建立。<br>第二个战时产生的进步是建立“多元化团队(mixed-team)”来解决问题。 尽管在未军方进行数学计算的人已经非常熟悉这个名词了，但我还是要介绍一番。<br>想象这样一个场景，为大西洋上的目标提供护航以及补给，考虑可以使用的舰艇数量，潜艇攻击能力以及其他可量化的和不可量化的因素。 如何组织才是最好的方案？综合考虑到速度，安全性，经济性等指标？ 护航编队应该是大是小？速度要快还是慢？ 他们应该迂回前进还是直线前进？ 应该如何组织，如何防御才是最好的？ 什么样的组织和架构形式才能更好用于巡防和攻击？<br>试图去回答这些宽泛的战术问题的工作团队就是运作分析团队(operations analysis groups)。 从英国开端，在纳粹的反潜艇作战以及陆军防空队中大放异彩，这样的运作分析团队更多的被称为“多元化团队”。 尽管数学家，物理学家以及工程学家都是必要的，实际上最好的交叉团队包含了心理学家，生化学家，生理学家以及多种生物医药以及社会学方面的代表性任务。 例如在优秀的英国多元化团队中，就包含了内分泌专家和X射线晶体学家。 在战争的压力下，这些交叉团队在同一个普遍性的问题上施展了队员各自不同角度的才华。 尽管现代科学有专业分工增强的趋势，但是最终人们发现在多元化团队中的人可以共同工作并且形成一个整体效用大于所有人之和的组织。 实践证明这样的团队可以针对一个复杂性问题进行研究并且获得有用的解答。<br>预测在未来50年将会实现的科学的巨大进步中，将会有交叉团队的贡献，就像他们在战时做的那样。计算机的发展更会提高他们的效率。 但是，并不能认为这就是未来科学工作的方式。 一定会有那种只有在独立的环境下才能保持思维的自由的科学家，那样的人一定会独立工作。 前者则是更“美国”的做事方式。 不同方式之间的竞争将是有益的，所以这里并没有一定要描绘一幅所有科学家都在同样的体系下工作。这里仅仅是建议一些学者可以寻求一种新的合作方式，在团队中包含所有必要领域的专家，这样一种新的工作方式，在计算机的帮助下，将为后半个世纪发展解决复杂生物和社会学问题的方法提供帮助。</p>
<h4 id="科学的界限"><a href="#科学的界限" class="headerlink" title="科学的界限"></a>科学的界限</h4><p>让我们会到最初的问题，什么是科学？什么不是科学？我们希望从科学获得什么？<br>科学显然是解决问题的一种方法————并不是所有的问题，但是是很大一部分重要的和实践性的问题。科学可以处理的问题是那些影响的主要因素是符合逻辑的基本规律，常常还是可以度量的问题。科学是这样的可重现的知识的集合，是专注与训练想象力，是权衡证据，是确定哪些现象是相关的，哪些是无关的，是验证假设，是丢失可能不准确的数据，是阐述，是面对事实，是让自然的真相服务于人类。<br>科学的本质并不是其外在的表现，不是其物理现象，而在于其内核的精神。 那些朴素却令人激动的探究方式也就是人们常说的科学方法。 科学的方法要求实施者诚实守信，头脑开放，视野聚焦以及热爱真理。 这些都是可贵的品质，但是科学却并不完全依赖它们，诗人往往也有同样的品质，并且将它们用在更纯高的地方。<br>科学已经在解决逻辑和定量问题上获得了极大的成功。事实上，这类成功实在是太多太伟大了，以至于失败的结果极少被公开发布，以至于普通的人一定觉得科学是人类完成的最伟大的事业。事实上，这样的看法的确有一点道理。<br>我们取得的成就大伟大了，以至于科学家没有理由走出固有的工作方式。 但我们必须清醒的认识到，尽管很多简单的问题已经被科学解决，还有很多复杂的，与人类未来相关的问题，任然摆在我们面前。<br>因此，我们必须停止认为科学永远是解决简单问题的成果的方法。这在某种程度上意味着我们不在把科学当做手中摆弄的小玩意儿，也不能认为科学史现代的可以掌控任何事的黑魔法。<br>我认为所有科学家都会对科学在未来为人类福祉作出巨大贡献怀有信心。科学将会继续认识物理，了解自然法则，学会预测以及调控，创造新的物质攻人们使用或者娱乐。 科学将会继续帮助我们认识动物的本性，提高健康水平，延长寿命以及更加了解人类的行为。实际上，我认为有追求的科学家还“得寸进尺”的希望这种精确的，客观的分析手段可以应用于过去极少涉足的社会学以及政治学的领域。<br>甚至更进一步的，由于科学本身的特质，科学家坚持使用精确定义的术语以及明确阐述的问题进行交流。尽管在科学领域确实更容易获得清晰的定义，但是实际上科学的语言在表意的有效性上压倒一切自然语言，意识以及传统。 这种普适性对于跨域时空限制，跨越政治以及文化的界限是非常重要的。可能科学本身比任何有智慧的人更能够解决意识交流的问题，得到世界范围内的合作，分享以及获得科学成果。<br>是的，科学是一种强大的工具，获得了巨大的成功。然而谦逊和明智的科学家不会期待科学可以解决任何问题。 他记得科学教会我们重视特殊的情况，他不认为任何一个社会，经济或者政治问题会因为“科学家”的介入而自行解决，他不期待——也许有些例外——科学可以提供道德和美学的基准。他不期待科学能够度量或者控制人类的爱，纯真，价值观以及信仰。人生之中有太多无形的难以衡量的感性存在，它们是无法在显微镜下观测的，无法在天平上称量的，无法被最灵敏的话筒记录。<br>如果科学只是关于定量的逻辑的问题的话，如果科学不去关注价值以及目标，那么现代的有科学素养的人如何获得平衡的幸福生活？逻辑是美感的伙伴，效率是一种美德。<br>答案或许是简单的，那就是让我们的精神匹配我们的技术。为什么要这样呢？使得我们驾驭力量的智慧与我们所拥有的力量匹配需要多方面的努力。我们必须加强对个体以及群体行为的理解，必须加强不同语言和文化背景的人之间的交流，必须使用同样的规范分享我们的观点。我们对影响政治和经济的因素的理解必须有飞跃式的加深，必须建立起牺牲个人甚至民族的短期的自私的利益以换取对整个人类长期的贡献的意愿。<br>这些提升需要建立在对科学到底是什么的理解上，建立在科学不可避免的展现出强大的影响力的世界中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2017/05/01/Fun-with-your-first-Day-with-Matlab-S01E02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2017/05/01/Fun-with-your-first-Day-with-Matlab-S01E02/" itemprop="url">Fun with your first daty with Matlab S01E02</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-01T23:32:35+08:00">
                2017-05-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/MATLAB/" itemprop="url" rel="index">
                    <span itemprop="name">MATLAB</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h3><p>上一节当中我们说到了如何使用MATLAB作为高级的计算器，事实上，数据处理的过程就是对“数字”进行计算从而获取有意义的信息的过程。理论上来讲，如果时间足够多，我们就可以使用计算器手工计算处理任何的数据。然而，这种方式太过繁琐，如果要处理成千上万条数据记录，还不是要被累死!更重要的是，处理这些数据的方法大多数情况下都是固定的，重复的。对于这种由明确定义的，固定的，重复的工作，交给计算机程序来做真是最好不过了。幸运的是，有很多数据处理的任务都是这样的。使用计算机语言批量的执行任务，我们需要写“脚本”。脚本(Script)就是一组指令，写好以后计算机会按照顺序依次执行，而不需要有人在一旁看管，实在是非常方便。那么我们就开始学习如何写MATLAB的脚本吧！</p>
<h3 id="MATLAB中的数据类型"><a href="#MATLAB中的数据类型" class="headerlink" title="MATLAB中的数据类型"></a>MATLAB中的数据类型</h3><p>数据类型是计算机程序中非常重要的概念。计算机工作的原理就是对数据进行操作，因此数据类型应该是非常基础和重要的东西啦！学过C语言的同学可能还记得，C语言中有整形变量(int:0,1,2,3…), 单精度浮点类型(float:1.0,1.2….)等等数据类型。像C语言这样的，在声明变量之前，首先要声明变量类型的语言，被称为【强类型语言】。例如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//声明变量i为整型变量，初始值为0</span></div></pre></td></tr></table></figure></p>
<p>MATLAB的脚本语言，在声明变量的时候并不需要声明类型，而是由解释器（将MATLAB脚本进一步解释为计算机能够理解的指令的东西）决定变量的类型，这样的语言被称为【弱类型语言】。最近火热的Python也是弱类型语言哦。弱类型语言实际上是方便使用者，也就是编程人员，的一项设计。不过相比与类型严格的强类型语言，在使用弱类型语言的时候，有可能会渐渐忘记或者搞混变量的类型，引发程序错误。如果错误在运行时被发现的话，还是很好的。可是，如果在运行时因为类型错误而进行了错误的计算，解释器并没有因此报告错误的话，是可能使处理出来的数据完全没有意义的。因此，在完成复杂的程序编写以后进行测试以便确定算法的正确性是一个非常重要的好习惯。为了保持这样的习惯，你需要在下意识里“质疑”自己写的程序。</p>
<h4 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h4><p>上一节我们讲到，MATLAB可以被认为是Matrix Lab的缩写，可见，矩阵在MATLAB中的重要地位。 矩阵可以类比于C语言中的数组，是包含一组<strong>同类</strong>数据的<strong>容器</strong>。【容器】在计算机术语里面称为Container。正如其名，是包含一组数据的结构。MATLAB中的矩阵的特点是只能包含同类型的数据，除了数学上的数字以外，还可以包含字符串，引用等等。矩阵的数据结构还可以让我们轻易的进行高效的矩阵运算，如矩阵乘法，转置，求逆等等。使用矩阵的思维进行数据处理，还可以大大加快程序运行的速度，这样的技术被称为“向量化”。我在自己的工作中，超过一半的计算都是通过矩阵进行的。</p>
<h5 id="矩阵基础"><a href="#矩阵基础" class="headerlink" title="矩阵基础"></a>矩阵基础</h5><p>矩阵是有【维度】的，这个维度就是指矩阵的大小。在MATLAB中，我们可以通过size函数获取矩阵的大小。例如：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">x = <span class="built_in">rand</span>(<span class="number">5</span>); <span class="comment">%创建5x5的矩阵</span></div><div class="line">[nr,nc] = <span class="built_in">size</span>(x)</div><div class="line">nr = </div><div class="line"><span class="number">5</span></div><div class="line">nc = </div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure></p>
<p>上面的代码中我们使用rand函数创建了一个5x5的随机数矩阵，使用size函数可以获取矩阵的行数和列数。值得注意的是，在编写程序或者脚本的时候，变量的命名非常重要。因为程序是写给人看的，而不是给计算机看的。因此，使用良好的变量命名规范，可以使得程序的【可读性】变得更好，方便自己和他人阅读程序。这里，nr和nc是常用的矩阵大小变量命名，是number of row以及number of column的缩写。不同的语言的变量命名也不尽相同，Python的变量命名非常喜欢使用下划线_，因此，同样含义的变量可能会被命名为num_row以及num_col。如果我们希望只得到矩阵的行数，可以使用<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nr = <span class="built_in">size</span>(x,<span class="number">1</span>);</div><div class="line">[nr,~] = <span class="built_in">size</span>(x);</div></pre></td></tr></table></figure></p>
<p>这两种写法。其中，第一种写法使用了size函数的可变参数的功能。可变参数是指一个函数可以输入多种可能数量的参数，并因此而改变函数的行为。MATLAB中大多数函数都是有可变数量参数的，这样设计的目的是为了既保证函数调用的简洁性，又保持函数调用的灵活性。<br>怎么理解呢？譬如说我们现在有一个add函数，作用是给传入的参数加上一个值。我们在使用的过程中发现，大多数情况下，我们都是给传入参数加上1的，因此，我们可以把add函数设计为一个可变参数的函数。当调用<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">add(x);</div></pre></td></tr></table></figure></p>
<p>时，函数的行为是返回x+1的值。当调用<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">add(x,a)</div></pre></td></tr></table></figure></p>
<p>时，函数的行为是返回x+a的值。这样在大多数情况下我们都可以按照前者的方式调用函数，非常的简洁方便。可是我们需要使用add函数提供的更灵活的功能时，例如加上a，我们又可以按照后者的方式进行调用。这就是所谓的既保证函数调用的简洁性，又保持函数调用的灵活性，是不是很方便呢？在这个例子里，add函数的第一个参数是必要的，否则就不知道在谁的基础上做加法了。第二个参数是可选参数，可以指定，如果没有指定就使用默认值。<br>size函数调用的第一种写法中第二个参数1就是可选的参数。它代表传入的矩阵的轴的次序。1是指列，2则是指行。在matlab中的矩阵，因为常常与数据处理相关，因此矩阵的行往往表示<strong>观测结果</strong>，列往往表示<strong>观测的维度</strong>。譬如我们对小学生早晨上学这个事情进行观测，那么默认我们的数据集矩阵的行是上学的每一个小学生，列则是相应学生的身高，体重等等信息。<br>第二种获取矩阵大小的方式我们使用了符号~。“~”代表我们在之后的计算中不需要使用相应位置的变量。这使得matlab脚本在执行的时候不在为这部分数据分配储存空间，因此在程序运行的效率上会更好一些。</p>
<h5 id="创建矩阵"><a href="#创建矩阵" class="headerlink" title="创建矩阵"></a>创建矩阵</h5><p>我们常常需要创建新的矩阵，新矩阵的创建有很多种方法<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = <span class="built_in">zeros</span>(<span class="number">5</span>) <span class="comment">%创建5行5列的零矩阵</span></div><div class="line">a = <span class="built_in">zeros</span>(<span class="number">5</span>,<span class="number">3</span>) <span class="comment">%创建5行3列的零矩阵</span></div><div class="line">a = <span class="built_in">zeros</span>(<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>) <span class="comment">%创建5行3列2层的零矩阵</span></div></pre></td></tr></table></figure></p>
<p>类似的，我们还有<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = <span class="built_in">ones</span>(<span class="number">5</span>,<span class="number">1</span>) <span class="comment">%创建5行1列的全1矩阵</span></div><div class="line">a = <span class="built_in">nan</span>(<span class="number">5</span>,<span class="number">1</span>) <span class="comment">%创建5行1列的全无效数字矩阵</span></div><div class="line">a = <span class="built_in">rand</span>(<span class="number">5</span>,<span class="number">1</span>) <span class="comment">%创建5行1列的随机矩阵</span></div><div class="line">a = <span class="built_in">randn</span>(<span class="number">5</span>,<span class="number">1</span>) <span class="comment">%创建5行1列的正态分布随机矩阵</span></div><div class="line">a = <span class="built_in">eye</span>(<span class="number">5</span>) <span class="comment">%创建5阶单位矩阵</span></div></pre></td></tr></table></figure></p>
<p>我们也可以直接创建矩阵，使用中括号表示矩阵的起始，逗号或者空格表示矩阵的行间隔，分号表示列间隔。例如：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</div><div class="line">a = </div><div class="line">[ <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></div><div class="line">  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></div><div class="line">  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>]</div></pre></td></tr></table></figure></p>
<p>还可以使用冒号：操作符建立等差的行向量（1行n列的矩阵），例如<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = <span class="number">1</span>:<span class="number">1</span>:<span class="number">10</span> <span class="comment">%建立一个以1为始，1为步长，10为终止的行向量</span></div></pre></td></tr></table></figure></p>
<p>当步长为1的时候，也可以省略，直接用1:10表示起始位置。<strong>注意,MATLAB中所使用的符号均为英文符号！</strong></p>
<h5 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h5><p>创建矩阵以后，我们还需要对元素进行操作。这些操作主要包括索引和赋值。索引就是通过编号来查找矩阵中某一个位置的元素的值，赋值就是改变某一个位置元素的值。<br>矩阵是通过行列来进行索引的，索引用括号表示，括号内可以使用逗号进行分割，表示行或者列的区别。例如：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</div><div class="line">a = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span></div><div class="line">     <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></div><div class="line">     <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</div><div class="line">x = a(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">% 索引矩阵a的1行2列的数值</span></div><div class="line">x = <span class="number">2</span></div></pre></td></tr></table></figure></p>
<p>MATLAB中存储矩阵数据是按照列存储的，因此也可以使用序号对矩阵数据进行索引，因为MATLAB的序号是以1开头的，因此需要的最大值是行数*列数。这种索引方法并不推荐，因为并不直观，容易出BUG，但是介绍这种方法的意义在于写代码的时候有时会因为不注意而忘记写行列索引中的逗号，这种情况下MATLAB可能仍然执行代码，只不过是按照上面介绍的序号索引取值，而不会引发错误警告。在这种情况下，计算实际上是错误的，因为你索引到的数据并不是你想要的，然而MATLAB的解释器并不会发现这个错误，因而是十分危险的。<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x = a(<span class="number">3</span>) <span class="comment">%索引矩阵a的第3个值</span></div><div class="line">x = <span class="number">7</span></div><div class="line">x = a(<span class="number">8</span>) <span class="comment">%索引矩阵a的第8个值</span></div><div class="line">x = <span class="number">6</span></div></pre></td></tr></table></figure></p>
<p>同时，我们也可以向量化的进行索引，冒号在这里表示在相应的维度取所有有效的值<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x = a([<span class="number">1</span>,<span class="number">2</span>],<span class="number">3</span>) <span class="comment">%索引矩阵a的第1,2行，第3列的值</span></div><div class="line">x = [<span class="number">3</span></div><div class="line">     <span class="number">6</span>]</div><div class="line">x = a(<span class="number">3</span>,:) <span class="comment">%索引矩阵a的第3行，所有列的值</span></div><div class="line">x = [<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</div></pre></td></tr></table></figure></p>
<p>end在索引中代表相应维度的最后一个有效的序号<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x = a(<span class="keyword">end</span>,<span class="number">3</span>) <span class="comment">%索引矩阵a最后一行，第三列的值</span></div></pre></td></tr></table></figure></p>
<p>索引中还有一个很重要的方法叫做逻辑索引。在实际应用中，这种索引方式非常方便，可以使得代码更简洁，运行速度也更快。逻辑索引是在索引的位置不传入索引的需要（如第1行，第3列等），而是传入一个与被索引矩阵相应维度等长的逻辑数组，其中每个逻辑元素表示相应的位置是否会被索引到，如果为True就表示索引到，反之则为被忽略掉。例如，我们对一个随机向量r,想要获取数值大于0.5的所有值，可以这样操作<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">r = <span class="built_in">rand</span>(<span class="number">10</span>,<span class="number">1</span>) <span class="comment">%建立[0,1]均匀分布的10行列向量</span></div><div class="line">logicTag = r &gt; <span class="number">0.5</span> <span class="comment">%获取元素是否大于0.5的逻辑向量，向量大小与r相同</span></div><div class="line">x = r(logicTag)</div></pre></td></tr></table></figure></p>
<p>在实际应用中这种方式非常有用，例如：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">t = importdata(<span class="string">'sales.csv'</span>) <span class="comment">%一个3列的表格，每一列分别表示 商品出售时间，商品价格，商品折扣</span></div><div class="line">logicTag = t(:,<span class="number">2</span>) &gt; <span class="number">10</span> <span class="comment">%获取商品价格大于10的逻辑向量</span></div><div class="line">saleTime = t(logicTag,<span class="number">1</span>) <span class="comment">%获取商品价格大于10的商品的出售时间</span></div></pre></td></tr></table></figure></p>
<p>在上面的例子中我们非常方便的获取了商品价格大于10的商品的出售时间，而不需要循环判断。<br>元素操作的另一个重要方面是元素的赋值。上面我们进行取值的时候，元素的索引放在了等号的右边。当进行元素赋值的时候，索引就放在等号的左边来告诉MATLAB的解释器将数值赋值给哪些元素。例如：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</div><div class="line">a = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span></div><div class="line">     <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></div><div class="line">     <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</div><div class="line">a(<span class="number">1</span>,<span class="number">3</span>) = <span class="number">0</span> <span class="comment">%将1行3列的元素赋值为0</span></div><div class="line">a = [<span class="number">1</span> <span class="number">2</span> <span class="number">0</span></div><div class="line">     <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></div><div class="line">     <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</div></pre></td></tr></table></figure></p>
<p>赋值的时候有两种赋值的形式。一种是按照元素赋值，一种是广播赋值。<br>按照元素赋值的时候，等号的左右两边必须是维度相同的矩阵，例如<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a(<span class="number">1</span>,:) = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]; <span class="comment">%正确，等号左右两边都是1行3列</span></div><div class="line">a(<span class="number">1</span>,:) = [<span class="number">0</span>;<span class="number">0</span>;<span class="number">0</span>]; <span class="comment">%报错，等号的左边是1x3向量，右边是3x1向量</span></div></pre></td></tr></table></figure></p>
<p>另外一种赋值的方法是广播赋值，顾名思义，在这种形式下，等号右边是单一数值，数值将赋值给左边表示的矩阵的任意一个元素，例如：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</div><div class="line">a = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span></div><div class="line">     <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></div><div class="line">     <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</div><div class="line">a(<span class="number">1</span>,:) = <span class="built_in">inf</span></div><div class="line">a = [inf inf inf</div><div class="line">     <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></div><div class="line">     <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</div></pre></td></tr></table></figure></p>
<p>无穷大inf这个值就赋予了左边a矩阵的1行所有列的所有位置上<br>上面学的索引的方法在赋值的时候都可以使用，因此我们可以快速的实现很多效果，比如有两个等长的向量a和b，我们希望将a中大于0的数字都替换成对应位置的b的数字，可以这样：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bLogic = a &gt; <span class="number">0</span>;</div><div class="line">a(bLogic) = b(bLogic);</div></pre></td></tr></table></figure></p>
<p>是不是很方便呢？</p>
<h5 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h5><p>矩阵的运算非常多，这里介绍主要的几种。<br><strong>转置</strong>：矩阵的转置是常见的矩阵运算，数学中的转置用T来表示，在MATLAB中，用英文中的一撇来表示<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A = A';</div></pre></td></tr></table></figure></p>
<p>矩阵的转置除了本来的数学意义以外，很多情况下也用来将原始的数据进行转置以满足一些函数的输入需求，某些函数要求输入的数据是行向量或者列向量的形式。<br><strong>统计计算</strong>：统计计算中经常要求计算最大值，最小值，标准差等等统计量。这些统计量的计算在MATLAB中都有具体的函数，以max函数为例：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>; <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</div><div class="line">b = max(a) <span class="comment">%默认，按列取最大值</span></div><div class="line">b = <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></div><div class="line">b = max(a,[],<span class="number">2</span>) <span class="comment">%按行取最大值</span></div><div class="line">b = [ <span class="number">3</span></div><div class="line">      <span class="number">6</span></div><div class="line">      <span class="number">9</span>]</div></pre></td></tr></table></figure></p>
<p>因为MATLAB的逻辑中，行代表观测的样本，列代表观测特征，因此在默认情况下，统计函数都是对列进行计算，也就是对观测的特征进行计算。也可以通过输入特别的参数来指定特定的计算维度。如果想要得到一个矩阵的最大值怎么办呢？<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">b = max(max(a)) <span class="comment">%naive的方法</span></div><div class="line">b = max(a(:)) <span class="comment">%高级的方法</span></div></pre></td></tr></table></figure></p>
<p>a(:)的方法可以将矩阵a完全向量化为一个列向量,因此使用一次，max函数就可以得到整个矩阵的最大值。<br><strong>数值计算</strong><br>矩阵可以直接与一个数值进行加减乘除，结果是矩阵中每一个元素对这个数值进行加减乘除；矩阵相互之间可以相互加减，要求是相互加减的矩阵维度大小相同，例如其中一个矩阵是3x5的矩阵，另一个矩阵也必须是3x5.矩阵之间也可以相互乘除，要求也线性代数的一样。<br>那么，如果想要让矩阵中每一个元素分别乘除另一个矩阵中对应的元素怎么办呢？只要在乘除符号前加上英文的.就可以。.*和./代表的含义就是逐元素的乘和除。此时要求两个矩阵对应维度大小相同，与矩阵相互加减的情况相同。</p>
<p>这里举一个例子，在数据分析中有一个常见的需求是对各个观测量的数值进行归一化，也就是让各个观测维度的数值均值为0，方差为1。这样做的好处是使得各个观测的特征对数据分布的贡献相同。这样讲有点抽象，我们再举一个实际例子，譬如说我们对房价的一个观测：</p>
<table>
<thead>
<tr>
<th>样本序号</th>
<th>与中心城区距离</th>
<th>面积</th>
<th>价格</th>
<th>层高</th>
<th>客厅面积与卧室面积之比</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>50</td>
<td>100</td>
<td>1000000</td>
<td>20</td>
<td>0.5</td>
</tr>
<tr>
<td>2</td>
<td>20</td>
<td>80</td>
<td>2000000</td>
<td>15</td>
<td>0.8</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>在这个例子里面一个房子就是一个观测样本，房子的面积、价格等等都是对于这个样本的观测属性，或者说是特征。不同的特征，数值范围不同。在这个例子当中，房价这个特征数值最大，客厅卧室面积之比这个特征数值最小。可是如果不做处理，价格这个特征的变化量在数值上要远远大于面积之比的变化量，这样就可能掩盖后者变化造成的影响。为了在数值上让不同的特征的变化有相同的权重，就需要做归一化。也就是让不同的特征在所有样本上的值均值为0，方差为1。在数学上，假设某个维度用$X$表示，$X_i$表示第i个观测值，$\mu_x$表示$X$的均值，$\sigma_x$表示$X$的标准差,使用$X_i^{transformed}$表示转换以后的特征数值。那么可以使用<br>$$X_i^{transformed}=\frac{X_i-\mu_x}{\sigma_x}$$<br>这个公式进行归一化转换。假设我们我们这个观测的表是x，一个最为naive的操作是：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[nr,nc] = <span class="built_in">size</span>(x); <span class="comment">%获取行数和列数</span></div><div class="line"><span class="keyword">for</span> m = <span class="number">1</span>:nc <span class="comment">%对于每一列</span></div><div class="line">    rowMean = mean(x(:,m));</div><div class="line">    rowStd = std(x(:,m));</div><div class="line">    <span class="keyword">for</span> n = <span class="number">1</span>:nr <span class="comment">%对于每一行</span></div><div class="line">        x(n,m) = (x(n,m) - rowMean)/rowStd;</div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>另一种操作是通过向量化的方式，其中repmat的作用是将一个矩阵重复堆叠。repmat(x,2,1)的含义是将x矩阵当做一个元素堆叠为两行一列，如果x的的维度是mxn，那么堆叠以后就会成为(2*m)xn的矩阵。<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">L = <span class="built_in">size</span>(x,<span class="number">1</span>); <span class="comment">%获取x表格的长度/矩阵的行数</span></div><div class="line">xMean = mean(x); <span class="comment">%获取x的各个维度(各列)的平均值</span></div><div class="line">xStd = std(x); <span class="comment">%获取x的各个维度(各列)的标准差</span></div><div class="line">x = (x - <span class="built_in">repmat</span>(xMean,L,<span class="number">1</span>))./<span class="built_in">repmat</span>(xStd,L,<span class="number">1</span>);</div></pre></td></tr></table></figure></p>
<p>那么关于向量数据结构的讲解就到这里吧！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2017/04/20/Fun-with-your-first-Day-with-Matlab-S01E01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2017/04/20/Fun-with-your-first-Day-with-Matlab-S01E01/" itemprop="url">Fun with your first Day with Matlab S01E01</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-20T22:54:54+08:00">
                2017-04-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/MATLAB/" itemprop="url" rel="index">
                    <span itemprop="name">MATLAB</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我打算写一系列关于MATLAB入门的文章。原因有二，一个是我发现身边很多搞科研的小伙伴有处理数据，实现算法的需求，但是却苦于没有办法入门一种处理数据的编程语言（或者说脚本语言吧）。虽然说市面上MATLAB入门的书籍很多，但是我等写代码的人总有一种“造轮子”的情怀，总觉得还不如自己搞的好，因此，还是按照自己的思路写一套入门的教程似的东西。二来嘛，也是自己觉得好玩咯。</p>
<h4 id="这些文章适合谁"><a href="#这些文章适合谁" class="headerlink" title="这些文章适合谁"></a>这些文章适合谁</h4><p>正如上面所说的，如果你已经有了MATLAB编程经验了，我只能说——大神求轻拍！</p>
<h4 id="MATLAB"><a href="#MATLAB" class="headerlink" title="MATLAB"></a>MATLAB</h4><p>Matlab可以解释成Matrix Lab，直译成为矩阵实验室。它的计算是围绕着矩阵的，因此对向量化的计算支持很好（至于什么是向量化的计算，也许以后你就明白了吧…）。 据我所知，MATLAB，R语言，Python和Java都是比较流行的科学计算语言（加上Java是因为<a href="https://imagej.nih.gov/ij/" target="_blank" rel="external">ImageJ</a>的开发是使用Java的，而ImageJ在至少是生物化学学科的研究中，是有非常重要的地位的）。其中MATLAB，R以及Python都含有大量的程序包，使得你可以轻而易举的用一两行代码实现一些常用的算法和数据统计，非常适合快速的算法开发和验证，因此在学术研究中扮演了非常重要的作用。在实际的工业生产中，因为考虑到代码运行的效率的问题，可能会选择用更底层的语言如C++来作为最终产品的实现，但编程的思维和逻辑是不变的，这也是一些招聘岗位对掌握一门统计语言的应聘者比较青睐的原因吧。<br>实际上，上面说的都是废话，既然来看这篇文章，当然是本来就是下定决定学MATLAB的啦。</p>
<h4 id="文章的结构"><a href="#文章的结构" class="headerlink" title="文章的结构"></a>文章的结构</h4><p>我希望能从浅入深的带领大家学习MATLAB脚本的书写，让大家感受到其中的乐趣。近来有一款非常流行的游戏叫我的世界(Minecraft)，这款游戏之所以风靡全球，就是因为它的玩法构建在非常简单的原理（方块堆叠）之上，却给了玩家极大的自由发挥的空间。更重要的是，不同的简单的方块的组合，形成了复杂而庞杂的结构，使得观者惊叹，制作者也获得了非常大的成就感。写代码也是这样的，再复杂的程序也不过是顺序执行、判断跳转和循环执行组合而成的，却产生了这么多拥有复杂而强大的功能的软件。当你开始写代码的时候，你的面前就是等待你创造的世界！<br>至于文章的结构嘛，还没有特别想好，一边写一边看吧！</p>
<h4 id="准备什么"><a href="#准备什么" class="headerlink" title="准备什么"></a>准备什么</h4><p>一台电脑，我安装的是MATLAB R2016b，再加上你的热情，就可以开始啦！</p>
<h3 id="熟悉MATLAB"><a href="#熟悉MATLAB" class="headerlink" title="熟悉MATLAB"></a>熟悉MATLAB</h3><h4 id="MATLAB的界面"><a href="#MATLAB的界面" class="headerlink" title="MATLAB的界面"></a>MATLAB的界面</h4><p>我在这里不想再赘述MATLAB的安装了，一般下载的源文件中都会有readme之类的文本教你怎样一步一步的安装MATLAB，这里就略过。<br>我们可以看一下MATLAB的界面：</p>
<p><div align="center"><br><img src="http://i4.buimg.com/567571/13f8358b92553488.png" alt="“MATLAB的界面”"><br></div><br>其中包含了几个重要的部分：</p>
<ol>
<li>菜单栏：里面包含了很多功能，我们有机会慢慢讲述。软件的设置，新建脚本文件，函数，类文件都是在这里<br></li>
<li>工作目录：和R，Python一样，MATLAB也有工作目录。工作目录有这样的几个含义，当你输出输入文件的时候，如果没有指明具体的路径，而是只给出了文件名，那么就默认从工作目录进行读取和输出。如果读取的时候没有找到文件，就会报错。另外，当你执行一个命令的时候，MATLAB会首先从已经加入到一个路径列表里面的那些路径中从上到下寻找你输入的命令对应的源代码文件，如果没有找到，就会从当前工作目录找。如果还找不到，就会报错。这就意味着，当你做一个项目写了很多函数的时候，只能在存放这些函数的目录下进行调用，否则就会找不到命令。当然，你还可以将写好的代码的路径添加到MATLAB中的路径表中，这样就可以在其他工作目录下调用自己写的代码了。这里要注意的是，如果自己写的代码中的函数或者类与MATLAB自带的函数或者类同名，那么<strong>MATLAB会先找到哪个就用哪个</strong>，无疑会带来很多不确定性。MATLAB的命名是大小写敏感的，因此，自己写的函数可以用特殊的命名方法或者改变大小写来避免与MATLAB自带的函数混淆。<br></li>
<li>当前文件夹： 列出了当前工作目录下的文件，类似于Window的资源管理器<br></li>
<li>命令行窗口：最为重要的窗口，输入命令和观察计算的结果都是在这里<br></li>
<li>WorkSpace：显示了当前可以直接调用的计算中间值的名称和类型。譬如说你直接输入：<br><br>c = a + b;<br><br>这样会报错，说找不到a和b。因为你并没有声明a和b到底是什么，因此MATLAB就无法对他们进行运算。如果在命令行窗口输入<br><br>a = 1;<br><br>意味着你声明了一个变量a，值为1，这个a就会出现在WorkSpace中，从此以后你就可以随时调用。举一个不太恰当的例子，WorkSpace就好比是写作业时候的书桌一样，你首先要准备好要用的笔，橡皮，本子等等，相当于声明计算所需的变量。声明好以后，这些变量就像已经拿出来的笔、橡皮和本子一样可以随时使用。等到作业写完了，最好还要清理一下桌子上(WorkSpace)的杂物，让它保持整洁。<br></li>
<li>历史记录：非常有用的一个窗口，如果你找不到这个窗口，可以在1中的菜单中找到Layout——Show——Command History——Docked来打开它。这里面记录了你输入的历史命令，当你需要进行很多重复性的工作的时候，可以直接复制这里面的内容，再做修改使用，提高效率。当然，最快的方法还是写一个批处理脚本咯。历史记录还有一个作用，当你处理玩数据以后，可以按住Shift点选一定范围内的所用命令，右键选择Create Script，将创建一个脚本文件。你可以保存这个脚本文件，当需要重现处理结果的时候可以参考之。最后，历史记录还支持Ctrl+F搜索。如果你忘了一条命令原来是怎么用的了，可以用这个方法检索过去你使用的记录。</li>
</ol>
<h4 id="高级的计算器"><a href="#高级的计算器" class="headerlink" title="高级的计算器"></a>高级的计算器</h4><p>为了熟悉MATLAB，我们可以先把它当做一个计算器来使用。这个高级的计算器可以识别你输入的表达式，并且计算出这个表达式的值：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt; <span class="number">1</span>+<span class="number">2</span></div><div class="line">&gt;&gt; <span class="built_in">ans</span> = <span class="number">3</span></div></pre></td></tr></table></figure></p>
<p>我们可以看到MATLAB将表达式1+2的值正确的计算了出来，并给出了结果3。有趣的是，MATLAB的命令行窗口显示的是<em>ans=3</em>，再看看你的WorkSpace，是不是发现其中有一个名为ans的变量，显示值为3？这是因为MATLAB将这个表达式的计算结果默认的赋予给了变量<em>ans</em>。如果我们人为的指定计算结果赋予的对象，那么MATLAB就会将值赋予给我们指定的变量上：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt; a = <span class="number">1</span>+<span class="number">2</span></div><div class="line">&gt;&gt; a = <span class="number">3</span></div></pre></td></tr></table></figure></p>
<p>再看Workspace，就会发现你设置的变量a以及它的值3了。现在我们每次输入一个命令，马上在命令行窗口就可以看到执行的结果，这在有些时候是非常麻烦的事情。解决的办法就是在命令之后加上英文的分号 ;<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt; b = <span class="number">1</span>+<span class="number">2</span>;</div></pre></td></tr></table></figure></p>
<p>这样就看不到计算的结果了。在Workspace里面你仍然可以看到创建的变量b，可见这样的命令与不加分号的时候结果是相同的。加分号的好处可以在这个例子中体现：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt; vec = <span class="built_in">zeros</span>(<span class="number">100</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure></p>
<p>可以尝试一下上述命令的执行结果。上述命令的作用是产生一个100行1列的全零向量，通常用于一个数组的初始化，最后将这个向量赋予给变量vec，如果这个指令不加分号，那么就会在命令行窗口打印出来100行的0，非常的蛋疼，所以说，引号还是很有用的。<br>上面讲到的，如果我们不指定表达式的值赋予给谁，那么MATLAB就会默认的赋予给名为ans的变量。可见，ans这个词在MATLAB中是有特殊含义的，不能随便使用，这样的“保留”了特殊含义的单词还有很多：</p>
<table>
<thead>
<tr>
<th>单词</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ans</td>
<td>表达式值默认赋予对象</td>
</tr>
<tr>
<td>pi</td>
<td>圆周率常量</td>
</tr>
<tr>
<td>eps</td>
<td>微小的正值，常用于防止分母为0的情况</td>
</tr>
<tr>
<td>i，j</td>
<td>尽管可以任意负值，但常用于表示复数</td>
</tr>
<tr>
<td>inf</td>
<td>表示无穷大量，-inf表示负无穷</td>
</tr>
<tr>
<td>nan</td>
<td>表示Not a Number，一般永无表示解析失败的值</td>
</tr>
</tbody>
</table>
<p>在使用MATLAB计算表达式数值的时候，除了常用的加减乘除以外，还有其他的高级运算符<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a = <span class="built_in">log</span>(<span class="number">10</span>); <span class="comment">%自然对数</span></div><div class="line">b = <span class="built_in">log10</span>(<span class="number">10</span>); <span class="comment">%以10为底的对数</span></div><div class="line">c = <span class="built_in">exp</span>(<span class="number">10</span>); <span class="comment">%自然常数的10次幂</span></div><div class="line">d = <span class="number">2</span>^<span class="number">3</span>; <span class="comment">%2的3次幂</span></div><div class="line">e = <span class="built_in">sin</span>(<span class="built_in">pi</span>); <span class="comment">%正弦</span></div><div class="line">f = <span class="built_in">cos</span>(<span class="built_in">pi</span>); <span class="comment">%余弦</span></div></pre></td></tr></table></figure></p>
<p>等等，常见的数学运算一般都可以找到相应的符号来进行运算。<br>MATLAB还支持矩阵的运算。<strong>下面的例子里面，我们用大写字母表示矩阵，小写字母表示数字</strong><br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">A = <span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">%创建2行3列的全零矩阵A</span></div><div class="line">A1 = A + <span class="number">1</span>; <span class="comment">%矩阵加上一个数字，相当于每一个矩阵元素加上这个数字</span></div><div class="line">A2 = A * <span class="number">5</span>；<span class="comment">%矩阵乘以一个数字，相当于每一个元素乘以这个数字</span></div><div class="line">B = <span class="built_in">ones</span>(<span class="number">3</span>,<span class="number">2</span>); <span class="comment">%创建3行两列的全一矩阵B</span></div><div class="line">A + B; <span class="comment">%错误，矩阵相加的时候需要两个矩阵具有相同的大小，结果是对应的元素相加</span></div><div class="line">A + B’; <span class="comment">%正确，单引号表示矩阵的转置，B通过转置就有了和A相同的大小，可以相加</span></div><div class="line">A * B’; <span class="comment">%错误，矩阵相乘需要满足数学上的需求，A右边乘的矩阵需要有三行，B的转置只有两行</span></div><div class="line">A * B; <span class="comment">%正确，符合矩阵乘法的要求，获得2行2列的结果</span></div><div class="line">A .* B'; <span class="comment">%正确，乘号前面加英文句号表示对应元素相乘，要求两个矩阵大小相同</span></div></pre></td></tr></table></figure></p>
<p>向量的计算法则与矩阵相同，可见，MATLAB为矩阵的运算提供了很好的支持。那么问题来了，如果想要生成一个全部为9的3*2的矩阵怎么办？答案是：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A = <span class="built_in">ones</span>(<span class="number">3</span>,<span class="number">2</span>) * <span class="number">9</span>;</div></pre></td></tr></table></figure></p>
<p>是不是很简单？<br>最后，需要提醒大家注意的是，MATLAB中对于大小写敏感，也就是A和a是代表不同的东西的。另外，MATLAB输入的表达式需要用英文字符，如果使用中文字符将无法解析。<br>在上面的例子中，我们还使用了MATLAB中自带函数ones，zeros等才创建矩阵或者向量。其实，MATLAB中包含了大量的可以直接调用的函数。那么，是不是MATLAB高手就都会使用这些函数呢？对于常用的函数来说是的，但是，还有很多不常用的函数，它们的用法，除了上网搜索以外，MATLAB中还内置了doc文档提供详细的权威的解释，实在是学习MATLAB的好帮手。下一节，我们就来讲解如何使用doc文档。</p>
<h4 id="资深的老师doc"><a href="#资深的老师doc" class="headerlink" title="资深的老师doc"></a>资深的老师doc</h4><p>不管是Python，R还是MATLAB，都内置了一个函数用于帮助使用者了解一个指令的用法和作用的。实际上，Windows的cmd控制台以及Linux的终端都是这样的。<br>在MATLAB中有两个函数，help和doc来完成这个功能，譬如说我们想要查找mean这个函数的用法<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">&gt;&gt; help mean</div><div class="line">&gt;&gt; mean   Average or mean value.</div><div class="line">    S = mean(X) is the mean value of the elements in X <span class="keyword">if</span> X is a vector. </div><div class="line">    For matrices, S is a row vector containing the mean value of each </div><div class="line">    column. </div><div class="line">    For N-D arrays, S is the mean value of the elements along the first </div><div class="line">    array dimension whose <span class="built_in">size</span> does not equal <span class="number">1.</span></div><div class="line"> </div><div class="line">    mean(X,DIM) takes the mean along the dimension DIM of X.</div><div class="line"> </div><div class="line">    S = mean(...,TYPE) specifies the type in which the mean is performed, </div><div class="line">    and the type of S. Available options are:</div><div class="line"> </div><div class="line">    <span class="string">'double'</span>    -  S has class double <span class="keyword">for</span> any input X</div><div class="line">    <span class="string">'native'</span>    -  S has the same class as X</div><div class="line">    <span class="string">'default'</span>   -  If X is floating point, that is double or single,</div><div class="line">                   S has the same class as X. If X is not floating point, </div><div class="line">                   S has class double.</div><div class="line"> </div><div class="line">    S = mean(...,NANFLAG) specifies how NaN (Not-A-Number) values are </div><div class="line">    treated. The default is <span class="string">'includenan'</span>:</div><div class="line"> </div><div class="line">    <span class="string">'includenan'</span> - the mean of a vector containing NaN values is also NaN.</div><div class="line">    <span class="string">'omitnan'</span>    - the mean of a vector containing NaN values is the mean </div><div class="line">                   of all its non-NaN elements. If all elements are NaN,</div><div class="line">                   the result is NaN.</div><div class="line"> </div><div class="line">    Example:</div><div class="line">        X = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">3</span> <span class="number">3</span> <span class="number">6</span>; <span class="number">4</span> <span class="number">6</span> <span class="number">8</span>; <span class="number">4</span> <span class="number">7</span> <span class="number">7</span>]</div><div class="line">        mean(X,<span class="number">1</span>)</div><div class="line">        mean(X,<span class="number">2</span>)</div><div class="line"> </div><div class="line">    Class support <span class="keyword">for</span> input X:</div><div class="line">       float: double, single</div><div class="line">       integer: uint8, int8, uint16, int16, uint32,</div><div class="line">                int32, uint64, int64</div><div class="line"> </div><div class="line">    See also median, std, min, max, var, cov, mode.</div><div class="line"></div><div class="line">    Reference page <span class="keyword">for</span> mean</div><div class="line">    Other functions named mean</div></pre></td></tr></table></figure></p>
<p>我们可以看到，在使用help指令以后，命令行窗口打印出来了一段关于mean函数的描述。包括函数作用的概述（Average or mean value），函数的使用方法，每一个输入和输出函数的作用等等，非常的详尽。最后还给出了使用的例子，相当于一个电子版的API（Application Programming Interface）速查手册,非常之方便。<br>还可以看到后面有一行 See also…，这是MATLAB为你推荐的其他相关的函数，对于mean来说，包括了中位数函数median，标准差std，最大值与最小值，方差，协方差和众数mode函数，对于学习和了解更多命令非常有帮助。<br>然后是Reference page for mean这个超链接，点击以后来到一个类似于网页的东西，里面提供了更为详尽的关于mean函数的内容，非常有用，这个效果和直接使用<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">doc mean</div></pre></td></tr></table></figure></p>
<p>是相同的，在文档里面查看函数的用法，界面更加漂亮好看，内容也更加丰富。这个文档在MATLAB的官方网站上也是提供的。MATLAB的某些版本可能不提供本地的doc文档。<br>最后还有一个很重要的是Other functions named mean，这意味着mean函数在MATLAB中不止有一个。还记得前面我们说的MATLAB搜寻函数的方式吗？MATLAB先在内部的路径列表中依次寻找你输入的指令，用找到的第一个作为指令的解析方式。但是，如果这个指令不是你需要的呢？这个时候就可能造成错误。如果你发现你使用的指令输出的结果与你预想的不同，那么请输入<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt; help 指令名</div></pre></td></tr></table></figure></p>
<p>来检查MATLAB是否是使用了你需要的指令，如果没有，请点击Other functions named 指令名 来寻找想要的指令吧！</p>
<h4 id="多说几句"><a href="#多说几句" class="headerlink" title="多说几句"></a>多说几句</h4><p>写到这里，基本上这篇文章也该结束了。但是还想说些乱七八糟的东西。譬如说玩到现在，你的命令窗口和workspace应该已经很乱了吧，这个时候可以执行<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt; clc</div></pre></td></tr></table></figure></p>
<p>来清空命令行窗口中的东西。还可以使用<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt; clear all</div></pre></td></tr></table></figure></p>
<p>来清空工作区间中的东西。<br>另外，总有人问我说怎么样才能更快更好的学习编写代码，我自己的经验是一定要上手实际的去写命令，实现一定的功能，也就是实战啦。编程是一门实践性很强的技术，即使是有经验的程序员，如果长时间不写代码一定会手生的，所以请多加练习吧（日语翻译风）！<br>从下一节开始，我将以解决实际问题的角度来教大家写一个函数。程序中的函数和数学上的函数有一定的联系但是也有很大的差异。程序中的函数是指一段可以重复调用的，接受输入或者不接受输入，按照一定的顺序进行运算的代码段，函数的使用可以减少编码中重复的编写相同的逻辑，还可以通过函数名的命名提高程序的可读性。<br>我自己喜欢写程序的一个原因就是每次调用自己写好的函数的时候都特别有成就感。函数将具体的实现过程隐藏起来，使你可以很方便的使用它所有的功能。就好比你做了一个好用的工具，每次干活的时候用你的工具来做，特别方便好用，固然是有成就感。看起来枯燥的编码就是将复杂的问题分解为一个个简单的小功能，再把每个小功能用函数实现，每一步都伴随着一点点的成就感。最后再将这些函数按照算法的逻辑组合调用，就形成了复杂神奇的程序。<br>说了这么多，是不是也变得期待起来了呢？我们下次再见吧！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2017/04/20/三面骰/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2017/04/20/三面骰/" itemprop="url">三面骰</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-20T15:39:07+08:00">
                2017-04-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/闲谈/" itemprop="url" rel="index">
                    <span itemprop="name">闲谈</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>近日看了一本书叫做《白话大数据与机器学习》，里面有一句话说的很有意思。具体是什么忘了，书也不在身边。大概就是说世上没有三个面的骰子。我觉得很有意思，世界上真的没有三面的骰子吗？不知道读者会作何解答。你可以想一想在往下看。<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>
<p><div align="center"><br><img src="http://i1.piimg.com/567571/6bce6162786d0d97.jpg" alt="“三面骰”"><br></div><br>这是我给出的解答，我用3ds max渲染的三面骰，还不错吧？不过这个骰子是“哪个面朝下，投出的数字就是哪个”。是不是很蛋疼？快给出你觉得更好的三面骰吧！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/HansenZhao.github.io/page/2/">2</a><a class="extend next" rel="next" href="/HansenZhao.github.io/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/HansenZhao.github.io/images/zhs.png"
                alt="Hansen Zhao" />
            
              <p class="site-author-name" itemprop="name">Hansen Zhao</p>
              <p class="site-description motion-element" itemprop="description">Machine Learning & Coding</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/HansenZhao.github.io/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/HansenZhao.github.io/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/HansenZhao" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="zhaohs12@163.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hansen Zhao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/HansenZhao.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/HansenZhao.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/HansenZhao.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/HansenZhao.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/HansenZhao.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/HansenZhao.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/HansenZhao.github.io/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/HansenZhao.github.io/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/HansenZhao.github.io/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
