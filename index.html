<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/HansenZhao.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/HansenZhao.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/HansenZhao.github.io/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/HansenZhao.github.io/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/HansenZhao.github.io/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/HansenZhao.github.io/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/HansenZhao.github.io/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Machine Learning &amp; Coding">
<meta property="og:type" content="website">
<meta property="og:title" content="HansenZhao&#39;s Blog">
<meta property="og:url" content="https://hansenzhao.github.io/index.html">
<meta property="og:site_name" content="HansenZhao&#39;s Blog">
<meta property="og:description" content="Machine Learning &amp; Coding">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HansenZhao&#39;s Blog">
<meta name="twitter:description" content="Machine Learning &amp; Coding">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/HansenZhao.github.io/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://hansenzhao.github.io/"/>





  <title>HansenZhao's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/HansenZhao.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HansenZhao's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Share with ZhuangBiology</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/HansenZhao.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/HansenZhao.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/HansenZhao.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2018/03/31/什么是科学/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2018/03/31/什么是科学/" itemprop="url">什么是科学：梳理与问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-31T18:30:00+08:00">
                2018-03-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/General-Science/" itemprop="url" rel="index">
                    <span itemprop="name">General Science</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>什么是科学呢？我们常常谈论科学，并且常常断言什么是科学的，什么不是科学的。仿佛在这一个问题上我们已经默契的达到了一种心照不宣的标准。可是，如果问起来到底什么是科学，什么不是，有没有一个准确的定义呢？<br>我们不能够以形式化的方式定义科学。例如，用实验仪器和数学方法的就是科学，没有用实验仪器和数学方法的就不是科学。须知实验仪器与数学方法只是工具，用工具或者说形式来定义我们的行为目标，容易导致故步自封。即使实验仪器和数学方法就是科学的必要条件，我们也必须正本清源，明白到底为什么他们能够成为科学的代名词。为了能够理解科学的本源，思考科学到底是什么，是非常必要的。</p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>科学的存在是基于一个基本的逻辑的，这个逻辑就是，自然（物质世界）是运动的，运动是有规律的，规律是可以被人类掌握的。如果这个逻辑不成立，那么我们科学的存在就没有必要。首先，自然是运动的，意味着自然是不断演化的，正因为如此，我们才有必要掌握甚至控制这种变化，已达到我们生存和发展的目的。如果自然的发展停滞了（如同热寂理论描述的那样），科学的存在也就没有意义了。于此同时，我们也必须假设运动是有规律的，如果没有特定的规律，那么我们主动的学习和改造也就没有了意义，正能剩下听天由命。 运动的规律性要求科学的结论和实验必须是可重复的。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>我们现在常常喜欢用客观和主观将物质实际与人分离。这是一种基于对人的不信任产生的，人的观察和判断常常受到干扰，因而是不准确的，也是不可重复的，因此一直以来在科学的方法学上被人避之不及。那么，是否存在一种科学，完全客观，完全没有人的参与呢？ 我们可以设想一个“科学机器人”，其行为完全受到某个程序操控，严谨的研究和操控自然，这是不是一种“无人的科学”呢？ 如果这也算是科学的话，那么可以说这种“终极科学”就在我们的身边。因为这个“科学机器人”实际上就是自然本身。自然本身是物质客观，永远遵循着一定的规律运动，自然本身不就是这个“科学机器人”么？ 其实，“自然”这个词就具有非常深刻的哲学观点：“自”就是没有人的意思，就是不受干扰的，完全客观的意思；“然”就是“本来就这样”的意思，蕴含着规律无因无果，不可变更的意思。</p>
<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>从这个角度讲，科学必须是有人参与的。实际上，科学就是对人类的一种活动的描述，是人类主动的认识和改造自然的活动。光合作用产生氧气，神经系统帮助我们活动，思考，这些过程都为人类的生存和发展提供了巨大的助力，但是它们并不是人类主动追求的，是“自然”这样的，因此不算是科学。<br>科学是的活动，主要包含三个过程：</p>
<ol>
<li>观察和记录</li>
<li>描述和理解</li>
<li>预测和工程<br>其中，观察和记录是第一步，是对物质世界的变化和现象的观察和记录。这些变化和现象关系到人类的生存和发展，有的时候，仅仅是因为好奇，总之，我们观察到了，需要将其记录下来。基于上面提到的基本逻辑，我们希望对现象的原因，本质进行理解，并且对现象进行描述，因为现象可能重复的发生，以及我们需要相互交流，将知识不断的传递和积累。最后，我们希望在描述和理解的基础上，对物质世界的变化进行预测，以及通过施加扰动控制其发展的方式，以更好的实现人类的生存和发展。这整个过程，就是科学的过程。 我们期望这个过程是可重复的，可理解的，这样才符合上述我们对科学存在意义提出的基本逻辑。凡是不可重复不可理解的，我们就不认为其为科学。</li>
</ol>
<h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>科学的方法是实现前面说的三个过程的具体方法论。随着时代的进步，科学在这三个过程中的方法有很大不同。最早我们观察和记录的方式就是通过我们的身体，用眼睛，鼻子等感官去观察，用记忆去记录这些观察。在这样的上古时代，科学还没有产生，科学的后两个过程也都无从谈起。<br>从壁画到文字，我们有了更好的记录方式。相比于记忆，壁画和文字更方便进行种群内的交流，也更加持久。以此为基础，描述和理解开始变成可能。语言成为描述物质世界的绝对唯一的方式。由于时代的限制，神话传说成为对物质世界现象和变化的理解的重要方式。从天气、气候变化，地理的形成，人的生老病死，世界各个角落的人类都不约而同的发展了神话体系来进行理解和解释。巫术也形成了，人类在预测自然和人类社会发展，以及对自然体系的干预（主要是生老病死）的需求是如此的强烈。</p>
<h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>神话，巫术今天不被认为是科学，主要是其不符合我们前面说的科学的基本逻辑。神话中神灵对世界的改造和控制，不是一个令人满意的解释。因为其意味着存在人类不能掌握的规律。巫术则因为可重复性太差导致被时代抛弃。随着语言，文字的发展，以及社会生产力的进步，大量的专职从事文化，记录事业的个体出现。人类积累了大量对自然的描述和观察。这个时候，出现了早期的唯物哲学和相应的对世界的解释。元素理论是出现非常频繁的一种体系。将世界运行的本源归结为物质的相互作用，而纷繁复杂的物质在本质上都是由有限数量的简单元素组成。这样的理论即使在今天看来，也不无道理。以周易为基本理论的发展的古中国科学体系，涉及医药，健康，政治，军事，建筑等多个领域，绵延了数千年，即使到今天，还有很多信徒。 朴素唯物哲学以及其科学理论，首次的将物质世界的变化与人类社会和精神分离。从自然规律的角度，而非是神的意识出发解释自然，具有非常重要的意义。由于其发展伴随着语言和文字的高度发展，大量相对客观的自然规律被记录下来，因此相应的理论在解释，甚至预测物质世界变化上具有一定的意义。</p>
<h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p>近代以来，朴素的唯物哲学及其科学方法，让位于一个直到今天仍然是最为主流的现代科学方法，就是以实验和数学为主要方法的。在上述的科学的三个过程中，现代科学使用检测器来对物质世界进行观察，使用数字信号对现象进行记录。使用数学公式和物理模型对自然变化进行描述和理解，最终使用数学计算对体系进行预测和工程扰动。相比于朴素的唯物方法，现代的科学方法更加客观真实，可重复性好，在预测和工程方面更是有无与伦比的优势。因此直到今天，这种方法仍然是最为广泛使用的方法，甚至是被认为是科学的代名词。</p>
<h3 id="8"><a href="#8" class="headerlink" title="8"></a>8</h3><p>在这个体系下，物质世界的变化为认为是客观的，遵循规律运动的。但是物质世界这么纷繁复杂，如何才能观察和记录这些变化呢？我们寻找到一个特殊的客观的体系，这个体系与大部分自然体系能够相互作用，并且这种作用是已知的。我们用这个特殊的客观体系与我们需要观测的体系进行作用，将目标体系的变化，统一的转化为我们已知的，主观选择的体系的变化。这个我们选择的特殊物质体系就是检测器。我们太不信任人类本身了，因此用在研究一个客观实在的时候，要用另一个被选中的客观实在去与其相互作用。相互作用的结果，被另一个客观的东西记录下来，就是数字信号。<br>接下来，人类的主观意识首次登场，将记录下来的数字信号转换为研究结论，以及物理模型。由于有人的意识的参与，大家还都不放心，需要重新用实验数据验证物理模型才可以。最后，我们可以通过物理模型和数学计算的方式对体系进行预测和有意识的干预。</p>
<h3 id="9"><a href="#9" class="headerlink" title="9"></a>9</h3><p>这套方法一直以来都没有问题，但是随着科学技术的发展，人类感兴趣的体系也越来越多。现代的科学方法就出现了很多问题。在物理中的多体问题，混沌体系等问题上，数学公式难以获得解析解，对体系的预测遇到了很大的困难。在生态，生物，社会等领域中，我们难以理解和描述非平衡状态下的，多因素相互作用的问题。这些是生物以及医疗技术发展迟滞的主要原因之一。元胞自动机的发明者Wolfram在自己的书《A New Kind of Science》中质疑了数学描述的方法是否存在极限，是否真的能完整的描述所有观察到的现象？</p>
<h3 id="10"><a href="#10" class="headerlink" title="10"></a>10</h3><p>由这个问题引申出来，数学模型与数学公式对于自然体系的描述是否是有极限的？如果有，这个极限在哪里？这个极限是本征的存在的，还是因为我们数学的描述方法导致的？换句话说，通过发展数学中的某个特定的领域，是否能解决上面的问题？</p>
<h3 id="11"><a href="#11" class="headerlink" title="11"></a>11</h3><p>前面提到文字和语言的高度发展为科学方法的进步带来了新的契机。今天，数据信号的收集和记录也获得了极大的发展，也就是我们常说的大数据时代。今天，实验室获取数据的效率大大的提升，但从数据中如何获得有意义的信息却成为了问题。因此，很多相关领域的学者提出了数据科学的概念。我们回到刚才说的现代科学的方法中。我们用数字信号带体系的变化进行描述后，下一步是使用物理模型和数学公式进行进一步的总结和归纳。但是在数据科学的方法中，我们可以使用特定的算法从数据中学习到一个数据模型。这个数据模型本质上仍然是科学的过程中的第二个，对体系的描述和理解，的范畴，但是它与现代科学中的物理模型不同，它是建立在数据之上而非是物理意义之上的。这样的模型同样也用于预测——实际上这是数据科学的商业应用的主要目标。或者说，数据科学的产生，就是在商业应用需求激增而传统的现代科学方法无法满足之间的矛盾中产生的。 毕竟，并没有那个数学模型可以帮助我预测一个人还款的意愿和能力；即使有，其效果也远远差与于数据科学的方法。</p>
<h3 id="12"><a href="#12" class="headerlink" title="12"></a>12</h3><p>尽管在商业上受到热捧，但是在学界中，数据科学的地位还远远没有现代科学的地位高。这是因为，数据科学的核心，数据模型在科学的三个过程中的第二个，描述和理解，上做的特别不好。尽管我们可以通过数据学习来获得一个很准确的预测个人贷款后还款能力和意愿的模型，但这个数据模型并不能告诉我到底是为什么一个人能或者不能还上贷款。尽管特征的权重可以帮助我了解到哪些个人信息对于结果的影响更大，但是这种关联性并不能构成因果性。我们在理解自然发生的事件时，总是希望其存在因果性，而且这个因果性最好还是线性的。但更有可能的是，线性因果性可能只存在于很少数的简单体系中，就是牛顿力学研究的那些体系。实际上大部分的现实体系都是网状结构的。</p>
<h3 id="13"><a href="#13" class="headerlink" title="13"></a>13</h3><p>网状结构，非线性关系预示着线性的因果关系可能并不是广泛存在的。但是，数据科学中的数据模型仍然不能令人满意。因为它脱离体系本身，太过于抽象，以至于不能对人的理解提供一个自然运动过程的图景。 基于计算机模拟的规则模型也是一个重要的发展方向。规则模型并不是面向对体系的数学描述建立的，而是面向体系中的部分所遵循的规则建立的。尽管这个规则仍然是使用数学描述，但是规则模型并不试图对体系整体进行解析的数学描述，而是仅仅描述系统部分相互之间的运动，而后使用计算模拟的方式描述和预测系统的发展。这种方式提供的模型更容易被人类理解，并且已经得到了广泛的研究和应用。</p>
<h3 id="14"><a href="#14" class="headerlink" title="14"></a>14</h3><p>要使得基于规则模型的科学方法得到更广泛的承认和发展，就必须要问一个问题：规则模型的科学方法，能否解决经典的牛顿物理问题？就如同现代科学方法一样。尽管前者已经被广泛的用于复杂的社会学和生态学研究中，但是很少有人研究其在简单物理体系中的应用范式，如果答案是肯定的，将会是一个颠覆性的成果。</p>
<h3 id="15"><a href="#15" class="headerlink" title="15"></a>15</h3><p>最后一个问题就是，如何看待一个复杂体系与另一个复杂体系的相互作用？这个问题的实质是，人类是否能够理解复杂体系的自然现象，当我们将人本身看成一个复杂体系的时候。在Wolfram的书中，他提出的计算等价性原理，并对上述问题作出了肯定的回答。但我认为这个问题的答案还需要进一步探究。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2018/03/11/Scientific Writing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2018/03/11/Scientific Writing/" itemprop="url">科学论文写作金句不定期整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-11T13:00:00+08:00">
                2018-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/General-Science/" itemprop="url" rel="index">
                    <span itemprop="name">General Science</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="令人惊奇的结果"><a href="#令人惊奇的结果" class="headerlink" title="令人惊奇的结果"></a>令人惊奇的结果</h3><blockquote>
<p>Rather than getting a simple regular pattern as we might expect, the cellular automaton instead produces a pattern that seems extremely irregular and complex —- A New Kind of Science</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2018/03/11/Notes of A new kind of science-03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2018/03/11/Notes of A new kind of science-03/" itemprop="url">Notes of A new kind of Science-03</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-11T13:00:00+08:00">
                2018-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/General-Science/" itemprop="url" rel="index">
                    <span itemprop="name">General Science</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Chapter-03-The-World-of-Simple-Programs"><a href="#Chapter-03-The-World-of-Simple-Programs" class="headerlink" title="Chapter 03: The World of Simple Programs"></a>Chapter 03: The World of Simple Programs</h2><h3 id="The-search-for-general-feature"><a href="#The-search-for-general-feature" class="headerlink" title="The search for general feature"></a>The search for general feature</h3><h4 id="What-Cellular-Automata-do"><a href="#What-Cellular-Automata-do" class="headerlink" title="What Cellular Automata do"></a>What Cellular Automata do</h4><ul>
<li>pure repetition</li>
<li>overall regular</li>
<li>complex</li>
</ul>
<h4 id="三色元胞自动机"><a href="#三色元胞自动机" class="headerlink" title="三色元胞自动机"></a>三色元胞自动机</h4><ul>
<li>使得每个单元可以有黑，灰，白三种状态，可能存在的规则数量大大的增加了。但其表现的复杂行为与更简单的自动机没有本质的差异</li>
</ul>
<h3 id="Mobile-Automata"><a href="#Mobile-Automata" class="headerlink" title="Mobile Automata"></a>Mobile Automata</h3><h4 id="元胞自动机中复杂特征的产生是常见的，但是在每次更新一个元胞的mobile-automata中，复杂图样的产生变得非常稀少。"><a href="#元胞自动机中复杂特征的产生是常见的，但是在每次更新一个元胞的mobile-automata中，复杂图样的产生变得非常稀少。" class="headerlink" title="元胞自动机中复杂特征的产生是常见的，但是在每次更新一个元胞的mobile automata中，复杂图样的产生变得非常稀少。"></a>元胞自动机中复杂特征的产生是常见的，但是在每次更新一个元胞的mobile automata中，复杂图样的产生变得非常稀少。</h4><blockquote>
<p>Despite the fact that mobile automata update only one cell at a time, it is thus still possible for them to produce behavior of great complexity. But while we found that such behavior is quite common in cellular automata, what we have seen in this section indicates that it is rather rare in mobile automata.</p>
</blockquote>
<h4 id="generalized-moile-automata"><a href="#generalized-moile-automata" class="headerlink" title="generalized moile automata"></a>generalized moile automata</h4><blockquote>
<p>One can get some insight into the origin of this difference by studying a class of generalized mobile automata, that in a sense interpolate between ordinary mobile automata and cellular automata.</p>
<p>The basic idea of such generalized mobile automata is to allow more than one cell to be active at a time. And the underlying rule is then typically set up so that under certain circumstances an active cell can split in two, or can disappear entirely.</p>
<p>But looking at many examples, a certain theme emerges: complex behavior almost never occurs except when large numbers of cells are active at the same time</p>
</blockquote>
<h3 id="图灵机"><a href="#图灵机" class="headerlink" title="图灵机"></a>图灵机</h3><ul>
<li>相比于元胞自动机，图灵机的模型包含了拥有两个状态的元胞和不同状态的磁头。下一个回合的状态仅仅与当前元胞的状态和磁头的状态有关，而与其附近的元胞状态无关。</li>
<li>2元胞状态和2磁头状态的图灵机中出现了周期纹样和嵌套纹样，但没有发现复杂纹样</li>
</ul>
<blockquote>
<p>Both repetitive and nested behavior are seen to occur, though nothing more complicated is found.</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2018/03/08/Fun-with-your-first-Day-with-Matlab-S02E01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2018/03/08/Fun-with-your-first-Day-with-Matlab-S02E01/" itemprop="url">Fun with your first daty with Matlab S02E01</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-08T20:00:00+08:00">
                2018-03-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/MATLAB/" itemprop="url" rel="index">
                    <span itemprop="name">MATLAB</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="元胞自动机模拟程序"><a href="#元胞自动机模拟程序" class="headerlink" title="元胞自动机模拟程序"></a>元胞自动机模拟程序</h2><p>元胞自动机是复杂系统研究的经典模型。直至今天，仍然引起研究者的广泛兴趣。大名鼎鼎的“生命游戏”也是元胞自动机的一种。这种模型生动的展示了即时简单的规则的组合也能在不断的演化中产生复杂的行为。这一现象的发现人，mathmatica软件的开发者Stephen Wolfram在他写的<a href="http://www.wolframscience.com/nks/" target="_blank" rel="external">畅销书</a>中盛赞这种体系是新科学（A new kind of science)的开端。<br>尽管元胞自动机看起来逼格满满，实际上非常简单。我们可以使用MATLAB轻而易举的编写一个元胞自动机模拟的软件。<br>本文的最终程序请见 <a href="https://github.com/HansenZhao/HSToolkit/blob/master/cellularAuto.m" target="_blank" rel="external">Github</a></p>
<h3 id="元胞自动机的原理"><a href="#元胞自动机的原理" class="headerlink" title="元胞自动机的原理"></a>元胞自动机的原理</h3><p>本文仅介绍一维元胞自动机的原理，了解以后，拓展到更高维度就很容易了。<br>首先，所谓元胞，是指在一个模拟的空间中生成彼此相邻的格子，每一个格子都代表一个元胞。每一个元胞都有两个状态——生或者死，也即0或者1。元胞的状态随着时间变化，下一个回合每个元胞的状态取决于上一个回合这个元胞的状态以及其相邻的元胞状态。我们可以看到，元胞自动机在时间上和空间上都是离散的。<a href="http://mp.weixin.qq.com/s/i5x4J7806n9whTEuD5nFiQ" target="_blank" rel="external">现代科学的研究</a>也支持我们生活的世界在极为微小的尺度上是离散的而非连续的,难怪Wolfram要在自己写的书中洋洋得意了。<br>元胞自动成为复杂系统研究的经典模型还有一大因素，就是它在最简单的体系中表达了复杂系统的共性特征：相互作用个体通过简单的规则，形成复杂的整体行为<br>元胞自动机的规则就是前面提到的，下一个回合的状态是如何由上一个时刻的状态决定的。我们知道，影响下一个回合的某个元胞的状态的因素有两个：这个元胞本身状态以及其左邻右舍的状态。那么，所有可能的状态有几个呢？因为我们只考虑紧密相邻的元胞之间的相互影响，因此实际上是三个相邻的元胞状态决定下一个回合的某个元胞的状态。由于每个元胞的状态只有0和1两种情况，因此只有$2^{3}$八种可能的状态。对于八种可能的原始状态，我们完全可以枚举可能的下一个回合的状态，因此对应于每一种原始状态，在规则设定上，下一个回合都有可能是0或者1，因此规则的个数一共有$2^{8}=256$中可能的规则。<br>例如我们可以设定某一个规则，对于上一回合任何情况，除非三个相邻的元胞自动机都为0时，下一个时刻的元胞才为0。否则，下一个时刻的元胞状态为1。我们可以通过表格表示这个规则：</p>
<table>
<thead>
<tr>
<th>上一回合状态</th>
<th style="text-align:center">111</th>
<th style="text-align:center">110</th>
<th style="text-align:center">101</th>
<th style="text-align:center">100</th>
<th style="text-align:center">011</th>
<th style="text-align:center">010</th>
<th style="text-align:center">001</th>
<th style="text-align:right">000</th>
</tr>
</thead>
<tbody>
<tr>
<td>下一回合状态</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:right">0</td>
</tr>
</tbody>
</table>
<p>我们约定在写这张表的时候，上一个时刻的状态组合按照二进制的大小顺序来书写，因此在上面的表格中，上一个回合的状态分别的$7<em>{(2)}$（也就是二进制的111转换为十进制为7）,$6</em>{(2)},5<em>{(2)},4</em>{(2)},3<em>{(2)},2</em>{(2)},1<em>{(2)},0</em>{(2)}$八个二进制数字。下面的状态组合，形成一个八位的二进制数字$1111 1110$。这个二进制数字是多少呢？254。因此，这个规则就被称为254规则。 在Wolfram书中，这个规则有一个很形象的表示：<br><img src="http://oyeuye83q.bkt.clouddn.com/18-3-8/89773590.jpg" alt=""><br>我们可以使用一个二维数组来表示元胞自动机在每一个回合的状态。数组中的0或者1表示相应元胞的状态，数组的行表示每一代元胞自动机的状态组合，不同的行代表了不同代的交替。这样就可以在二维的平面上表示一维的元胞自动机的演化过程了。</p>
<h3 id="元胞自动机的MATLAB编程"><a href="#元胞自动机的MATLAB编程" class="headerlink" title="元胞自动机的MATLAB编程"></a>元胞自动机的MATLAB编程</h3><p>首先，我们要确认模拟一个元胞自动机需要哪些参数。首先，模拟时遵循的规则需要给出。其次，模拟的一维世界的长度必须给出，模拟的步数，初始条件也是必要的。除此之外，还有一个重要的参数，就是元胞自动机如何处理边界条件。<br>我们上面讨论的时候，假设了每一个元胞都有两个相邻的邻居。但是模拟的世界大小是有限的，在一维世界的边界处，左边界的元胞没有左邻局；右边界的元胞没有右邻居。应该怎么办呢？常见的解决方法有三种：</p>
<ul>
<li>常数补充：将缺失的邻居补充为0或者1</li>
<li>扩展补充：将缺失的邻居补充为自己本身</li>
<li>卷曲补充：想象一维世界是一个环，那么左边界的左邻局其实就是右边界，反之亦然。</li>
</ul>
<p>因此，我们需要一个参数来设定世界边界的补充方式<br>最后，我们设定一个参数来确定是否模拟完成就把结果显示出来。</p>
<h4 id="MATLAB中的参数检测"><a href="#MATLAB中的参数检测" class="headerlink" title="MATLAB中的参数检测"></a>MATLAB中的参数检测</h4><p>MATLAB中的函数是输入一个或者几个参数，返回结果的东西。函数相比于脚本，将参数的设置与计算逻辑隔离开来，从而更容易让程序得到复用。MATLAB中的函数的书写格式一般是这样的：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="params">[返回值]</span> = 函数名<span class="params">(参数1，参数2...)</span></span></div><div class="line">    函数体（处理逻辑）</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>其中，函数体的部分与脚本的书写基本一致。返回值的数值在函数体内部被赋值完成。<br>我们前面提到，元胞自动机的参数一共有6个。想象一下如果每次我们用这个函数都需要输入6个参数，是不是很麻烦。因此，我们可以在函数体内对参数的存在与否进行检测，如果用户赋值了，就按照用户的赋值来，如果用户没有赋值，我们就给予默认值。这样的话，用户在不必要的时候就不需要给定赋值了。我们看这部分的代码：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ histArray ]</span> = <span class="title">cellularAuto</span><span class="params">( rules,len,steps,init,world,isShow )</span></span></div><div class="line">    <span class="comment">% 规则编号</span></div><div class="line">    <span class="keyword">if</span> ~exist(<span class="string">'rules'</span>,<span class="string">'var'</span>) <span class="comment">%检查是否存在叫rules的变量，如果没有就赋值为110</span></div><div class="line">        rules = <span class="number">110</span>;</div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="comment">% 一维世界长度</span></div><div class="line">    <span class="keyword">if</span> ~exist(<span class="string">'len'</span>,<span class="string">'var'</span>)</div><div class="line">        len = <span class="number">21</span>;</div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="comment">% 模拟回合数</span></div><div class="line">    <span class="keyword">if</span> ~exist(<span class="string">'steps'</span>,<span class="string">'var'</span>)</div><div class="line">        steps = <span class="number">100</span>;</div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="comment">% 原始赋值</span></div><div class="line">    <span class="keyword">if</span> ~exist(<span class="string">'init'</span>,<span class="string">'var'</span>)</div><div class="line">        init = randi(<span class="number">2</span>,[<span class="number">1</span>,len])<span class="number">-1</span>;</div><div class="line">    <span class="keyword">elseif</span> <span class="built_in">size</span>(init,<span class="number">2</span>)~= len</div><div class="line">        <span class="comment">% 如果原始赋值向量长度与设定一维世界长度不同，报错退出</span></div><div class="line">        error(<span class="string">'Init condition size: %d is not equal to the length: %d\n'</span>,<span class="built_in">size</span>(init,<span class="number">2</span>),len);</div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="comment">% 边界处理模式</span></div><div class="line">    <span class="keyword">if</span> ~exist(<span class="string">'world'</span>,<span class="string">'var'</span>)</div><div class="line">        world = <span class="string">'zero'</span>;</div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="comment">% 是否展示结果</span></div><div class="line">    <span class="keyword">if</span> ~exist(<span class="string">'isShow'</span>,<span class="string">'var'</span>)</div><div class="line">        isShow = <span class="number">1</span>;</div><div class="line">    <span class="keyword">end</span></div><div class="line">    ..........</div></pre></td></tr></table></figure></p>
<p>我们命名了一个叫做$cellularAuto$的函数，拥有6个输入参数，1个输出结果$histArray$。这个结果就是上面说的表示元胞自动机演化过程的二维数组。这里使用的是$exist$函数检测是否存在特定的变量。</p>
<h4 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h4><p>我们首先生成一个矩阵保存结果，同时也是函数的输出值<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">histArray = [init;zeros(steps<span class="number">-1</span>,len)];</div></pre></td></tr></table></figure></p>
<p>这里直接建立了一个二维数组。数组的第一行是用户指定的或者随机生成的一维01序列；后面的模拟回合数-1行一开始全部填充为0。然后我们对规则进行一定的前处理。前面说到的11111110规则也即254规则是通过将8位的二进制转化为10进制得到的。因此我们在程序中首先要对10进制的规则编号重新转化为原来的8位二进制。我们首先将规则编号转化为8位的数字<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rules = uint8(rules);</div></pre></td></tr></table></figure></p>
<p>我们将rules通过$uint8$函数转化为了无符号的8位整数。那么，想要取得每一个上一回合组合对应的下一个回合应该的状态，我们可以寻找这个8位整数对应的二进制位的数值。例如，我想知道在这个规则下，上一个回合是111的时候，这个回合应该存在的状态，我们可以寻找这个规则（254规则）的第8位上的数字。如何实现呢？使用的是$bitget$函数。$bitget$函数接受两个参数，第一个参数是一个数字，第二个参数是位的编号。比如我想知道254号的第8位是多少，只需要使用<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bitget(<span class="number">254</span>,<span class="number">8</span>)</div><div class="line"><span class="built_in">ans</span> = <span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>即可。其中，第二个参数也可以是矩阵，我们因此可以批量的进行这个操作。另外，这里面还有一点窍门。例如上一个回合的状态是111，那么上一个时刻的状态的10进制表示就是7，正好是对应的检索位数（8）减去1的结果。这个窍门成立的原因就是我们前面严格的约定了规则表格的书写方式。<br>下面，我们可以很简单的想到可以通过一个循环语句来进行模拟，每次模拟一步<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> m = <span class="number">2</span>:<span class="number">1</span>:steps</div><div class="line">    模拟一步......</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>那么每一步怎么模拟呢？我们首先针对world参数的赋值，补全上一个回合的边界状态<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">tmp = histArray(m<span class="number">-1</span>,:); <span class="comment">%将上一个回合的状态取出</span></div><div class="line"><span class="keyword">switch</span> world</div><div class="line">    <span class="keyword">case</span> <span class="string">'zero'</span></div><div class="line">        tmp = [<span class="number">0</span>,tmp,<span class="number">0</span>]; <span class="comment">%边界补0</span></div><div class="line">    <span class="keyword">case</span> <span class="string">'one'</span></div><div class="line">        tmp = [<span class="number">1</span>,tmp,<span class="number">1</span>]; <span class="comment">%边界补1</span></div><div class="line">    <span class="keyword">case</span> <span class="string">'extend'</span></div><div class="line">        tmp = [tmp(<span class="number">1</span>),tmp,tmp(end)]; <span class="comment">%边界扩展</span></div><div class="line">    <span class="keyword">case</span> <span class="string">'wrap'</span></div><div class="line">        tmp = [tmp(end),tmp,tmp(<span class="number">1</span>)]; <span class="comment">%边界卷曲</span></div><div class="line">    <span class="keyword">otherwise</span></div><div class="line">        tmp = [<span class="number">0</span>,tmp,<span class="number">0</span>];</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>由于上一个回合的状态本身就是一个行向量，因此我们补全的过程就是给行向量的头和尾扩展一个元素。这里面使用了一个MATLAB的语法糖（就是语法中为开发者提供的便利语法）。在对向量进行索引的时候，end表示最后一个元素。<br>补充完上一个回合的边界状态以后，我们想要得到每一个对应位置的状态。这个地方比较抽象，我们假设一个简单的情况。例如上一个状态是 1 1 0 1 0，我们采用全0补全以后，变成了0 1 1 0 1 0 0。这是一个1x7的行向量。那么，对应下一个时刻的第一个元胞的状态就是 0 1 1，第二个就是 1 1 0。下一个回合第一个元胞对应上一个时刻【补充以后的元胞组】的索引是1,2,3；第二个就是2,3,4。是不是发现了规律了呢？我们可以直接将上一个时刻补充后元胞状态组1x7的向量转化为3x5的矩阵。其中每一列是对应位置的上一个时刻的状态。<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mat = [tmp(<span class="number">1</span>:(end<span class="number">-2</span>));tmp(<span class="number">2</span>:(end<span class="number">-1</span>));tmp(<span class="number">3</span>:end)];</div></pre></td></tr></table></figure></p>
<p>根据这样的操作，补充后的0 1 1 0 1 0 0数组就会变成这样的一个矩阵</p>
<table>
<thead>
<tr>
<th>0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">1</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td>1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<p>看，是不是第一列对应了第一个位置上一回合的状态，第二列对应了第二个位置上一回合的状态？下一步，我们需要从这个矩阵中获取8位规则的索引。上面提到的111的索引是$7+1=8$。实际上，就是$1<em>2^2+1</em>2^1+1*2^0+1=8$因此，我们只要将上面的矩阵的第一列乘以4，第二列乘以2最后一列乘以1最后再每列求和再加1就好。这样的操作就是：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">condition = sum(mat.*<span class="built_in">repmat</span>([<span class="number">4</span>;<span class="number">2</span>;<span class="number">1</span>],<span class="number">1</span>,len))+<span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>这里的repmat函数将[4;2;1]列向量在重复铺展了1行len这么多列，目的是使得其大小与mat变量大小一致，才能进行按位乘的矩阵操作。最后使用前面说的$bitget$函数查找出来这个时刻应该的状态,就好了，并赋值到histArray的相应位置就好了。<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">res = bitget(rules,condition);</div><div class="line">histArray(m,:) = res;</div></pre></td></tr></table></figure></p>
<p>全部的代码是这样的:<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ histArray ]</span> = <span class="title">cellularAuto</span><span class="params">( rules,len,steps,init,world,isShow )</span></span></div><div class="line">    <span class="keyword">if</span> ~exist(<span class="string">'rules'</span>,<span class="string">'var'</span>)</div><div class="line">        rules = <span class="number">110</span>;</div><div class="line">    <span class="keyword">end</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ~exist(<span class="string">'len'</span>,<span class="string">'var'</span>)</div><div class="line">        len = <span class="number">21</span>;</div><div class="line">    <span class="keyword">end</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ~exist(<span class="string">'steps'</span>,<span class="string">'var'</span>)</div><div class="line">        steps = <span class="number">100</span>;</div><div class="line">    <span class="keyword">end</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ~exist(<span class="string">'init'</span>,<span class="string">'var'</span>)</div><div class="line">        init = randi(<span class="number">2</span>,[<span class="number">1</span>,len])<span class="number">-1</span>;</div><div class="line">    <span class="keyword">elseif</span> <span class="built_in">size</span>(init,<span class="number">2</span>)~= len</div><div class="line">        error(<span class="string">'Init condition size: %d is not equal to the length: %d\n'</span>,<span class="built_in">size</span>(init,<span class="number">2</span>),len);</div><div class="line">    <span class="keyword">end</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ~exist(<span class="string">'world'</span>,<span class="string">'var'</span>)</div><div class="line">        world = <span class="string">'zero'</span>;</div><div class="line">    <span class="keyword">end</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ~exist(<span class="string">'isShow'</span>,<span class="string">'var'</span>)</div><div class="line">        isShow = <span class="number">1</span>;</div><div class="line">    <span class="keyword">end</span></div><div class="line">    </div><div class="line">    histArray = [init;zeros(steps<span class="number">-1</span>,len)];</div><div class="line">    rules = uint8(rules);</div><div class="line">    <span class="keyword">for</span> m = <span class="number">2</span>:<span class="number">1</span>:steps</div><div class="line">        tmp = histArray(m<span class="number">-1</span>,:);</div><div class="line">        <span class="keyword">switch</span> world</div><div class="line">            <span class="keyword">case</span> <span class="string">'zero'</span></div><div class="line">                tmp = [<span class="number">0</span>,tmp,<span class="number">0</span>];</div><div class="line">            <span class="keyword">case</span> <span class="string">'one'</span></div><div class="line">                tmp = [<span class="number">1</span>,tmp,<span class="number">1</span>];</div><div class="line">            <span class="keyword">case</span> <span class="string">'extend'</span></div><div class="line">                tmp = [tmp(<span class="number">1</span>),tmp,tmp(end)];</div><div class="line">            <span class="keyword">case</span> <span class="string">'wrap'</span></div><div class="line">                tmp = [tmp(end),tmp,tmp(<span class="number">1</span>)];</div><div class="line">            <span class="keyword">otherwise</span></div><div class="line">                tmp = [<span class="number">0</span>,tmp,<span class="number">0</span>];</div><div class="line">        <span class="keyword">end</span></div><div class="line">        mat = [tmp(<span class="number">1</span>:(end<span class="number">-2</span>));tmp(<span class="number">2</span>:(end<span class="number">-1</span>));tmp(<span class="number">3</span>:end)];</div><div class="line">        condition = sum(mat.*<span class="built_in">repmat</span>([<span class="number">4</span>;<span class="number">2</span>;<span class="number">1</span>],<span class="number">1</span>,len))+<span class="number">1</span>;</div><div class="line">        res = bitget(rules,condition);</div><div class="line">        histArray(m,:) = res;</div><div class="line">    <span class="keyword">end</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> isShow</div><div class="line">        figure;</div><div class="line">        imagesc(histArray); colormap([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]);</div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<h3 id="玩转元胞自动机"><a href="#玩转元胞自动机" class="headerlink" title="玩转元胞自动机"></a>玩转元胞自动机</h3><p>至此，我们的编程也就完了，是不是很简单？我们可以全部使用默认设置玩一下<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cellularAuto; <span class="comment">%无任何参数，全部使用默认值</span></div></pre></td></tr></table></figure></p>
<p>两次模拟的结果。其中每一行就是一维世界的一个状态，每一列代表一次模拟，由上到下是时间维度。</p>
<p><img src="http://oyeuye83q.bkt.clouddn.com/18-3-8/48934686.jpg" alt=""></p>
<p>我们还可以使用110规则模拟一个一万长度的一维世界的一万次变化的结果：</p>
<p><img src="http://oyeuye83q.bkt.clouddn.com/18-3-8/87004660.jpg" alt=""></p>
<p>怎么样，很有意思吧！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2018/03/06/Notes of A new kind of science-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2018/03/06/Notes of A new kind of science-01/" itemprop="url">Notes of A new kind of Science-01</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-06T13:00:00+08:00">
                2018-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/General-Science/" itemprop="url" rel="index">
                    <span itemprop="name">General Science</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Chapter-01-The-Foundations-for-a-New-Kind-of-Science"><a href="#Chapter-01-The-Foundations-for-a-New-Kind-of-Science" class="headerlink" title="Chapter 01: The Foundations for a New Kind of Science"></a>Chapter 01: The Foundations for a New Kind of Science</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><h4 id="传统科学是否能真正的解释自然？"><a href="#传统科学是否能真正的解释自然？" class="headerlink" title="传统科学是否能真正的解释自然？"></a>传统科学是否能真正的解释自然？</h4><blockquote>
<p>If theoretical science is to be possible, then at some level the systems it studies must follow definite rules…But the crucial realization that led me to develop the new kind of science in this book is that there is in fact no reason to think that systems ike those we see in nature should follow only such traditional mathematical rules.</p>
</blockquote>
<h4 id="计算可能是是相比于数学更普适的描述自然的方法"><a href="#计算可能是是相比于数学更普适的描述自然的方法" class="headerlink" title="计算可能是是相比于数学更普适的描述自然的方法"></a>计算可能是是相比于数学更普适的描述自然的方法</h4><ul>
<li>想法：这里使用计算而非计算机，主要是因为我认为现代的计算机架构未必就是最优化的形式。现代计算机的运行基本上是线性的，独立的，不同计算单元之间的联系是非常复杂的。但是元胞自动机以及自然界中存在的计算本质上是多核心（去中心化），并行以及非线性的。不同个体之间的联系是本征的。并行化与相互作用是自然产生复杂现象的必要条件。</li>
</ul>
<h4 id="简单的规则也可以产生复杂的行为（元胞自动机）"><a href="#简单的规则也可以产生复杂的行为（元胞自动机）" class="headerlink" title="简单的规则也可以产生复杂的行为（元胞自动机）"></a>简单的规则也可以产生复杂的行为（元胞自动机）</h4><h4 id="已有的科学范式将整体分解为部分，并仔细的研究各个部分的性质（蛋白）"><a href="#已有的科学范式将整体分解为部分，并仔细的研究各个部分的性质（蛋白）" class="headerlink" title="已有的科学范式将整体分解为部分，并仔细的研究各个部分的性质（蛋白）"></a>已有的科学范式将整体分解为部分，并仔细的研究各个部分的性质（蛋白）</h4><ul>
<li>想法：【科学】的思维模式也被广泛的应用到了社会治理至少。工人们和学生们一天中大部分的时间扮演了机器上的一颗螺丝钉，其独特的情感以及创造性被忽略且被视为社会机器的一个组成部分。只有当下班或者下课以后，他们的生命才再次鲜活起来，变成了了一个真正的人，尽管还要与劳作以后的疲惫奋战。</li>
</ul>
<blockquote>
<p>In the existing sciences much of the emphasis over the past century or so has been on breaking systems down to find their underlying parts, then trying to analyze these parts in as much detail as possible.</p>
</blockquote>
<h4 id="计算等价定理（Principle-of-Computational-Equivalence）"><a href="#计算等价定理（Principle-of-Computational-Equivalence）" class="headerlink" title="计算等价定理（Principle of Computational Equivalence）"></a>计算等价定理（Principle of Computational Equivalence）</h4><ul>
<li>想法：不同的观察视角是否会对复杂性产生不同的认识？复杂性显然的与时间和空间的次序相关，但是与观测的智能是否相关呢？是否观测的角度导致的复杂性？在【rule space】中观测是否就简单了？</li>
</ul>
<blockquote>
<p>Whenever one sees behavior that is not obviously simple, in essentially any system, it can be thought of as corresponding to a computation of equivalent sophistication.</p>
</blockquote>
<h4 id="传统的数学公式表达仅仅适用于少部分体系"><a href="#传统的数学公式表达仅仅适用于少部分体系" class="headerlink" title="传统的数学公式表达仅仅适用于少部分体系"></a>传统的数学公式表达仅仅适用于少部分体系</h4><blockquote>
<p>But the great historical successes of theoretical science have typically revolved around finding mathematical formulas that instead directly allow one to predict the outcome…And the principle of Computational Equivalence now implies that this will normally be possible only for rather special system with simple behavior.</p>
</blockquote>
<h4 id="理论科学是否存在极限，极限在哪里？极限以外是否还是人能够理解的世界？"><a href="#理论科学是否存在极限，极限在哪里？极限以外是否还是人能够理解的世界？" class="headerlink" title="理论科学是否存在极限，极限在哪里？极限以外是否还是人能够理解的世界？"></a>理论科学是否存在极限，极限在哪里？极限以外是否还是人能够理解的世界？</h4><blockquote>
<p>So this implies that there is in a sense a fundamental limitation to theoretical science. </p>
<p>But it also shows that there is something irreducible that can be achieved by the passage of time. And it leads to an explanation of how we as humans—even though we may follow definite underlying rules—can still in a meaningful way show free will.</p>
</blockquote>
<ul>
<li><p>想法：作者联系到的“自由意志”看似是无稽之谈，但是也有一定道理。用数学和理论描述世界的思想尽管是科学的主流。但是将这种方法论极致的推广导致的结果就是我们开始怀疑是否存在【自由意志】。</p>
</li>
<li><p>想法：是否可以存在一种理论工具预测元胞自动机的发展趋势</p>
</li>
</ul>
<h4 id="人类没有什么特别的"><a href="#人类没有什么特别的" class="headerlink" title="人类没有什么特别的"></a>人类没有什么特别的</h4><blockquote>
<p>One feature of many of the most important advances in science throughout history is that they show new ways in which we as humans are not special. And at some level the Principle of Computational Equivalence does this as well. For it implies that when it comes to computation—or intelligence—we are in the end no more sophisticated than all sorts of simple programs, and all sorts of systems in nature.</p>
</blockquote>
<h3 id="与其他学科的联系"><a href="#与其他学科的联系" class="headerlink" title="与其他学科的联系"></a>与其他学科的联系</h3><h4 id="数学：作者认为元胞自动机是一种更广泛意义上的数学"><a href="#数学：作者认为元胞自动机是一种更广泛意义上的数学" class="headerlink" title="数学：作者认为元胞自动机是一种更广泛意义上的数学"></a>数学：作者认为元胞自动机是一种更广泛意义上的数学</h4><blockquote>
<p>And one of the consequences of this complexity is that it leads to fundamental limitations on the idea of proof that has been central to traditional mathematics…Yet what the discoveries in this book show is that this is largely just a reflection of how small the scope is of what is now considered mathematics. And indeed the core of this book can be viewed as introducing a major generalization of mathematics—with new ideas and methods, and vast new areas to be explored.</p>
</blockquote>
<h4 id="物理"><a href="#物理" class="headerlink" title="物理"></a>物理</h4><blockquote>
<p>The traditional mathematical approach to science has historically had its great success in physics—and by now it has become almost universally assumed that any serious physical theory must be based on mathematical equations. Yet with this approach there are still many common physical phenomena about which physics has had remarkably little to say. But with the approach of thinking in terms of simple programs that I develop in this book it finally seems possible to make some dramatic progress. And indeed in the course of the book we will see that some extremely simple programs seem able to capture the essential mechanisms for a great many physical phenomena that have previously seemed completely mysterious.</p>
</blockquote>
<h5 id="传统物理多使用连续数值，微积分以及概率；元胞自动机本质是离散的；简单的规则组合形成了复杂的行为"><a href="#传统物理多使用连续数值，微积分以及概率；元胞自动机本质是离散的；简单的规则组合形成了复杂的行为" class="headerlink" title="传统物理多使用连续数值，微积分以及概率；元胞自动机本质是离散的；简单的规则组合形成了复杂的行为"></a>传统物理多使用连续数值，微积分以及概率；元胞自动机本质是离散的；简单的规则组合形成了复杂的行为</h5><h5 id="传统物理多是理想化的建立在数学上的关系；元胞自动机可以表达更复杂的关系"><a href="#传统物理多是理想化的建立在数学上的关系；元胞自动机可以表达更复杂的关系" class="headerlink" title="传统物理多是理想化的建立在数学上的关系；元胞自动机可以表达更复杂的关系"></a>传统物理多是理想化的建立在数学上的关系；元胞自动机可以表达更复杂的关系</h5><h4 id="生物：传统生物学细节了解的多，但是却缺乏统一的理论"><a href="#生物：传统生物学细节了解的多，但是却缺乏统一的理论" class="headerlink" title="生物：传统生物学细节了解的多，但是却缺乏统一的理论"></a>生物：传统生物学细节了解的多，但是却缺乏统一的理论</h4><blockquote>
<p>Vast amounts are now known about the details of biological organisms, but very little in the way of general theory has ever emerged.</p>
<p>And part of the reason for this is that traditional mathematical models have never seemed to come even close to capturing the kind of complexity we see in biology. </p>
</blockquote>
<h4 id="社会科学"><a href="#社会科学" class="headerlink" title="社会科学"></a>社会科学</h4><ul>
<li>想法：社会科学，环境科学，天体科学的变化周期长，难以在短期内获得重复性数据。从容易掌控和重复的微观体系入手研究复杂体系行为；再寻找微观复杂体系的行为与宏观复杂体系行为之间的关系，从而间接的探究宏观体系的动力学本质</li>
</ul>
<blockquote>
<p>From economics to psychology there has been a widespread if controversial assumption—no doubt from the success of the physical sciences—that solid theories must always be formulated in terms of numbers, equations and traditional mathematics. </p>
</blockquote>
<h4 id="计算机科学-从专家型的编程变为通用型-自组织的编程"><a href="#计算机科学-从专家型的编程变为通用型-自组织的编程" class="headerlink" title="计算机科学:从专家型的编程变为通用型+自组织的编程"></a>计算机科学:从专家型的编程变为通用型+自组织的编程</h4><ul>
<li>想法：例如机器学习、遗传算法等方法的发展代表了这种趋势</li>
</ul>
<blockquote>
<p>Throughout its brief history computer science has focused almost exclusively on studying specific computational systems set up to perform particular tasks. But one of the core ideas of this book is to consider the more general scientific question of what arbitrary computational systems do. </p>
</blockquote>
<h4 id="哲学"><a href="#哲学" class="headerlink" title="哲学"></a>哲学</h4><h4 id="艺术"><a href="#艺术" class="headerlink" title="艺术"></a>艺术</h4><h4 id="技术：去中心化的控制，进化的功能实现"><a href="#技术：去中心化的控制，进化的功能实现" class="headerlink" title="技术：去中心化的控制，进化的功能实现"></a>技术：去中心化的控制，进化的功能实现</h4><ul>
<li>Despite all its success, there is still much that goes on in nature that seems more complex and sophisticated than anything technology has ever been able to produce. But what the discoveries in this book now show is that by using the types of rules embodied in simple programs one can capture many of the essential mechanisms of nature. And from this it becomes possible to imagine a whole new kind of technology that in effect achieves the same sophistication as nature. </li>
</ul>
<h3 id="相关领域"><a href="#相关领域" class="headerlink" title="相关领域"></a>相关领域</h3><h4 id="人工智能：遭遇瓶颈"><a href="#人工智能：遭遇瓶颈" class="headerlink" title="人工智能：遭遇瓶颈"></a>人工智能：遭遇瓶颈</h4><blockquote>
<p> And in the 1960s the field of artificial intelligence grew up with the goal of understanding processes of human thinking and implementing them on computers. But doing this turned out to be much more difficult than expected, and after some spin-offs, little fundamental progress was made. At some level, however, the basic problem has always been to understand how the seemingly simple components in a brain can lead to all the complexities of thinking</p>
</blockquote>
<h4 id="合成生命-Artificial-Life"><a href="#合成生命-Artificial-Life" class="headerlink" title="合成生命(Artificial Life)"></a>合成生命(Artificial Life)</h4><blockquote>
<p>Most active from the mid-1980s to the mid-1990s, the field of artificial life concerned itself mainly with showing that computer programs could be made to emulate various features of biological systems. But normally it was assumed that the necessary programs would have to be quite complex. What the discoveries in this book show, however, is that in fact very simple programs can be sufficient.</p>
</blockquote>
<h4 id="突变理论"><a href="#突变理论" class="headerlink" title="突变理论"></a>突变理论</h4><blockquote>
<p>Traditional mathematical models are normally based on quantities that vary continuously. Yet in nature discrete changes are often seen. Popular in the 1970s, catastrophe theory was concerned with showing that even in traditional mathematical models, certain simple discrete changes could still occur. </p>
</blockquote>
<h4 id="混沌理论"><a href="#混沌理论" class="headerlink" title="混沌理论"></a>混沌理论</h4><blockquote>
<p>Indeed, all that it shows is that if there is complexity in the details of the initial conditions, then this complexity will eventually appear in the large-scale behavior of the system. But if the initial conditions are simple, then there is no reason for the behavior not to be correspondingly simple. What I show in this book, however, is that even when their initial conditions are very simple there are many systems that still produce highly complex behavior. And I argue that it is this phenomenon that is for example responsible for most of the obvious complexity we see in nature.</p>
</blockquote>
<h4 id="复杂性理论"><a href="#复杂性理论" class="headerlink" title="复杂性理论"></a>复杂性理论</h4><blockquote>
<p>One feature of the new kind of science that I describe in this book is that it finally makes possible the development of a basic understanding of the general phenomenon of complexity, and its origins.</p>
</blockquote>
<h4 id="计算复杂度理论"><a href="#计算复杂度理论" class="headerlink" title="计算复杂度理论"></a>计算复杂度理论</h4><blockquote>
<p>Developed mostly in the 1970s, computational complexity theory attempts to characterize how difficult certain computational tasks are to perform. Its concrete results have tended to be based on fairly specific programs with complicated structure yet rather simple behavior. The new kind of science in this book, however, explores much more general classes of programs—and in doing so begins to shed new light on various longstanding questions in computational complexity theory.</p>
</blockquote>
<h4 id="控制论-Cybernetics"><a href="#控制论-Cybernetics" class="headerlink" title="控制论 (Cybernetics)"></a>控制论 (Cybernetics)</h4><h4 id="动力系统理论"><a href="#动力系统理论" class="headerlink" title="动力系统理论"></a>动力系统理论</h4><blockquote>
<p>But what I argue in this book is that in fact the behavior of many systems is fundamentally too complex to be usefully captured in any such way.</p>
</blockquote>
<h4 id="进化理论"><a href="#进化理论" class="headerlink" title="进化理论"></a>进化理论</h4><blockquote>
<p>And indeed I will argue in this book that in many respects it(natural selection) tends to oppose complexity. But the discoveries in the book suggest a new and quite different mechanism that I believe is in fact responsible for most of the examples of great complexity that we see in biology.</p>
</blockquote>
<h4 id="实验数学"><a href="#实验数学" class="headerlink" title="实验数学"></a>实验数学</h4><h4 id="分形"><a href="#分形" class="headerlink" title="分形"></a>分形</h4><h4 id="系统理论"><a href="#系统理论" class="headerlink" title="系统理论"></a>系统理论</h4><h4 id="纳米技术"><a href="#纳米技术" class="headerlink" title="纳米技术"></a>纳米技术</h4><h4 id="非线性动力学"><a href="#非线性动力学" class="headerlink" title="非线性动力学"></a>非线性动力学</h4><h4 id="科学计算"><a href="#科学计算" class="headerlink" title="科学计算"></a>科学计算</h4><h4 id="自组织"><a href="#自组织" class="headerlink" title="自组织"></a>自组织</h4><h4 id="统计力学"><a href="#统计力学" class="headerlink" title="统计力学"></a>统计力学</h4><h3 id="作者自传"><a href="#作者自传" class="headerlink" title="作者自传"></a>作者自传</h3><blockquote>
<p>So I thought that perhaps I could do something similar in natural science: that there might be some appropriate primitives that I could find that would successfully capture a vast range of natural phenomena.</p>
<p>There were in many cases well-established mathematical models for the individual components of such systems. But two practical issues stood in the way of using these as a basis for simulations. First, the models were usually quite complicated, so that with realistic computer resources it was very difficult to include enough components for interesting phenomena to occur. And second, even if one did see such phenomena, it was almost impossible to tell whether in fact they were genuine consequences of the underlying models or were just the result of approximations made in implementing the models on a computer.</p>
<p>My early discoveries about the behavior of cellular automata stimulated a fair amount of activity in the scientific community. And by the mid-1980s, many applications had been found in physics, biology, computer science, mathematics and elsewhere. And indeed some of the phenomena I had discovered were starting to be used as the basis for a new area of research that I called complex systems theory.</p>
<p>The typical issue was that there was some core problem that traditional methods or intuition had never successfully been able to address—and which the field had somehow grown to avoid. Yet over and over again I was excited to find that with my new kind of science I could suddenly begin to make great progress—even on problems that in some cases had remained unanswered for centuries.</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2018/03/06/Notes of A new kind of science-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2018/03/06/Notes of A new kind of science-02/" itemprop="url">Notes of A new kind of Science-02</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-06T13:00:00+08:00">
                2018-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/General-Science/" itemprop="url" rel="index">
                    <span itemprop="name">General Science</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Chapter-02-The-Crucial-Experiment"><a href="#Chapter-02-The-Crucial-Experiment" class="headerlink" title="Chapter 02: The Crucial Experiment"></a>Chapter 02: The Crucial Experiment</h2><h3 id="How-do-Simple-Programs-Behave"><a href="#How-do-Simple-Programs-Behave" class="headerlink" title="How do Simple Programs Behave?"></a>How do Simple Programs Behave?</h3><h4 id="Simple-Programe是不事先设定功能的程序"><a href="#Simple-Programe是不事先设定功能的程序" class="headerlink" title="Simple Programe是不事先设定功能的程序"></a>Simple Programe是不事先设定功能的程序</h4><blockquote>
<p>In our everyday experience with computers, the programs that we encounter are normally set up to perform very definite tasks. But the key idea that I had nearly twenty years ago—and that eventually led to the whole new kind of science in this book—was to ask what happens if one instead just looks at simple arbitrarily chosen programs, created without any specific task in mind. How do such programs typically behave?</p>
</blockquote>
<ul>
<li>想法：设定简单的规则，模拟，然后看它如何发展</li>
</ul>
<h4 id="元胞自动机-cellular-automata-是典型的Simple-Program"><a href="#元胞自动机-cellular-automata-是典型的Simple-Program" class="headerlink" title="元胞自动机(cellular automata)是典型的Simple Program"></a>元胞自动机(cellular automata)是典型的Simple Program</h4><h4 id="元胞自动机从简单的规律出发，产生复杂的变化"><a href="#元胞自动机从简单的规律出发，产生复杂的变化" class="headerlink" title="元胞自动机从简单的规律出发，产生复杂的变化"></a>元胞自动机从简单的规律出发，产生复杂的变化</h4><ul>
<li>与非线性系统的简单方程（洛伦兹）产生复杂变化类似，应该具有同样的本质</li>
</ul>
<h3 id="The-Need-for-a-New-Intuition"><a href="#The-Need-for-a-New-Intuition" class="headerlink" title="The Need for a New Intuition"></a>The Need for a New Intuition</h3><h4 id="工程实践限制了人类以线性思维考虑问题"><a href="#工程实践限制了人类以线性思维考虑问题" class="headerlink" title="工程实践限制了人类以线性思维考虑问题"></a>工程实践限制了人类以线性思维考虑问题</h4><blockquote>
<p>For normally we start from whatever behavior we want to get, then try to design a system that will produce it. Yet to do this reliably, we have to restrict ourselves to systems whose behavior we can readily understand and predict—for unless we can foresee how a system will behave, we cannot be sure that the system will do what we want.<br>But unlike engineering, nature operates under no such constraint. So there is nothing to stop systems like those at the end of the previous section from showing up. And in fact one of the important conclusions of this book is that such systems are actually very common in nature.</p>
</blockquote>
<h3 id="Why-these-discoveries-were-not-made-before"><a href="#Why-these-discoveries-were-not-made-before" class="headerlink" title="Why these discoveries were not made before"></a>Why these discoveries were not made before</h3><h4 id="与主流科学不符"><a href="#与主流科学不符" class="headerlink" title="与主流科学不符"></a>与主流科学不符</h4><blockquote>
<p>One reason is just that they were not in the mainstream of any existing field of science or mathematics. But a more important reason is that standard intuition in traditional science gave no reason to think that their results would be interesting.</p>
</blockquote>
<h4 id="数学描述一切的思想"><a href="#数学描述一切的思想" class="headerlink" title="数学描述一切的思想"></a>数学描述一切的思想</h4><blockquote>
<p>During the 1700s and 1800s there was ever-increasing success in using rules based on mathematical equations to analyze physical phenomena. And after the spectacular results achieved in physics in the early 1900s with mathematical equations there emerged an almost universal belief that absolutely every aspect of the natural world would in the end be explained by using such equations.</p>
</blockquote>
<h4 id="计算机科学的发展"><a href="#计算机科学的发展" class="headerlink" title="计算机科学的发展"></a>计算机科学的发展</h4><blockquote>
<p>Indeed, many of my discoveries about cellular automata came as direct consequences of using progressively better computer technology.</p>
</blockquote>
<h4 id="尽管历史上出现过很多类似现象的端倪，但都被忽略了"><a href="#尽管历史上出现过很多类似现象的端倪，但都被忽略了" class="headerlink" title="尽管历史上出现过很多类似现象的端倪，但都被忽略了"></a>尽管历史上出现过很多类似现象的端倪，但都被忽略了</h4><blockquote>
<p>But the history that I have outlined in this section—like the history of many other scientific discoveries—provides a sobering reminder of just how easy it is to miss what will later seem obvious.</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2017/12/30/生物化学方向数据分析与机器学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2017/12/30/生物化学方向数据分析与机器学习/" itemprop="url">生物化学方向数据分析与机器学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-30T13:00:00+08:00">
                2017-12-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/General-Science/" itemprop="url" rel="index">
                    <span itemprop="name">General Science</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这篇文章主要讲生物化学的基础研究和技术应用中产生的数据与机器学习的结合。实际上，在我看过的文献里面，这两者的结合早已有之，并不是什么新鲜的事情，至少20世纪90年代就有相关的工作，这也和人工智能等概念的几起几落相关。近年来，这种相互结合的趋势愈加明显，部分的原因可能也是机器学习和大数据等概念的兴起，但除此之外，生物化学的研究本身的趋势也愈加的需要这样的技术。</p>
<p>我们研究基础科学，涉及的主要认为有：客观的观测与描述，抽象模型和解释，预测以及干预。科学走到今天，不同的领域有不同的发展，基础物理和高能物理现在还在寻找一些方法间接的观测例如“暗物质”或者某种预言的粒子之类的东西，包括近来观测到的引力波等等，都是在寻找方法对系统进行观测。反过来，如有机合成等学科，已经建立了一套方法体系，控制有机反应，使得我们可以理性的设计合成路线，获得我们想要的产物，对有机产物结构的观测手段如质谱等，已经在过去多次获得诺贝尔奖。可见，【客观的观测与描述】一个体系这件事情，尽管是科学定量研究的第一步，但是仍然是非常重要且大有可为的一个领域。</p>
<p>在对生命科学体系以及化学体系的研究中，分析手段大部分就是做的客观的观测与描述的工作。这部分工作尽管已经取得了长足的进步，但是还有很多问题没有解决。如何从静态的观测走向动态的观测；在空间尺度和时间尺度上，如何尽可能准确的观测到尽可能微小的差异；如何观测和分析复杂的多组分相互作用的体系等等</p>
<p>我们客观的观测和描述研究的对象，基本的方法就是通过检测器检测信号，获取数据，我们认为，数据是脱离主观的，是对被观测食物的客观反映。然后再进一步的从数据中提取信息，进行分析和描述，最终获得对研究对象的理解和新的知识。因此，对于数据中包含的信息的提取，分析和描述是一道连接实验数据与我们最终目标——对体系的理解和获取新的知识的桥梁，不得不说是非常重要的。当我们研究的体系比较简单，数据量较少的时候，分析和描述也不复杂，因此，在过去的纯分析研究中，大量的精力集中在如何更好的获得数据上面；而分析的应用方面，则精力集中在如何从对体系的描述中发现新的知识，建立新的模型上面。比如说获得了诺贝尔奖的MALDI离子源，就是解决了质谱如何获取生物大分子质量数的问题。</p>
<p>但是，随着分析技术的进步，从观测数据到知识之间的桥梁变得不那么好走了。这主要是两个方面的原因造成的，一是随着分析方法和分析仪器的进步，单位时间获取的数据量大大增加了。过去我们拍摄一张荧光成像的图片，显示了被标记的物种在某个时刻在体系中的空间分布情况，我们是可以简单的对其进行分析的；但是现在，在笔者的实验中，拍摄的随时间变化的荧光时序图像，由于采用了高速的和高灵敏度的EMCCD，因此在一个下午的时间里，2~3份样品就将产生大约六万帧的图像，占用约50GB储存空间。在这样的情况下，完全无法通过传统的定性分析的方法人工的来全面的理解和描述获得的实验信息。第二个原因是我们研究的体系变得更加的复杂了，简单的体系中，我们关注的物质种类单一，且认为不同的物种之间是相互独立的，如果有相互作用，那么这种作用是线性的和决定性的，可以简单描述的。例如我们分析一份环境样本，想要获取其中几种农药含量，这样的体系就是简单的，因为每一种农药的情况都单一的对应一个质谱峰的强度；且不同的质谱峰之间互不干扰，这样的分析是经典的化学分析的内容。但是，当面对复杂的体系的时候，我们就没有办法如此直观的获得一一对应的相关性信息。譬如说，我们现在想要研究的是药物对细胞的刺激作用，当然，如果刺激的作用很强烈，那么就只有杀死细胞和细胞存活的差异。 但是，如果药物对细胞的状态产生了影响，但这种影响只是改变了细胞的生活方式，而并没有杀死细胞，这样的情况下问题就非常多了。如何观测细胞状态的变化？细胞的状态与那些可以被观测的量相关？如何定量的描述这种变化等等。研究体系的复杂化以及研究问题的精细化，导致我们很难再像以前一样直观的从数据中获得结论了，因此必须更好的利用“从数据中提取信息，进行描述和分析”这个桥梁的作用，帮助我们从复杂的自然想象中获取有益的信息。</p>
<p>那么如何更好的利用这个桥梁呢？或者说，如何从大量的，复杂的数据中，提取我们想要的信息，进行定量化的描述和分析呢？机器学习的方法无疑是很重要的方法（但不是唯一的方法）。</p>
<h3 id="机器学习中的基本概念"><a href="#机器学习中的基本概念" class="headerlink" title="机器学习中的基本概念"></a>机器学习中的基本概念</h3><h4 id="机器学习的任务"><a href="#机器学习的任务" class="headerlink" title="机器学习的任务"></a>机器学习的任务</h4><p>机器学习的任务，也就是大家使用机器学习的目的，大致上可以有 <strong>分类与预测</strong>，<strong>关联性分析</strong>等内容。<br><strong>分类与预测</strong>是机器学习最常见的用途。实际上，分析的目的常常与分类有关，有些是二分类问题：如一份河水样本是不是有机物超标？一个细胞是否是活细胞？一个生物样本是否是来自于猪的？这些都是传统的二分类问题。当我们的结论与信号之间的很强的关联性的时候，这个事情并不需要机器学习来做：河水中还原性物质给了高锰酸钾x个电子每毫升以上就是有机物超标；细胞质区域被不能跨膜的染料染上颜色就说明细胞已经死亡；DNA电泳中出现了特征的条带就说明样本来源是猪等等。但是，正如上面所说的，如果需要研究的问题更为深入和精细的时候，我们就很难将结论与直接观测的数据相联系了，比如，一个细胞是否是癌细胞？如果是，是哪一种癌细胞？一个细菌是否是耐药的？如果是，耐哪一种类型的药物？我们直接能够观测的量没有一个能想前面所说的那样给我们直接的结论，综合多个不同观测变量的结果，给出一个单一的分类标签的过程，就是机器学习中的分类。之所以成为机器学习，主要是因为我们在生活中大部分时间都会做这件事：比如我们第一次遇到一个人，我们的大脑就可以根据这个人的衣着，相貌，举止，语言等多个因素给出一个综合的评价——第一印象是好还是坏；这就是我们大脑作出的二分类问题。预测问题就是给定一个未知结果的观测结果，根据以前的学习结果，预测这个观测结果属于的类别。<br><strong>关联性分析</strong>则是为了回答这样的一个问题，一个观测的结果与众多的不同的观测值之间的关系是什么。尽管学习的方法可以对数百上千的观测值进行综合给出一个单一的结果，但是我们人类还是希望知道，这个结果主要是由哪些因素影响的。这与后面的解释，建模以及预测直接相关。因此也是科学领域内非常重要的一步。</p>
<h4 id="样本，特征与分类器"><a href="#样本，特征与分类器" class="headerlink" title="样本，特征与分类器"></a>样本，特征与分类器</h4><p>机器学习中一个观测的对象称为一个样本，每个观测的指标称为一个特征，对观测结果进行综合和预测的一组参数成为模型或者分类器。 上面的概念非常抽象，我们可以举一个很简单的例子来说明。譬如我们给实验室采购电脑，需要选择买哪些电脑来给大家来用。买电脑这种事情还是有点复杂的，对于每一个品牌和型号的电脑，实际上就是我们观测的一个对象，也就是一个样本。 我们观测的指标很简单，一个是CPU的计算能力，可以用benchmark来量化表示；另一个就是电脑的价格，可以用人民币为单位进行表示。这里的CPU benchmark和价格就是我们观测的两个特征。对于每一个样本（电脑型号），都可以获得这两个特征。分类器的作用就是根据这两个特征来作出决策，买还是不买这个品牌的电脑。<br>那么怎么理解分类器就是一组参数呢？因为机器学习需要处理的问题来自各个不同的领域，永远也无法穷举出来每个领域的专家模型（也就是对这个领域有深厚了解的专家的决策规则）。因此机器学习算法仅仅是一系列抽象的计算方法，而面对不同领域和不同的数据集的时候，同样的一个算法实际上还是同样设定好的分析规则。所不同的是执行这个规则的参数不同。什么样的参数最适合做一个特定领域的分析和预测呢？这个就是通过这个领域的历史数据来进行学习的<br>还回到买电脑的故事里面。我们怎么知道什么样的电脑才适合实验室买呢？我们可以找出来过去实验室买电脑的记录，其中已经购买的电脑的CPU benchmark以及当时的价格我们都是可以获得的；同时我们也可以看看当时考虑了但是没有买的电脑的相关特征。我们知道过去的决策中关注的样本，特征与最终结果，就可以训练一个分类器来帮我们预测当前的那些电脑型号适合实验室购买。<br>刚才我们说，一个机器学习算法就是一个通用的计算规则。比如我们这里找到了一个简单的算法，那就是价格在某个区间中的时候，CPU benchmark达到一定数值，就会被购买。这个规则就是一个简单的机器学习模型。那么价格具体要在哪个范围呢？CPU benchmark要高过哪个阈值才会购买呢？这些参数与就是需要通过从历史数据中计算确定得到的。这些参数算出来以后，这个规则和参数就形成了一个分类器，帮助我们确定一个新的品牌的电脑是否值得购买。<br>那么上述的机器学习算法的抽象就是这样的一组规则：特征1（例子中为价格）需要同时满足大于参数$\alpha$，小于参数$\beta$，以及特征2需要大于参数$\gamma$的情况下，就输出结果1，否则输出结果2. 一个具体应用的模型就是由一组具体($\alpha_0$, $\beta_0$, $\gamma_0$)确定的规则。</p>
<h4 id="有监督的学习和无监督的学习"><a href="#有监督的学习和无监督的学习" class="headerlink" title="有监督的学习和无监督的学习"></a>有监督的学习和无监督的学习</h4><p>上面描述的例子中，学习是通过历史决策数据完成的。这样的机器学习算法成为有监督的机器学习算法。也就是说过去的决策数据作为真实值，指导了算法的优化和评价过程。但是，实际工作中，历史决策数据可能是很难获取到的。更重要的是，有监督的情况是建立在我们对需要做的事情非常清楚的情况下。但是，在研究中我们有的时候希望从大量的数据中看到差异性，再从差异性入手挖掘新的未知的知识，这个时候，无监督的学习方法也就变得很重要了。<br>还是上面的买电脑的例子。假如现在实验室刚刚建立，还没有过去买电脑的历史。于是导师跟你说，你调研总结一下市场上在售的电脑都有哪些不同的类型，我们选一个类型来买。这个需求中提到的【调研总结一下市场上在售的电脑都有哪些不同的类型】就是一个非常不明确的需求，我们作为非计算机销售的专家，并不知道在售有哪几种类型的电脑；也不知道每一种类型的电脑都是什么样子的。但是，我们可以使用无监督的学习方法，从在售电脑数据中学习到这些东西。<br>无监督学习的主要应用就是聚类。所谓聚类就是对于一个有大量不同样本的数据集，根据样本之间的相似度，将彼此相似的样本聚为一类；彼此不同的样本分开为不同的类。最终给出的结果就是每一个样本属于的类别。我们再观察每一个类别的平均状况，就可以知道大概每一个类别都是什么情况。无监督学习判断两个样本的差异性就是通过他们的特征值计算得到的。不同的相似度计算方法成为不同的【度量】。度量选择的不同也会导致分类结果的不同，这是因为无监督学习既然是【无监督】的，它其实不懂对错，只是完美的根据【相似的在一起；不同的不在一起】的规则去工作，至于最后的结果是否有意义，就让人来决定吧。举一个例子，现在我们有一群人要进行分类；如果选择【性别】作为度量，那么就会分成【男人】和【女人】两类。如果根据年龄来作为度量，分类的结果就是老年和少年。无监督的学习方法没有变，规则也没有变，但是分类的结果变了，这是度量发生改变的结果。<br>回到原来的例子，使用无监督的学习方法，我们将收集来的市场上在售的电脑分成了四类。我们观察每一类的平均情况，发现有一类是价格高，CPU benchmark低的电脑，原来是商务笔记本；有一类价格高，benchmark也高的，原来是游戏本；有一类价格低，benchmark也低的，原来是低端本；还有一类价格低但是benchmark高的，原来是二手本。</p>
<h4 id="机器学习与物理模型"><a href="#机器学习与物理模型" class="headerlink" title="机器学习与物理模型"></a>机器学习与物理模型</h4><p>上面谈到，机器学习的方法是普适性的，而非是领域相关的专家知识的集合。相反的，物理模型则完全是通过领域内专家通过专业知识推导得到的结果。我们说机器学习这个东西并不新鲜，在过去已经经历多次起落。当它衰落的时候，也就是对应的专家模型应用广泛的时候。因此，这两种东西实际上是相互竞争又相互启发的。 机器学习在过去衰落的原因主要是计算能力不够，数据量不够或者算法不好导致的应用效果差。对于科学研究上来说，机器学习还有一个先天的劣势，就是即时机器学习给出了很好的预测或者聚类结果，我们却无法从科学本质上的了解其中的因果关系。尽管通过关联分析和重要特征的提取可以改善这一问题（因为特征一般是有具体意义的观测值），但仍然不如物理模型来的直接和易于解释。机器学习也因为其黑匣子的特征，大部分的应用于商业。对于科学研究来说，黑匣子是不够的。<br>但是我们上面说，机器学习与物理模型也有相辅相成的关系。这也是当前科学研究中的新型热点。物理模型的建立过程中天然的带有人对于体系本身的规则的假设，也就是模型的预设条件。但是，对于上面说的复杂的多因素相互作用的系统，尤其是缺乏先验知识的未被探索的科学领域，建立的模型常常是不完整的，有偏差的甚至是错误的。当下甚至更有激进的观点认为，因果关系的科学主要是建立在牛顿力学的观念上的近现代科学研究体系。在面对复杂的，相互作用相互关联的系统是，因果关系可能是没有意义的。比如说，你说我是因为胖才不爱运动的呢？还是因为不爱运动才变胖的呢？这两个系统变量的变化是相互关联相互反馈的，因此因果之说就变得缥缈。遗憾的是，这样的系统在生物学，社会学等等重要领域都是广泛存在的，以至于让我们认为开始觉得过去研究的简单的相互独立的体系才是复杂的相互关联的体系的海洋中的孤岛。因此，这对我们是挑战也是机遇。<br>物理模型与机器学习的关系也是相辅相成的。我们谈到机器学习中需要对样本进行定量的描述，形成样本的特征，这个特征怎么来的呢？很大一部分就是通过物理模型计算出来的。比如在我的研究中，对于单个粒子在一段时间的运动行为，有一个重要的描述特征就是在这个区间的局部扩散系数。扩散系数是怎么计算的呢？就是基于爱因斯坦的自由扩散物理模型计算的。<br>爱因斯坦的自由扩散模型中的假设是粒子运动在均一稳定的粘性溶液中；因此粒子在扩散过程中，只要统计的量足够完备，应该扩散系数是处处相同的，运动行为的概率统计也应该是相同的。但是在观测实际的体系中，我们发现很多与生物复杂粘弹性的细胞质作用的粒子，表现出与空间和时间相关的运动行为，通过机器学习的方法，我们可以得到不同运动行为的时间和空间的分布。这样的结果反过来又可以刺激新的物理模型的产生。因为机器学习的方法，尤其是无监督的方法，并没有带入先验的人为假设，因此更适用于新知识的发现。数据驱动的知识挖掘也是非常热的商业和科学课题。</p>
<h3 id="生物化学基础研究，应用与机器学习"><a href="#生物化学基础研究，应用与机器学习" class="headerlink" title="生物化学基础研究，应用与机器学习"></a>生物化学基础研究，应用与机器学习</h3><p>前面谈了很多虚的东西，这里进入主题。生物化学的研究范围非常广阔，涉及的话题又纷繁复杂，并不是我这一篇文章能够说清楚的事情。 这里仅仅是从分析化学的角度谈其中很小的一部分。分析化学在生物化学上的研究和应用就是文章开头谈到的对观测体系进行定量的观测和描述。 过去，分析化学大量的研究了简单的，线性的体系，上面提到的如农药检测等就是经典的简单线性系统。 在研究这类系统的时候，最重要的问题是提高检测的范围，精确性和最低检出量。但是随着科学的进步，人们越来越多的关注到了复杂的非线性的系统。尽管这类系统实在是很多，但是真正能够确定性的，可重复性的研究的体系，还是一些生物体系。这是因为，如细胞，生物个体等研究体系可以通过标准化的培养发育大量的可重复的提供实验材料。更多的社会学，生态学和天文学问题，研究体系的时间尺度远远大于生物学实验，因此数据的积累和实验重复性，对照实验的设计等方面都会有所限制。更重要的是，对生物体系的了解直接关系人类永恒的需求——健康，因此生物学的研究如此火热也不难理解。<br>分析化学在生物学当中的应用非常广泛，可以说，分析手段是绝大多数生物学实验的基础。分析化学手段为生物学的研究提供了定量的基础。在研究参照之间存在单一的，显著性差异的时候，定性分析仍然适用（如跑胶看条带的深浅）；在研究参照之间存在单一的，但是仅仅是统计学意义上的显著差异时，定量分析为统计学计算提供了支持；在研究参照之间存在多变量的复杂的相互关系的时候，更多的计算方法就需要运用进去，将数据中的差异提取出来。 机器学习的方法无疑是一种重要的分析手段；其他的，建立在物理模型和假设上的特殊领域算法，时序分析等等也包括在内。<br>前面说了，既然使用数据分析方法的数据本身对于人的定性直觉来讲，太过复杂，那么就会遇到一个直接的问题，就是当分析结果与预期差距很大的时候，或者说结果“不好”的时候，我们如何确定是数据上的问题，还是计算方法上的问题？<br>最常用的方法是使用模拟数据来对算法进行评估。模拟数据的好处是我们本身对模拟所用的数学模型，条件以及基本参数非常了解，这些模拟的基本参数可以当做真实值来与算法的结果作对照，从而评估算法的准确性以及误差范围。如果通过这样的方式确定下来算法是准确的，那么当分析结果与预期有差异的时候，算法的因素就被排除了。<br>除了算法本身正确性的问题以外，还有一个重要的方面是算法本身是否能够揭示你需要的信息。这一点上，需要研究人员至少要对所使用的算法有基本性的了解，否则的话就是胡乱尝试，出了问题也无从下手改进。不同的算法所着重的点是不同的，好比我们看待一样事物有不同的角度一样。如果想要知道苹果的好坏，“尝一口”这个算法将得到口味的结果，对于区别好坏苹果很有帮助；反过来【称重】这个算法只能得到质量数据，很可能发现好苹果和坏苹果没有什么差异。在机器学习在生物化学的领域应用中，在特征的提取上以及算法的选用上，研究人员需要考虑数据的天然属性，机器学习算法的特性以及处理的目标，综合的选择合适的算法。当然，上述的要求实际上是比较高的，通常情况下我们可以先尝试文献中已经报道的方法或者实验室已有的成熟的方法入手。但是归根结底最重要的是，不能期望一劳永逸的用一套算法处理所有的数据且能获得预期的成果；也不建议计算结果不理想就直接重新做实验。还是要将实验数据和算法结果相互不断比对和印证，逐步有针对性的获得理想的结果。</p>
<h3 id="常见的数据种类与学习方法"><a href="#常见的数据种类与学习方法" class="headerlink" title="常见的数据种类与学习方法"></a>常见的数据种类与学习方法</h3><p>分析化学实验常用的数据类型有图像数据和谱图数据，在此处分开来讲。<br>图像数据的来源有显微成像和质谱成像。总体而言，图像数据表现的是物质在空间上的分布信息。图像数据中一个像素点对应一个空间位置，这个像素点的值对应这个位置的信号强度，图像数据本质上就是按照空间位置对应的一个数值矩阵。图像数据的处理非常之多，最为常见的是提高图像质量的降噪，滤波，调节对比度，边缘增强等等；还有识别目标的需求，如特殊物体的自动识别;也有数值分析的需求，如分析某个区域的强度均值等。<br>科学研究中的图像数据通常有TIF格式，TIF格式全称(Tag Image File Format), 是具有标签的无压缩的数据文件格式。其中的标签既可以描述图像本身的信息，也可以描述获取数据的仪器，软件等信息。TIF格式的无压缩特性使得它适合作为科学图像数据格式。计算机在保存图片的时候常常需要将像素的值归一化到一个范围区间内，如8 bit的TIF文件每一个像素的数值就是0~255。对于科学数据来说，并不一定原始信号就与TIF格式的要求相同，在这种情况下，会使用线性变幻将原始数据变换到需要的数值区域，这个过程中可能造成信息的损失。<br>另一个更为麻烦的数据格式是Text Image，如名称所示，这种格式中所有像素的值是按照一定的顺序写在一个txt文档中的，因此是没有信号值域的范围的，因此最大的保留的原始数据。但是这种数据在读取和保存的时候，涉及到数值与字符的相互转换以及显示的时候的数值变换，因此读取和保存的速度较慢。对于看重图像不同区域之间的强度比率的情况，适合使用TIF保存数据；对于看重具体信号强度的情况，适合保存为text image的形式。<br>PNG格式是常见的压缩格式，但是质量也是比较好的，因此与TIF格式一样适合作为发表文章时用的数据格式。<br>向量图通常是软件输出或者人工制作的用于发表文献用的展示用格式，非常重要，但是与数据处理无关，在此就不多说了。<br>说完图像数据常见的类型，那么对于图像数据常见的处理都有哪些呢？前面提到，图像数据的本质上是一个数值矩阵。空间信号处理的方式如二维傅里叶变换等处理方式广泛的应用于图像的信号处理（SIM），降噪等方面。目标识别目前有两种路径。简单的目标识别（如单个圆形颗粒等）可以使用数值方法如最大值寻找，边缘扩展等等方法。复杂的目标识别通常是计算机领域的工作，目前流行使用神经网络的方法。图像数据也可以作为机器学习的样本。最为简单的特征提取方式就是认为每一个像素点就是一个特征，像素点的数值就是特征的值。这样，一张100像素x100像素的图像作为一个样本，就有一万个不同的特征。特征还需要对齐，也就是在相同位置的特征需要表达相同的物理意义。前面提到机器学习中非常重要的相似度计算，就是分别计算对应位置的特征值差异获得的；因此如果物理意义都不想同，计算就没有意义了。<br>除了图像数据，最为常见还有谱图数据。谱图数据与图像数据类似，表达的是信号在不同波谱频域中的强度分布。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2017/12/03/Fun-with-your-first-Day-with-Matlab-S01E04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2017/12/03/Fun-with-your-first-Day-with-Matlab-S01E04/" itemprop="url">Fun with your first daty with Matlab S01E04</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-03T19:51:00+08:00">
                2017-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/MATLAB/" itemprop="url" rel="index">
                    <span itemprop="name">MATLAB</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h3 id="脚本的执行顺序控制"><a href="#脚本的执行顺序控制" class="headerlink" title="脚本的执行顺序控制"></a>脚本的执行顺序控制</h3><h4 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h4><h4 id="if-else-判断语句"><a href="#if-else-判断语句" class="headerlink" title="if-else 判断语句"></a>if-else 判断语句</h4><h4 id="switch-case分支语句"><a href="#switch-case分支语句" class="headerlink" title="switch-case分支语句"></a>switch-case分支语句</h4><h4 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h4><h4 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h4><h3 id="MATLAB中的函数"><a href="#MATLAB中的函数" class="headerlink" title="MATLAB中的函数"></a>MATLAB中的函数</h3><h4 id="创建函数文件"><a href="#创建函数文件" class="headerlink" title="创建函数文件"></a>创建函数文件</h4><h4 id="编写第一个函数"><a href="#编写第一个函数" class="headerlink" title="编写第一个函数"></a>编写第一个函数</h4><h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h4><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><h4 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h4><h4 id="公有与私有权限"><a href="#公有与私有权限" class="headerlink" title="公有与私有权限"></a>公有与私有权限</h4><h4 id="函数句柄"><a href="#函数句柄" class="headerlink" title="函数句柄"></a>函数句柄</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2017/11/22/复杂性思考/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2017/11/22/复杂性思考/" itemprop="url">Ideas of Complexity</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-22T20:55:35+08:00">
                2017-11-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/General-Science/" itemprop="url" rel="index">
                    <span itemprop="name">General Science</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="How-to-define-Complexity"><a href="#How-to-define-Complexity" class="headerlink" title="How to define Complexity?"></a>How to define Complexity?</h3><p>We may be sure of that static system can not produce complexity as complexity is emergenced from dynamics. While complexity system such as social behavior or genes expression usually can be modeled as network with many agents, I ask a question that can single series produce complexity?</p>
<p>To answer the question, we may begin with organized series such as const series$X_t = Const$ or series follows certain time related rule$X_t=A<em>sin(t)$. We may define these series as <strong>simple series</strong> instead of <strong>complex series</strong> for the rule is simple and easy to be found.Another side of the issue is that totally random series, we define this case as <em>*simple series</em></em> too for there is no rules to be found.</p>
<p>However, a subtle case is that the series is historical related, such as $X<em>t=f(X</em>{t-1},X<em>{t-2},…,X</em>{t-n})$, can we now define the series as <strong>complex series</strong>? The answer is yes and no. An important issue is that how complex the function $f(·)$(We then term the function as <strong>history function</strong>) is. For an example:<br>$$X_t = X_t + 1$$<br>In this case, we definitely define the series as simple. so why our definition change as the function become <strong>complex</strong>? The answer may be that we should introduce nonlinearity in our history function.</p>
<p>可以确定的是静态是无法产生复杂的，复杂是在动态中表现的行为。单个序列是否能够产生复杂的现象呢？当一个序列是有序的（如常量序列$X_t = Const$或者符合某个周期函数的序列$X_t=A<em>sin(t)$）或者是完全随机的，我们都可以认为这样的序列是简单的。同样的，简单的机制相互线性叠加产生的序列，如$X_t=A</em>sin(t)+random+Const$我们仍然认为是简单序列。但是如果一个序列是历史相关的，如$X<em>t=f(X</em>{t-1})$，我们是否应该认为这样的序列是复杂序列呢？</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hansenzhao.github.io/HansenZhao.github.io/2017/11/15/Fun-with-your-first-Day-with-Matlab-S01E03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hansen Zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/HansenZhao.github.io/images/zhs.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HansenZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/HansenZhao.github.io/2017/11/15/Fun-with-your-first-Day-with-Matlab-S01E03/" itemprop="url">Fun with your first daty with Matlab S01E03</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-15T15:02:35+08:00">
                2017-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/HansenZhao.github.io/categories/日志/MATLAB/" itemprop="url" rel="index">
                    <span itemprop="name">MATLAB</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>上一回我们讲述了MATLAB中最为重要的数据结构——数组的使用方法。这一次我们在讲述两个常用的数据结构，元胞和结构体。在实际使用的过程中，需要根据不同数据结构的特点以及需要完成的任务综合考虑需要什么样的数据结构。</p>
<h3 id="元胞"><a href="#元胞" class="headerlink" title="元胞"></a>元胞</h3><p>数组有一个特点，就是每一个元素储存的东西都必须是同类型的数据。如果想要存储不同类型的数据怎么办？这个时候就需要使用元胞了。</p>
<h4 id="创建元胞"><a href="#创建元胞" class="headerlink" title="创建元胞"></a>创建元胞</h4><p>元胞的创建是使用cell函数的：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = cell(<span class="number">3</span>,<span class="number">5</span>); <span class="comment">%创建3行5列的元胞</span></div></pre></td></tr></table></figure></p>
<p>这样就创建了一个元胞。除此之外，还可以直接创建元胞：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;;</div></pre></td></tr></table></figure></p>
<p>上面创建的元胞中包含3个字符。元胞还可以包含不同类型的数据：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b = &#123;<span class="string">'a'</span>,<span class="number">3</span>,<span class="string">'cdx'</span>&#125;;</div></pre></td></tr></table></figure></p>
<p>上面的元胞依次包含字符，数字以及字符串。<br>实际应用中，直接创建的可能性较少，大部分情况下都是先用cell函数创建空元胞，再使用索引将元胞的元素赋值为需要存储的变量。实际上，元胞和向量大部分情况下在MATLAB中都充当了数据的集合的作用。元胞和数组在使用的时候，需要占用内存空间，通常情况下，我们如果可以预先知道需要使用的元胞和数组的大小维度，就可以使用函数先声明相应大小的元胞或者数组，再将其中的元素赋值为我们需要的变量。如果需要扩大元胞或者数组的大小，这是非常耗时的一个操作。因为在这个操作中，实际上发生的是：声明一个新大小的元胞或者数组$\rightarrow$将原来的数据搬运到新声明的空间中$\rightarrow$销毁原来的元胞或者数组，释放空间</p>
<p>想想也觉得很麻烦吧！</p>
<h4 id="元胞元素操作"><a href="#元胞元素操作" class="headerlink" title="元胞元素操作"></a>元胞元素操作</h4><p>获取元胞的单个元素可以使用大括号操作，修改值也是这样<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">12</span>&#125;;</div><div class="line">a&#123;<span class="number">1</span>&#125;</div><div class="line"><span class="built_in">ans</span> = <span class="number">2</span></div><div class="line">a&#123;<span class="number">1</span>&#125; = <span class="string">'s'</span></div><div class="line"><span class="built_in">ans</span> = &#123;<span class="string">'s'</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">12</span>&#125;</div></pre></td></tr></table></figure></p>
<p>如果要对元胞进行切片，切片是指从数据的集合中获取一个子集。元胞的切片也是使用圆括号的<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">12</span>&#125;;</div><div class="line">b = a([<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>])</div><div class="line">b = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>&#125;</div></pre></td></tr></table></figure></p>
<p>要想同时改变元胞中的多个元素的值也是使用圆括号，赋值的项需要是元胞<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">12</span>&#125;;</div><div class="line">a([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) = &#123;inf&#125; <span class="comment">%广播赋值</span></div><div class="line">a = &#123;inf,inf,inf,<span class="number">11</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">12</span>&#125;</div><div class="line">a([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) = &#123;<span class="string">'s'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>&#125; <span class="comment">%按元素赋值</span></div><div class="line">a = &#123;<span class="string">'s'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">12</span>&#125;</div></pre></td></tr></table></figure></p>
<p>如果想要删除元素，直接使用圆括号和空集就可以<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">12</span>&#125;;</div><div class="line">a([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) = &#123;[]&#125; <span class="comment">%赋值为空集</span></div><div class="line">a = &#123;[],[],[],<span class="number">11</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">12</span>&#125;;</div><div class="line">a([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) = [] <span class="comment">%删除</span></div><div class="line">a = &#123;<span class="number">11</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">12</span>&#125;;</div></pre></td></tr></table></figure></p>
<p>上面的运算也都可以使用上一次讲的逻辑索引</p>
<h4 id="元胞与数组的转换"><a href="#元胞与数组的转换" class="headerlink" title="元胞与数组的转换"></a>元胞与数组的转换</h4><p>有的时候需要将元胞和数组相互转换。当一个元胞是全部由同种类型的数据组成的时候，就可以转换为数组。<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</div><div class="line">b = cell2mat(a)</div><div class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</div></pre></td></tr></table></figure></p>
<p>这样做有什么样的好处呢？前面我们说过，当使用数据集合的时候，最好能够提前知道需要的容量大小，然后再通过索引存入到数据集合中，当有些情况下，我们没有办法提前知道需要的容量，这个时候可能可以使用元胞优化。例如下面的程序，someFunc是一个返回任意长度的<strong>行</strong>向量的函数，我们需要调用它两次，将两次的结果放在同一个向量中，并求取平均值：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">%需要在运行中扩展向量大小的方法</span></div><div class="line">a = [];</div><div class="line">a = [a,someFunc()]; <span class="comment">%扩展大小，重新申请空间</span></div><div class="line">a = [a,someFunc()]; <span class="comment">%扩展大小，重新申请空间</span></div><div class="line">res = mean(a)</div><div class="line"></div><div class="line"><span class="comment">%不需要重新申请空间</span></div><div class="line">a = cell(<span class="number">2</span>,<span class="number">1</span>); <span class="comment">%两行一列的元胞</span></div><div class="line">a&#123;<span class="number">1</span>&#125; = someFunc();</div><div class="line">a&#123;<span class="number">2</span>&#125; = someFunc();</div><div class="line">a = cell2mat(a)；</div><div class="line">res = mean(a);</div></pre></td></tr></table></figure></p>
<p>反过来，也可以用mat2cell来将向量转换为元胞</p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>除了元胞，还有一个常用的保存不同类型数据的容器成为结构体（struct)。与前面讲的元胞和向量不同，结构体中存取数据是通过变量名称的，而前者实际上是使用数据所在位置的下标的。通过变量名称存取数据的好处是可以让程序更加容易阅读，毕竟变量名往往都是使用人类容易理解和符号表示的；但是使用下标容易大批量的存储，修改以及取出。因此，结构体往往用来存储性质不同但聚合程度很高的数据。什么意思呢？譬如我们可以使用元胞存储长度不一的字符串，他们性质不同（长度不同)，同时聚合度不高，也就是说相互之间没有关系。但是，同样的，如果我们需要储存几个长度不同的字符串，分别为一个对象的名称，描述，型号和价格，这些数据相互之间性质不同，但在意义上有很强的关联性，因为它们同样属于一个对象的性质，这个时候就非常适合使用结构体了。</p>
<h4 id="使用结构体"><a href="#使用结构体" class="headerlink" title="使用结构体"></a>使用结构体</h4><p>创建结构体使用struct函数，我们这里假设创建一个游戏中的角色，大天使bigAngel哈哈哈<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">bigAngel = struct() <span class="comment">%创建结构体</span></div><div class="line">bigAngel.HP = <span class="number">1000</span>; <span class="comment">%血量1k</span></div><div class="line">bigAngel.MP = <span class="number">2000</span>; <span class="comment">%魔法2k</span></div><div class="line">bigAngel.name = <span class="string">'Big Angel'</span> <span class="comment">%游戏名称</span></div><div class="line">bigAngel.skill = <span class="string">'Healing'</span> <span class="comment">%技能是治愈</span></div></pre></td></tr></table></figure></p>
<p>在结构体中，使用<strong>结构体名称.数据名称</strong>的方式来存取数据，这样的方式使得代码的可读性非常高，表达的意思的<strong>结构体XX的属性XXX</strong>的含义<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">bigAngel.HP <span class="comment">%查看bigAngel中HP的属性</span></div><div class="line"><span class="built_in">ans</span> = <span class="number">1000</span></div><div class="line">bigAngel.HP = <span class="number">2000</span></div><div class="line">bigAngel.HP <span class="comment">%给bigAngel中的HP属性赋值</span></div><div class="line"><span class="built_in">ans</span> = <span class="number">2000</span></div></pre></td></tr></table></figure></p>
<p>在像C++，C#这样的语言中，一个结构体中包含哪些属性，属性类型和名称名称是什么，都是提前设定好的，在使用过程中不能更改。但是在MATLAB，Python这样的动态语言中，像上面的例子一样，我们在定义结构体时，只需要使用struct函数，而给属性赋值的时候，如果这个属性以前定义过，就更更新属性值，如果从来没有定义过，就新建一个相应属性名称的属性，将值赋给新建的属性。这样的方式非常灵活，但有时候也会出现bug，例如上述的bigAngel的例子<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bigAngel.skil = <span class="string">'Purify'</span> <span class="comment">%本意是更改skill属性，但是打错为skil</span></div><div class="line">bigAngel.skill</div><div class="line"><span class="built_in">ans</span> = <span class="string">'Healing'</span> <span class="comment">%导致属性skill并没有如预期改变</span></div></pre></td></tr></table></figure></p>
<h4 id="结构体相关函数"><a href="#结构体相关函数" class="headerlink" title="结构体相关函数"></a>结构体相关函数</h4><p>结构体有很多相关的常用函数：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = isstruct(b) <span class="comment">%判断b是否为一个结构体</span></div><div class="line">a = isfield(b,C) <span class="comment">%判断某个字符串是否为结构体b的属性，C可以是单个字符串，也可以是一个由字符串构成的元胞</span></div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/HansenZhao.github.io/page/2/">2</a><a class="extend next" rel="next" href="/HansenZhao.github.io/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/HansenZhao.github.io/images/zhs.png"
                alt="Hansen Zhao" />
            
              <p class="site-author-name" itemprop="name">Hansen Zhao</p>
              <p class="site-description motion-element" itemprop="description">Machine Learning & Coding</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/HansenZhao.github.io/archives/">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/HansenZhao.github.io/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/HansenZhao" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="zhaohs12@163.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hansen Zhao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/HansenZhao.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/HansenZhao.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/HansenZhao.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/HansenZhao.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/HansenZhao.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/HansenZhao.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/HansenZhao.github.io/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/HansenZhao.github.io/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/HansenZhao.github.io/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
